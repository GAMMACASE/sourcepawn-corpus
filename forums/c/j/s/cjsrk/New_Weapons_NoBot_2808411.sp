/* Plugin Template generated by Pawn Studio */

#include <sdktools>
#include <sourcemod>
#include <sdkhooks>


new Handle:cvarEnable;
new Handle:cvarAllowBuyTime;
new Handle:cvarNewWalkSpeed;
new bool:isEnabled;    //启动或禁用插件变量
static int allowBuyTime = 0;    //购买时间上限变量
static float newWalkSpeed = 1.0;    //获取新武器之后的玩家行走速度（用于提升因客户端预测关闭而变慢的行走速度）

//定义新武器索引数组
static int iEntNewWeaponList[256] = {0};

static char NewWeaponNames[256][30];    //新武器名字数组
static char NewWeaponFatherNames[256][10];    //新武器的父类武器名字数组
static int IsNewWeaponUseShootSound[256] = {0};    //新武器由插件播放射击声开关数组
static char NewWeaponShootSound[256][50];    //新武器射击声文件路径数组
static int NewWeaponAmmo[256] = {0};    //新武器备弹量数组
static float NewWeaponDamage[256] = {0};    //新武器伤害值倍数数组
static float NewWeaponAccuracy[256] = {0};    //新武器精度差数组
static int NewWeaponPrice[256] = {0};    //新武器购买价格数组
static float GetNewWeaponTime[256] = {0};    //记录新武器购买时间数组

static float RoundStartTime = 0.0;    //每回合开始时间
int ClientPredict[128] = 1;    //客户端预测状态，0为已禁用，1为启用


public Plugin:myinfo = {
	name = "New Weapons Without Bot",
	author = "cjsrk",
	description = "<- Add New Weapons ->",
	version = "1.1",
	url = "<- URL ->"
}


public OnPluginStart(){
	//设置配置文件
	CreateConVar("sm_new_weapons_version", "1.1.0", "Plugin Version", FCVAR_SPONLY|FCVAR_REPLICATED|FCVAR_NOTIFY);
	cvarEnable = CreateConVar("sm_new_weapons_enable", "1", "Whether to enable the plugin (1: Enable the plugin. 0: disabled)", _, true, 0.0, true, 1.0);
	cvarAllowBuyTime = CreateConVar("sm_allow_buytime", "90", "Sets the maximum time to acquire new weapons after the start of a turn, in seconds (range: 5-300 seconds)", _, true, 5.0, true, 300.0);
	cvarNewWalkSpeed = CreateConVar("sm_new_walkspeed", "1.1", "The player's walk speed after acquiring new weapons ranges from 1.0 (the default speed) to 1.5.", _, true, 1.0, true, 1.5);
	AutoExecConfig(true, "plugin.new_weapons");
	HookConVarChange(cvarEnable, CvarChange);
	HookConVarChange(cvarAllowBuyTime, CvarChange);
	HookConVarChange(cvarNewWalkSpeed, CvarChange);
	
	HookEvent("round_start", RoundStart, EventHookMode_Post);
	HookEvent("weapon_fire", WeaponOldSound, EventHookMode_Pre);
	AddNormalSoundHook(SHook2);
	AddTempEntHook("Shotgun Shot", Hook_FireTE);
}


public OnMapStart(){
    //读取新武器信息文件	
	new String:filepath[PLATFORM_MAX_PATH];
	BuildPath(Path_SM, filepath, PLATFORM_MAX_PATH, "configs/NewWeaponsInfo.txt");
	new Handle:file = OpenFile(filepath, "r"); 
	if(file != INVALID_HANDLE){
		
		decl String:fileline[256];
		decl String:data[8][256];
		static int num = 0;
		
		while(ReadFileLine(file, fileline, 256))
		{		
			if(ExplodeString(fileline, "><", data, 8, 256) == 8)
			{
				if(strlen(data[0]) > 0 && strlen(data[1]) > 0)
				{
					//将新武器信息文件的数据载入各个新武器信息数组
					TrimString(data[0]);
					TrimString(data[1]);
					TrimString(data[2]);
					TrimString(data[3]);
					TrimString(data[4]);
					TrimString(data[5]);
					TrimString(data[6]);
					TrimString(data[7]);
					if(strlen(data[0]) > 0)
					    ReplaceString(data[0], strlen(data[0]), "<", "");
					if(strlen(data[7]) > 0)
					    ReplaceString(data[7], strlen(data[7]), ">", "");
					
					strcopy(NewWeaponNames[num], strlen(data[0]) + 1, data[0]);
					strcopy(NewWeaponFatherNames[num], strlen(data[1]) + 1, data[1]);
					
					new isUseShootSound = 0;
					if(strlen(data[2]) > 0)
						isUseShootSound = StringToInt(data[2]);
				    IsNewWeaponUseShootSound[num] = isUseShootSound;
					
					if(strlen(data[3]) > 0)
					    strcopy(NewWeaponShootSound[num], strlen(data[3]) + 1, data[3]);
					
					new ammo = 0;
					if(strlen(data[4]) > 0)
						ammo = StringToInt(data[4]);
					if(ammo < 0)
						ammo = 0;
				    NewWeaponAmmo[num] = ammo;
					
					new damage = 0.0;
					if(strlen(data[5]) > 0)
						damage = StringToFloat(data[5]);
				    NewWeaponDamage[num] = damage;
					
					new accuracy = 0.0;
					if(strlen(data[6]) > 0)
						accuracy = StringToFloat(data[6]);
				    NewWeaponAccuracy[num] = accuracy;
					
					new price = 0;
					if(strlen(data[7]) > 0)
						price = StringToInt(data[7]);
					if(price < 0)
						price = 0;
				    NewWeaponPrice[num] = price;
					num++;
				}
			    				
			}
			
		}	
		
		CloseHandle(file);		
	}
	
	//遍历各新武器信息数组，预载新武器模型文件和射击声音文件
	for(int i = 0; i <= 255; i++) {
		if(strlen(NewWeaponNames[i]) > 0 && strlen(NewWeaponFatherNames[i]) > 0)
		{
			decl String:PreStr0[] = "sm_";
			decl String:PreStr1[] = "models/weapons/v_";
			decl String:PreStr2[] = "models/weapons/w_";
			decl String:PreStr3[] = ".mdl";
			decl String:PreStr4[] = "_silencer.mdl";
			decl String:PreStr5[] = "_dropped.mdl";
			decl String:PreStr6[] = "_thrown.mdl";
			
			decl String:MyConsole[32];
			Format(MyConsole, sizeof(MyConsole), "%s%s", PreStr0, NewWeaponNames[i]);
			TrimString(MyConsole);
			RegConsoleCmd(MyConsole,Cmd_CreateAnaconda);    //注册获取新武器的控制台命令
			
			decl String:Path1[64];
			Format(Path1, sizeof(Path1), "%s%s%s", PreStr1, NewWeaponNames[i], PreStr3);
			TrimString(Path1);
			PrecacheModel(Path1);
			
			decl String:Path2[64];
			Format(Path2, sizeof(Path2), "%s%s%s", PreStr2, NewWeaponNames[i], PreStr3);
			TrimString(Path2);
			PrecacheModel(Path2);
			
			if(StrEqual(NewWeaponFatherNames[i], "usp") || StrEqual(NewWeaponFatherNames[i], "m4a1"))
			{
				decl String:Path3[64];
			    Format(Path3, sizeof(Path3), "%s%s%s", PreStr2, NewWeaponNames[i], PreStr4);
			    TrimString(Path3);
				PrecacheModel(Path3);
			}
			if(StrEqual(NewWeaponFatherNames[i], "elite"))
			{
				decl String:Path4[64];
			    Format(Path4, sizeof(Path4), "%s%s%s", PreStr2, NewWeaponNames[i], PreStr5);
			    TrimString(Path4);
				PrecacheModel(Path4);
			}			
			if(StrEqual(NewWeaponFatherNames[i], "hegrenade"))
			{
				decl String:Path5[64];
			    Format(Path5, sizeof(Path5), "%s%s%s", PreStr2, NewWeaponNames[i], PreStr6);
			    TrimString(Path5);
				PrecacheModel(Path5);
			}
			
			//如果新武器由插件播放射击声开关的值为1或2，则预载射击声音文件
			if(IsNewWeaponUseShootSound[i] > 0 && strlen(NewWeaponShootSound[i]) > 0)
		    {
				if(IsNewWeaponUseShootSound[i] == 1 || IsNewWeaponUseShootSound[i] == 2)
				{
					PrecacheSound(NewWeaponShootSound[i]);
				}			    
		    }			
		}
	}
	
	for(int i = 0; i <= (sizeof(ClientPredict) - 1); i++) {
		ClientPredict[i] = 1;
	}
}

//读取配置文件的cvar的值
public OnConfigsExecuted()
{
	isEnabled = GetConVarBool(cvarEnable);
	allowBuyTime = GetConVarInt(cvarAllowBuyTime);
	newWalkSpeed = GetConVarFloat(cvarNewWalkSpeed);
}

//cvar值变化时的响应数组
public CvarChange(Handle:convar, const String:oldValue[], const String:newValue[])
{
    if(convar == cvarEnable)
	{
		if(StringToInt(newValue) == 1)
		{
			isEnabled = true;
		}
		else
		{
			isEnabled = false;
		}
	}
	if(convar == cvarAllowBuyTime)
	{
		if(StringToInt(newValue) < 5)
			allowBuyTime = 5;
		else if(StringToInt(newValue) > 300)
			allowBuyTime = 300;
		else
		    allowBuyTime = StringToInt(newValue);
	}
	if(convar == cvarNewWalkSpeed)
	{
		if(StringToFloat(newValue) < 1.0)
			newWalkSpeed = 1.0;
		else if(StringToFloat(newValue) > 1.5)
			newWalkSpeed = 1.5;
		else
		    newWalkSpeed = StringToFloat(newValue);
	}
}


public OnClientPutInServer(client)
{
	SDKHook(client, SDKHook_OnTakeDamage, OnTakeDamage);  
    SDKHook(client, SDKHook_PostThink, OnPostThink);
    SDKHook(client, SDKHook_WeaponEquipPost, OnWeaponEquip3);
}

//获取新武器的控制台命令响应函数
public Action:Cmd_CreateAnaconda(Client,Args){
	if(!Client)Client=1;
	new TimeLeft = GetTickedTime() - RoundStartTime;    //获取离本回合开始已经过去了多少时间
	
	decl String:sText[256]; 
	GetCmdArg(0, sText, sizeof(sText));    //获取输入的控制台命令内容
	StripQuotes(sText);
	TrimString(sText);
	ReplaceStringEx(sText, strlen(sText), "_", ";");
	decl String:ArgumentStr[2][30];
	ExplodeString(sText, ";", ArgumentStr, 2, 30);
	
	if(isEnabled == false)
	{
		PrintToChat(Client, "Warning: The plugin is disabled, you cannot get new weapons!");
		return;
	}
	
	if(!IsPlayerAlive(Client))
		return;
	
	if(RoundFloat(TimeLeft) >= allowBuyTime)
	{
		PrintToChat(Client, "Tip: The countdown has ended, you can no longer get new weapons!");
		return;
	}
	
	//找到和用户输入获取新武器的控制台命令相匹配的新武器
	int num = -1;
	for(int i = 0; i <= (sizeof(NewWeaponNames) - 1); i++) {
		if(StrEqual(NewWeaponNames[i], ArgumentStr[1]))
		{
			num = i;
			break;
		}
	}
	
	if(num > -1)
	{
        if(GetNewWeaponTime[num] > 0)
		{
			new TempTime = GetTickedTime() - GetNewWeaponTime[num];			
			if(TempTime < 0.01)
				return;
		}
		
		new myMoney = GetEntProp(Client, Prop_Send, "m_iAccount");
		if(NewWeaponPrice[num] > 0)
		{
			if(myMoney <= 0 || myMoney < NewWeaponPrice[num])
            {
                PrintToChat(Client, "Tip: Weapons cost $ %d, you don't have enough funds to get new weapons!", NewWeaponPrice[num]);
                return;
            }
            SetEntProp(Client, Prop_Send, "m_iAccount", myMoney - NewWeaponPrice[num]);
		}
		
		//如果是获取新刀，则先要丢弃原来的匕首
		if(StrEqual(NewWeaponFatherNames[num], "knife"))
		{
			new knife = GetPlayerWeaponSlot(Client, 2);
			SDKHooks_DropWeapon(Client, knife);
		}
		
		decl String:PreStr[] = "weapon_";
		decl String:str1[32];
		Format(str1, sizeof(str1), "%s%s", PreStr, NewWeaponFatherNames[num]);
		TrimString(str1);
		iEntNewWeaponList[num] = CreateEntityByName(str1);    //设置新武器的父类武器
		
		decl String:str2[32];
		Format(str2, sizeof(str2), "%s%s", PreStr, NewWeaponNames[num]);
		TrimString(str2);
	    DispatchKeyValue(iEntNewWeaponList[num],"classname",str2);    //设置新武器类名
		
		//如果新武器不是刀或者手雷，则设置备弹量
		if(!StrEqual(NewWeaponFatherNames[num], "knife") && !StrEqual(NewWeaponFatherNames[num], "hegrenade"))
		{
			static String:MyWeaponAmmo[10]; 
		    IntToString(NewWeaponAmmo[num], MyWeaponAmmo, 10);
			DispatchKeyValue(iEntNewWeaponList[num],"ammo",MyWeaponAmmo);
		}
		
		DispatchSpawn(iEntNewWeaponList[num]);
	    ActivateEntity(iEntNewWeaponList[num]);
        EquipPlayerWeapon(Client,iEntNewWeaponList[num]);    //为用户装备新武器
		GetNewWeaponTime[num] = GetTickedTime();
        
		//如果新武器不是刀或者手雷，则再次设置备弹量
		if(!StrEqual(NewWeaponFatherNames[num], "knife") && !StrEqual(NewWeaponFatherNames[num], "hegrenade"))
		{
			new MyWeaponType = GetEntProp(iEntNewWeaponList[num], Prop_Data, "m_iPrimaryAmmoType")
            if(GetEntProp(Client, Prop_Data, "m_iAmmo", 4, MyWeaponType) <= 0)
	        {
		        SetEntProp(Client, Prop_Data, "m_iAmmo", NewWeaponAmmo[num], 4, MyWeaponType);
	        }
		}		
	}
}


//武器射击事件函数
public WeaponOldSound(Handle:event,const String:name[],bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	FadeClientVolume(client,100.0, 0.0, 0.04, 0.0);
	CreateTimer(0.04, Timer_PrintMessageFiveTimes, client);
	return Plugin_Continue;
}

//播放新武器射击声音函数
public Action:Timer_PrintMessageFiveTimes(Handle timer, int client)
{
	//获取当前武器名字
	if(!IsValidEntity(client))
		return Plugin_Continue;
	if(HasEntProp(client, Prop_Send, "m_hActiveWeapon") == false)
		return Plugin_Continue;
	
	new currentWeapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
    if (!IsValidEdict(currentWeapon) || (currentWeapon == -1))
		    return Plugin_Continue;	
	decl String:sWeapon[32];
	GetEdictClassname(currentWeapon, sWeapon, sizeof(sWeapon));
	ReplaceStringEx(sWeapon, strlen(sWeapon), "_", ";");
	decl String:data[2][30];
	ExplodeString(sWeapon, ";", data, 2, 30);
	
	int myWeapon = -1;
	for(int i = 0; i <= (sizeof(NewWeaponNames) - 1); i++) {
		if(StrEqual(NewWeaponNames[i], data[1]))
		{
			myWeapon = i;
			break;
		}
	}
	if(myWeapon > -1)
	{
		//根据新武器由插件播放射击声开关的值决定如何播放射击声音
		if(IsNewWeaponUseShootSound[myWeapon] == 1)
		{
			decl String:PreStr[] = "play ";			
			decl String:str[64];
		    Format(str, sizeof(str), "%s%s", PreStr, NewWeaponShootSound[myWeapon]);
		    TrimString(str);
			ClientCommand(client, str);
			return Plugin_Changed;
		}
		if(IsNewWeaponUseShootSound[myWeapon] == 2)
		{
			// EmitSoundToClient(client, NewWeaponShootSound[myWeapon], currentWeapon, 1);
			EmitSoundToAll(NewWeaponShootSound[myWeapon], currentWeapon, 1);
			return Plugin_Changed;
		}
		
		if(!IsFakeClient(client))    //如果玩家不是bot
		{
			if (CheckCommandAccess(client, "generic_admin", ADMFLAG_GENERIC, false))
			{
				// 玩家是房主
			}
			else    // 玩家不是房主，是普通真人玩家
			{
				if(!StrEqual("", NewWeaponShootSound[myWeapon]))
				{
					EmitSoundToClient(client, NewWeaponShootSound[myWeapon], currentWeapon, 1);    //不是服务器房主的真人玩家，播放武器射击声
				}
			}
		}
		
		//如果父类武器为手雷，则执行改变手雷抛出模型的函数
		if(StrEqual(NewWeaponFatherNames[myWeapon], "hegrenade"))
		{
			DataPack pack = new DataPack();
		    pack.WriteCell(client);
		    pack.WriteString(NewWeaponNames[myWeapon]);
			CreateTimer(0.01, Hegrenade_Throw, pack);
		}
	}
    return Plugin_Continue;
}


//修改新武器伤害值函数
public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	if(attacker == inflictor && inflictor <= MaxClients)
	{
		if(!IsValidEntity(attacker))
		    return Plugin_Continue;
	    if(HasEntProp(attacker, Prop_Send, "m_hActiveWeapon") == false)
		    return Plugin_Continue;
		
		new currentWeapon = GetEntPropEnt(attacker, Prop_Send, "m_hActiveWeapon");
		if (!IsValidEdict(currentWeapon) || (currentWeapon == -1))
		    return Plugin_Continue;
	    decl String:sWeapon[32];
	    GetEdictClassname(currentWeapon, sWeapon, sizeof(sWeapon));
		ReplaceStringEx(sWeapon, strlen(sWeapon), "_", ";");
		decl String:data[2][30];
	    ExplodeString(sWeapon, ";", data, 2, 30);
		
	    int myWeapon = -1;
		for(int i = 0; i <= (sizeof(NewWeaponNames) - 1); i++) {
			if(StrEqual(NewWeaponNames[i], data[1]))
		    {
			    myWeapon = i;
			    break;
		    }
		}
		
		//此函数对手雷无效
		if(myWeapon > -1 && !StrEqual(NewWeaponFatherNames[myWeapon], "hegrenade"))  
		{
			if(NewWeaponDamage[myWeapon] > 0)
			{
				//新武器伤害倍率，新武器初始伤害值等于父类武器的伤害值。1.0表示不变，2.0表示将新武器伤害值改为初始伤害值的两倍
				damage *= NewWeaponDamage[myWeapon]; 					
			    return Plugin_Changed;
			}
		}
	}
	return Plugin_Continue;
}

//改变手雷抛出模型函数，以修复旧版加枪插件不能加载手雷抛出模型的bug
public Action:Hegrenade_Throw(Handle:timer, DataPack pack)
{
	new ent = -1;
	new lastent;
	new owner;
	
	pack.Reset(); 
	int client = pack.ReadCell();
	decl String:WeaponName[32];
	pack.ReadString(WeaponName, sizeof(WeaponName));
	CloseHandle(pack);
	
	ent = FindEntityByClassname(ent, "hegrenade_projectile")	
	while (ent != -1)
	{
		owner = GetEntPropEnt(ent, Prop_Send, "m_hThrower")		
		if (IsValidEntity(ent) && owner == client)
			break;
		
		ent = FindEntityByClassname(ent, "hegrenade_projectile")		
		if (ent == lastent)
		{
			ent = -1;
			break;
		}		
		lastent = ent
	}
	
	if (ent != -1)
	{	
		decl String:PreStr1[] = "models/weapons/w_";
		decl String:PreStr2[] = "_thrown.mdl";
		decl String:Path[64];
		Format(Path, sizeof(Path), "%s%s%s", PreStr1, WeaponName, PreStr2);
		TrimString(Path);
		//如果新手雷附带throw模型，则加载新手雷的抛出模型
		if(FileExists(Path, true))
			SetEntityModel(ent, Path);
	}
}


//修改新武器精度差函数
public OnPostThink(client)
{
	new Buttons = GetClientButtons(client);
	if (Buttons & IN_ATTACK)
	{
		new currentWeapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
	    if (!IsValidEdict(currentWeapon) || (currentWeapon == -1))
		    return Plugin_Continue;	
		decl String:sWeapon[32];
	    GetEdictClassname(currentWeapon, sWeapon, sizeof(sWeapon));
		ReplaceStringEx(sWeapon, strlen(sWeapon), "_", ";");
	    decl String:data[2][30];
	    ExplodeString(sWeapon, ";", data, 2, 30);
		
		int myWeapon = -1;
		for(int i = 0; i <= (sizeof(NewWeaponNames) - 1); i++) {
			if(StrEqual(NewWeaponNames[i], data[1]))
		    {
			    myWeapon = i;
			    break;
		    }
		}
		
		//此函数不用于刀和手雷
	    if(myWeapon > -1 && !StrEqual(NewWeaponFatherNames[myWeapon], "hegrenade") && !StrEqual(NewWeaponFatherNames[myWeapon], "knife"))
	    {
			if(NewWeaponAccuracy[myWeapon] > 0 && NewWeaponAccuracy[myWeapon] <= 1)
			{
				//可设置精度差范围0.0（不含）-1.0，值0.0将使用基本点差而不是没有精度差
				SetEntPropFloat(currentWeapon, Prop_Send, "m_fAccuracyPenalty", NewWeaponAccuracy[myWeapon]);			
			    return Plugin_Changed;
			}
	    }
	}
	return Plugin_Continue;
}


//修复起源v9x版本闪烁问题
public void:OnWeaponEquip3(client, weapon)
{
	if(!IsValidEntity(client))
		return;
    char sWeapon[64];
    GetEdictClassname(weapon, sWeapon, sizeof(sWeapon));
	ReplaceStringEx(sWeapon, strlen(sWeapon), "_", ";");
	char data[2][30];
	ExplodeString(sWeapon, ";", data, 2, 30);
	
	int myWeapon = -1;
	for(int i = 0; i <= (sizeof(NewWeaponNames) - 1); i++) {
		if(StrEqual(NewWeaponNames[i], data[1]))
		{
			myWeapon = i;
			break;
		}
	}
	if(myWeapon > -1 && IsClient(client, true) && !IsFakeClient(client))
	{
		int OwnerId = -1;
		for(int i = 1; i <= MaxClients; i++)
		{
			if(IsClientInGame(i) && IsPlayerAlive(i) && !IsFakeClient(i))
			{
				// 记录房主的id
				if (CheckCommandAccess(i, "generic_admin", ADMFLAG_GENERIC, false))
				{
					OwnerId = i;
				}
			}
		}
		
		ClientCommand(client, "sv_client_predict 0");    //禁用客户端预测
		ClientPredict[client] = 0;
		SetEntPropFloat(client, Prop_Data, "m_flLaggedMovementValue", newWalkSpeed); 
		
		// 如果是非房主真人玩家购买新枪，则禁用服务器客户端预测
		if(client != OwnerId && OwnerId > 0)
		{
			ServerCommand("sv_client_predict 0");
			// 调整其他真人玩家的ClientPredict值（包括房主）
			for(int i = 1; i <= MaxClients; i++)
			{
				if(IsClientInGame(i) && IsPlayerAlive(i) && !IsFakeClient(i))
				{
					if(i != client)
					{
						ClientPredict[i] = 0;
						SetEntPropFloat(i, Prop_Data, "m_flLaggedMovementValue", newWalkSpeed);
					}
				}
			}
		}
		
	}	
}


//修复禁用客户端预测时某些声音消失的bug
public Action:SHook2(clients[64], &numClients, String:sample[PLATFORM_MAX_PATH], &entity, &channel, &Float:volume, &level, &pitch, &flags)
{
	//修复禁用客户端预测时刀子声音消失的bug
	if (IsValidEdict(entity) && (entity > -1))
	{
		char sWeapon[64];
		GetEdictClassname(entity, sWeapon, sizeof(sWeapon));
	if(StrContains(sWeapon, "weapon_knife") != -1 || StrContains(sample, "knife") != -1)
		{
			int owner = GetEntPropEnt(entity, Prop_Send, "m_hOwnerEntity");
			if(IsValidEntity(owner) && owner > 0 && owner <= MaxClients && ClientPredict[owner] == 0)
			{
				if(StrContains(sample, ".wav") != -1)
				{
					EmitSoundToClient(owner, sample, entity, channel, level, flags, volume, pitch);
					
					// 声音也传递给其他关闭预测的真人玩家
					for(int i = 1; i <= MaxClients; i++)
					{
						if(IsClientInGame(i) && !IsFakeClient(i) && ClientPredict[i] == 0)
						{
							if(i != owner)
							{
								EmitSoundToClient(i, sample, entity, channel, level, flags, volume, pitch);
							}
						}
					}
					
				}
				else
				{
					char MySound2[256];
					Format(MySound2, sizeof(MySound2), "%s%s", sample, ".wav");
					EmitSoundToClient(owner, MySound2, entity, channel, level, flags, volume, pitch);
					
					// 声音也传递给其他关闭预测的真人玩家
					for(int i = 1; i <= MaxClients; i++)
					{
						if(IsClientInGame(i) && !IsFakeClient(i) && ClientPredict[i] == 0)
						{
							if(i != owner)
							{
								EmitSoundToClient(i, sample, entity, channel, level, flags, volume, pitch);
							}
						}
					}
					
				}
			}
		}		
	}
	
	//修复禁用客户端预测时脚步声消失的bug
    if(StrContains(sample, "player/footsteps") != -1 || StrContains(sample, "player/land") != -1 )
    {
		  decl String:str11[32];
	      GetEdictClassname(entity, str11, sizeof(str11));
		  if(IsValidEntity(entity) && entity > 0 && entity <= MaxClients && ClientPredict[entity] == 0)
		  {
			  // PrintToChat(entity, "提示：响应！");
			  // EmitSound(clients, numClients, sample, entity, channel, level, flags, volume, pitch);
			  if(StrContains(sample, ".wav") != -1)
			  {
				  EmitSoundToClient(entity, sample, entity, channel, level, flags, volume, pitch);
				  
				  // 声音也传递给其他关闭预测的真人玩家
				    for(int i = 1; i <= MaxClients; i++)
					{
						if(IsClientInGame(i) && !IsFakeClient(i) && ClientPredict[i] == 0)
						{
							if(i != entity)
							{
								EmitSoundToClient(i, sample, entity, channel, level, flags, volume, pitch);
							}
						}
					}
					
			  }
			  else
			  {
				char MySound2[256];
				Format(MySound2, sizeof(MySound2), "%s%s", sample, ".wav");
				EmitSoundToClient(entity, MySound2, entity, channel, level, flags, volume, pitch);
				  
				// 声音也传递给其他关闭预测的真人玩家
				for(int i = 1; i <= MaxClients; i++)
				{
					if(IsClientInGame(i) && !IsFakeClient(i) && ClientPredict[i] == 0)
					{
						if(i != entity)
						{
							EmitSoundToClient(i, sample, entity, channel, level, flags, volume, pitch);
						}
					}
				}
				
			  }			  
		  }
    }
    return Plugin_Continue;
}


//修复禁用客户端预测时新枪弹孔消失的bug
public Action Hook_FireTE(const char[] te_name, const int[] Players, int numClients, float delay)
{
	new client = TE_ReadNum("m_iPlayer") + 1;
	if(IsValidEntity(client) && client > 0 && client <= MaxClients && ClientPredict[client] == 0)
    {
		int MyShoot = -1;
		for(int i = 0; i < numClients; i++) {
			if(Players[i] == client)
		    {
			    MyShoot = i;
			    break;
		    }
		}
		if(MyShoot == -1)
		{
			// PrintToChat(client, "符合客户实体：%d", client);
			if(HasEntProp(client, Prop_Send, "m_hActiveWeapon") == false)
		        return Plugin_Continue;
			new currentWeapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
			int myWeapon = -1;			
			if (IsValidEdict(currentWeapon) && (currentWeapon > -1))
			{
				char sWeapon[64];
				GetEdictClassname(currentWeapon, sWeapon, sizeof(sWeapon));
				ReplaceStringEx(sWeapon, strlen(sWeapon), "_", ";");
				char data[2][30];
				ExplodeString(sWeapon, ";", data, 2, 30);
				
				
				for(int i = 0; i <= (sizeof(NewWeaponNames) - 1); i++) {
					if(StrEqual(NewWeaponNames[i], data[1]))
					{
						myWeapon = i;
						break;
					}
				}
			}				
            	
			if(myWeapon == -1 && IsFakeClient(client))
				return Plugin_Continue;
			if (myWeapon > -1)
			{
				int MyMode = TE_ReadNum("m_iMode");
				if( MyMode == 1 && StrEqual(NewWeaponFatherNames[myWeapon], "sg550") )
					 TE_WriteNum("m_iWeaponID", 13);    //连狙开镜时只能发出父类武器的枪声      
                if( MyMode == 1 && StrEqual(NewWeaponFatherNames[myWeapon], "g3sg1") )
					TE_WriteNum("m_iWeaponID", 23);    //连狙开镜时只能发出父类武器的枪声     		
				if(MyMode == 0 || ( !StrEqual(NewWeaponFatherNames[myWeapon], "sg550") && !StrEqual(NewWeaponFatherNames[myWeapon], "g3sg1")) ) 
				{
					TE_WriteNum("m_iWeaponID", 24);    //修复客户端新枪的枪声变为原版武器的bug
				}				    
			}		
			
			// 检测真人玩家数量
			int RealPlayerNum = 0;
			for(int i = 1; i <= MaxClients; i++)
			{
				if(IsClientInGame(i) && !IsFakeClient(i))
				{
					RealPlayerNum++;
				}
			}
			
			// 非联机状态
			if(RealPlayerNum <= 1)
			{
				numClients ++;
				TE_SendToClient(client);
			}
			
			// 联机状态下，弹孔和枪声传递给所有关闭预测的真人玩家
			else
			{
				int RealPlayers[128] = 0;
				int num = 0;
				for(int i = 1; i <= MaxClients; i++)
				{
					if(IsClientInGame(i) && !IsFakeClient(i) && ClientPredict[i] == 0)
					{
						RealPlayers[num] = i;
						num++;
					}
				}
				if(num > 0)
				{
					numClients = numClients + num;
					TE_Send(RealPlayers, num);
				}
			}
			
			return Plugin_Changed;		
		}
    }
	return Plugin_Continue;
}


//检测玩家属性函数
bool:IsClient(Client, bool:Alive)
{
	return Client <= MaxClients && IsClientConnected(Client) && IsClientInGame(Client) && (Alive && IsPlayerAlive(Client));
}


public Action:RoundStart(Handle:event, const String:name[], bool:dontBroadcast) 
{
	RoundStartTime = GetTickedTime();    //获取每回合开始时间
	if(isEnabled == true)
	{
		// RealPlayerNum：真人玩家人数；OwnerId：房主id
		int RealPlayerNum = 0;
		int OwnerId = -1;
		
		for(int i = 0; i <= (sizeof(ClientPredict) - 1); i++) {
			ClientPredict[i] = 1;
		}
		
		for(int i = 1; i <= MaxClients; i++)
		{
			if(IsClientInGame(i) && IsPlayerAlive(i) && !IsFakeClient(i))
			{				
				// 检测回合开始时是否装备新枪
                new MainWeapon = GetPlayerWeaponSlot(i, 0);
				new SecWeapon = GetPlayerWeaponSlot(i, 1);
				new knife = GetPlayerWeaponSlot(i, 2);
				
				int myWeapon1 = -1, myWeapon2 = -1, myWeapon3 = -1;
				
				if (IsValidEdict(MainWeapon) && (MainWeapon > -1))
				{
					decl String:sWeapon1[32];
					GetEdictClassname(MainWeapon, sWeapon1, sizeof(sWeapon1));
					ReplaceStringEx(sWeapon1, strlen(sWeapon1), "_", ";");
					decl String:data1[2][30];
					ExplodeString(sWeapon1, ";", data1, 2, 30);
					
					for(int n = 0; n <= (sizeof(NewWeaponNames) - 1); n++) {
						if(StrEqual(NewWeaponNames[n], data1[1]))
						{
							myWeapon1 = n;
							break;
						}
				    }
				}
				
				if (IsValidEdict(SecWeapon) && (SecWeapon > -1))
				{
					decl String:sWeapon2[32];
					GetEdictClassname(SecWeapon, sWeapon2, sizeof(sWeapon2));
					ReplaceStringEx(sWeapon2, strlen(sWeapon2), "_", ";");
					decl String:data2[2][30];
					ExplodeString(sWeapon2, ";", data2, 2, 30);
					
					for(int n = 0; n <= (sizeof(NewWeaponNames) - 1); n++) {
						if(StrEqual(NewWeaponNames[n], data2[1]))
						{
							myWeapon2 = n;
							break;
						}
				    }
				}
				
				if (IsValidEdict(knife) && (knife > -1))
				{
					decl String:sWeapon3[32];
					GetEdictClassname(knife, sWeapon3, sizeof(sWeapon3));
					ReplaceStringEx(sWeapon3, strlen(sWeapon3), "_", ";");
					decl String:data3[2][30];
					ExplodeString(sWeapon3, ";", data3, 2, 30);
					
					for(int n = 0; n <= (sizeof(NewWeaponNames) - 1); n++) {
						if(StrEqual(NewWeaponNames[n], data3[1]))
						{
							myWeapon3 = n;
							break;
						}
				    }
				}
				
				// 记录房主的id
				if (CheckCommandAccess(i, "generic_admin", ADMFLAG_GENERIC, false))
				{
					OwnerId = i;
				}
				RealPlayerNum++;
				
				if(myWeapon1 > -1 || myWeapon2 > -1 || myWeapon3 > -1)    // 如果装备新枪
				{
					ClientCommand(i, "sv_client_predict 0");    //禁用客户端预测	
					ClientPredict[i] = 0;
					SetEntPropFloat(i, Prop_Data, "m_flLaggedMovementValue", newWalkSpeed);
				}
				else
				{
					ClientCommand(i, "sv_client_predict -1");    //启用用客户端预测
					SetEntPropFloat(i, Prop_Data, "m_flLaggedMovementValue", 1.0);
					
					// 回合开始时检测，当玩家不是房主，是普通真人玩家，需要把ClientPredict数组的对应值改为0
					if (CheckCommandAccess(i, "generic_admin", ADMFLAG_GENERIC, false))
					{
						// 玩家是房主
					}
					else
					{
						// 玩家不是房主
						ClientPredict[i] = 0;
					}
				}
			}
		}
		
		// 真人玩家人数大于1
		if(RealPlayerNum > 1)
		{
			CreateTimer(1.0, Timer_PrintMessageFiveTimes7, OwnerId);
		}
	}
}


// 联机时的每回合开始函数
public Action:Timer_PrintMessageFiveTimes7(Handle timer, int OwnerId)
{
	if(!IsValidEntity(OwnerId))
		return Plugin_Continue;
	ServerCommand("sv_client_predict 0");    //联机每回合开始时禁用服务器客户端预测
	if(ClientPredict[OwnerId] == 1)
	{
		ClientPredict[OwnerId] = 0;
		SetEntPropFloat(OwnerId, Prop_Data, "m_flLaggedMovementValue", newWalkSpeed);
		
		for(int i = 1; i <= MaxClients; i++)
		{
			if(IsClientInGame(i) && IsPlayerAlive(i) && !IsFakeClient(i))
			{
				if (CheckCommandAccess(i, "generic_admin", ADMFLAG_GENERIC, false))
				{
					// 玩家是房主
				}
				else
				{
					SetEntPropFloat(i, Prop_Data, "m_flLaggedMovementValue", newWalkSpeed);
					// 检测非房主真人玩家回合开始时是否装备新枪
					new MainWeapon = GetPlayerWeaponSlot(i, 0);
					new SecWeapon = GetPlayerWeaponSlot(i, 1);
					new knife = GetPlayerWeaponSlot(i, 2);
					
					int myWeapon1 = -1, myWeapon2 = -1, myWeapon3 = -1;
					
					if (IsValidEdict(MainWeapon) && (MainWeapon > -1))
					{
						decl String:sWeapon1[32];
						GetEdictClassname(MainWeapon, sWeapon1, sizeof(sWeapon1));
						ReplaceStringEx(sWeapon1, strlen(sWeapon1), "_", ";");
						decl String:data1[2][30];
						ExplodeString(sWeapon1, ";", data1, 2, 30);
						
						for(int n = 0; n <= (sizeof(NewWeaponNames) - 1); n++) {
							if(StrEqual(NewWeaponNames[n], data1[1]))
							{
								myWeapon1 = n;
								break;
							}
						}
					}
					
					if (IsValidEdict(SecWeapon) && (SecWeapon > -1))
					{
						decl String:sWeapon2[32];
						GetEdictClassname(SecWeapon, sWeapon2, sizeof(sWeapon2));
						ReplaceStringEx(sWeapon2, strlen(sWeapon2), "_", ";");
						decl String:data2[2][30];
						ExplodeString(sWeapon2, ";", data2, 2, 30);
						
						for(int n = 0; n <= (sizeof(NewWeaponNames) - 1); n++) {
							if(StrEqual(NewWeaponNames[n], data2[1]))
							{
								myWeapon2 = n;
								break;
							}
						}
					}
					
					// 如果装备新枪
					if((myWeapon1 > -1 || myWeapon2 > -1) && (IsValidEdict(knife) && (knife > -1)))    
					{
						if(HasEntProp(i, Prop_Send, "m_hActiveWeapon") == false)
							return Plugin_Continue;
						// 切换到刀
						SetEntPropEnt(i, Prop_Send, "m_hActiveWeapon", knife);
					}
				}				
			}
		}
	}
}

