/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 
#define TagRain -5
#define SOUND1  "physics/flesh/flesh_impact_bullet5.wav"
new Handle:l4d_neigong_range ;
new Handle:l4d_neigong_radius ;
new Handle:l4d_neigong_damage ;
new Handle:l4d_neigong_push ;
new Handle:l4d_neigong_energemax ;
new Handle:l4d_neigong_energeuse ;
new Handle:l4d_neigong_energerecover ;      
new Float: UseTime[MAXPLAYERS+1];
new Float: Energe[MAXPLAYERS+1];
new Float: FireTime[MAXPLAYERS+1];

new Float: ShoveTime[MAXPLAYERS+1];
new  String:rangestring[32];

new Float: energeuse;
new Float: energemax;
new Float: energerecover;
new 	g_iVelocity ;
new L4D2Version;
new GameMode;
new g_sprite;
 
public Plugin:myinfo = 
{
	name = "Neigong",
	author = "Pan Xiaohai",
	description = "Neigong",
	version = "1.0",
	url = "<- URL ->"
}

public OnPluginStart()
{
	l4d_neigong_range = CreateConVar("l4d_neigong_range", "200.0", " ", FCVAR_PLUGIN);
 	l4d_neigong_radius = CreateConVar("l4d_neigong_radius", "70.0", " ", FCVAR_PLUGIN);
	l4d_neigong_damage = CreateConVar("l4d_neigong_damage", "100", " ", FCVAR_PLUGIN);
	l4d_neigong_push = CreateConVar("l4d_neigong_push", "300", " ", FCVAR_PLUGIN);
	l4d_neigong_energemax = CreateConVar("l4d_neigong_energemax", "60.0", " ", FCVAR_PLUGIN);
	l4d_neigong_energeuse = CreateConVar("l4d_neigong_energeuse", "5.0", " ", FCVAR_PLUGIN);
	l4d_neigong_energerecover = CreateConVar("l4d_neigong_energerecover", "0.2", " ", FCVAR_PLUGIN);	
	
	
	g_iVelocity = FindSendPropOffs("CBasePlayer", "m_vecVelocity[0]");
	
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		L4D2Version=true;
	}	
	else
	{
		L4D2Version=false;
	}

	AutoExecConfig(true, "l4d_neigong");
 
	HookConVarChange(l4d_neigong_energemax, CvarChanged);
	HookConVarChange(l4d_neigong_energeuse, CvarChanged);
	HookConVarChange(l4d_neigong_energerecover, CvarChanged);	
	HookConVarChange(l4d_neigong_range, CvarChanged);
	HookEvent("weapon_fire", weapon_fire);

	HookEvent("round_start", RoundStart);
	ResetAllState();
	Set();
}
public OnGameFrame()
{
	if(L4D2Version)return;
	new Float:currenttime=GetEngineTime();
 
	for (new client = 1; client <= MaxClients; client++)
	{
		if(IsClientInGame(client) && GetClientTeam(client)==2 && IsPlayerAlive(client) && !IsFakeClient(client))
		{
			Do(client, currenttime);
		}
	}
    
}
Do(client, Float:currenttime )
{
	new button=GetClientButtons(client);
	if((button & IN_ATTACK2) && (button & IN_USE))
	{
		new Float:f=GetEntPropFloat(client, Prop_Send, "m_flNextShoveTime");
		if(f!=ShoveTime[client])
		{
			//PrintToChat(client, "%f %f", f, currenttime );
			NeiGong(client, currenttime)
		}
		ShoveTime[client]=f;
	}
	
	 
}
 public Action:weapon_fire(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(!L4D2Version)return;
 	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	//PrintToChatAll("%N fire", userid);
	 
	if(GetClientTeam(client)==2)
	{
		if(GetClientButtons(client) & IN_USE )
		{
			
			decl String:item[65];
			GetEventString(event, "weapon", item, 65);
			if( StrContains(item, "melee")>=0 )
			{
				new Float:time=GetEngineTime();
				NeiGong(client, time);
			}
			
		}
		
		
	}
}
NeiGong(client, Float:time)
{
	Energe[client]+=(time-FireTime[client])*energerecover;
	FireTime[client]=time;
	if( time-UseTime[client]>0.1)
	{
		if(Energe[client]-energeuse>0.0)
		{
 	 
			if(Energe[client]>energemax)Energe[client]=energemax;
			Energe[client]=Energe[client]-energeuse;
			UseTime[client]=time;
			//PrintToChatAll(" OK %f %f", Energe[client], energeuse);
			
			decl Float:Origin[3], Angles[3], AnglesVec[3], vec[3], pos[3];
			GetClientEyePosition(client, Origin);
			GetClientEyeAngles(client, Angles);
			GetAngleVectors(Angles, AnglesVec, NULL_VECTOR, NULL_VECTOR);
			NormalizeVector(AnglesVec, AnglesVec);
			CopyVector(AnglesVec, vec);
			ScaleVector(vec, 15.0);
			AddVectors(Origin, vec, Origin);
	 
		
			new Float:dis=GetConVarFloat(l4d_neigong_range)+15.0;
			new Float:radius=GetConVarFloat(l4d_neigong_radius);
			new Float:pushforce=GetConVarFloat(l4d_neigong_push);
			new Float:damage=GetConVarFloat(l4d_neigong_damage);
			new Float:k=radius;
			new Float:dr=radius;
			

			
			
			if(false)
			{	new push = CreateEntityByName("env_blood");    //  env_physimpact   
				DispatchKeyValueFloat(push, "Hint Text", pushforce);                     
				//DispatchKeyValueFloat (push, "radius", radius);         
				//DispatchKeyValueFloat (push, "distance", radius);        
				new Float:c[3]; c[0]=244; c[1]=0; c[2]=0; 
				 DispatchKeyValueVector(push, "spraydir", c);
				DispatchSpawn(push);   
				TeleportEntity(push, pos, Angles, NULL_VECTOR);  
				//AcceptEntityInput(push, "Enable", -1, -1);
				AcceptEntityInput(push, "EmitBlood", -1, -1);
				 
				//AcceptEntityInput(push, "Kill"); 
				//CreateTimer(0.2, DeletePushForce, push);
			}
			do
			{
				CopyVector(AnglesVec, vec);
				ScaleVector(vec, k);
				AddVectors(Origin, vec, pos);
				
				k+=radius;
				new pointHurt = CreateEntityByName("point_hurt"); 
				DispatchKeyValueFloat(pointHurt, "DamageRadius", dr); 
				DispatchKeyValueFloat(pointHurt, "Damage", damage); 
				if(L4D2Version)
				{
					 
					DispatchKeyValue(pointHurt, "DamageType", "64"); 
				}
				else 
				{
				 
					DispatchKeyValue(pointHurt, "DamageType", "64"); 
				}
				DispatchKeyValue(pointHurt, "DamageDelay", "0.0"); 
				DispatchSpawn(pointHurt);
				TeleportEntity(pointHurt, pos, NULL_VECTOR, NULL_VECTOR); 
				AcceptEntityInput(pointHurt, "Hurt", client); 
				AcceptEntityInput(pointHurt, "Kill"); 
				
				
				new push = CreateEntityByName("point_push");    //  env_physimpact   
				DispatchKeyValueFloat (push, "magnitude", pushforce);                     
				DispatchKeyValueFloat (push, "radius", radius);         
				//SetVariantString("spawnflags 24");
				DispatchSpawn(push);   
				TeleportEntity(push, pos, NULL_VECTOR, NULL_VECTOR);  
				AcceptEntityInput(push, "Enable", -1, -1);
				CreateTimer(0.2, DeletePushForce, push);
				 
				
				dr+=dr*0.05;
				damage-=damage*0.23;
				pushforce-=pushforce*0.25;
				//PrintToChatAll("long %f damage %f, radius %f, force %f   ", k, damage, dr,  pushforce);
			}while(k<=dis );
			PrintHintText(client, "energe %d", RoundFloat(Energe[client]));
			if(L4D2Version)
			{
				//ShowParticle(Origin, Angles, "fireworks_03", 0.1);
				Show(client );
			}
			else 
				Show(client );
				
			EmitSoundToAll(SOUND1, client); 
			 
		}
		else
		{
			PrintHintText(client, "not enough energe");
		}
	}	
			 
new String:Message[10] = "hello";
new Handle:hBuffer = StartMessageOne("KeyHintText", client);
BfWriteByte(hBuffer, 1);
BfWriteString(hBuffer, Message);
EndMessage();  
}
Show(client )
{
	
	decl Float:Origin[3], Angles[3];
	GetClientEyePosition(client, Origin);	
	GetClientEyeAngles(client, Angles);
	decl String:tName[32];
	Format(tName, sizeof(tName), "target%d", client);
	DispatchKeyValue(client, "targetname", tName);
	
	

	decl String:flame_name[32];
	Format(flame_name, sizeof(flame_name), "Flame%i", client);
	new flame = CreateEntityByName("env_steam");
	DispatchKeyValue(flame,"targetname", flame_name);
	DispatchKeyValue(flame, "parentname", tName);
	DispatchKeyValue(flame,"SpawnFlags", "1");
	DispatchKeyValue(flame,"Type", "0");
	
	DispatchKeyValue(flame,"InitialState", "1");
	DispatchKeyValue(flame,"Spreadspeed", "10");
	DispatchKeyValue(flame,"Speed", "1000");
	DispatchKeyValue(flame,"Startsize", "20");
	DispatchKeyValue(flame,"EndSize", "140");
	DispatchKeyValue(flame,"Rate", "15");
	DispatchKeyValue(flame,"RenderColor", "16 85 160");
	
 
	DispatchKeyValue(flame,"JetLength", rangestring);

 
	DispatchKeyValue(flame,"RenderAmt", "180");
	DispatchSpawn(flame);
	TeleportEntity(flame, Origin, Angles, NULL_VECTOR);
	SetVariantString(tName);
	AcceptEntityInput(flame, "SetParent", flame, flame, 0);
	SetVariantString("forward");
	AcceptEntityInput(flame, "SetParentAttachment", flame, flame, 0);
	AcceptEntityInput(flame, "TurnOn");

	 
	CreateTimer(0.2, StartKillFrame, flame);
 
}
public Action:StartKillFrame(Handle:timer, any:ent)
{
	KillFlame(ent );
}
KillFlame(ent1 )
{
 
	decl String:classname[128];
	if (ent1> 0 && IsValidEntity(ent1))
	{
		AcceptEntityInput(ent1, "TurnOff");
		GetEdictClassname(ent1, classname, sizeof(classname));
		if (StrEqual(classname, "env_steam", false))
		{
			RemoveEdict(ent1);
		}
		
	}
  
}
  
public Action:RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	ResetAllState();
	return Plugin_Continue;
}
ResetAllState()
{
	new Float:t=GetEngineTime();
	for (new x = 0; x < MAXPLAYERS+1; x++)
	{
		UseTime[x]=t;
		Energe[x]=0.0;
		FireTime[x]=t;
		ShoveTime[x]=0;
		
	}
}
public OnConfigExecuted()
{
	ResetAllState();
	Set();
}
Set()
{
	energeuse=GetConVarFloat(l4d_neigong_energeuse);
	energemax=GetConVarFloat(l4d_neigong_energemax);
	energerecover=GetConVarFloat(l4d_neigong_energerecover);
	GetConVarString(l4d_neigong_range, rangestring, 32);
}
public CvarChanged(Handle:convar, const String:oldValue[], const String:newValue[])
{
	Set();
}
public OnMapStart()
{
	PrecacheModel("models/props_junk/propanecanister001a.mdl", true);
	PrecacheModel("models/props_junk/gascan001a.mdl", true);
	 
	PrecacheParticle("gas_explosion_pump");
	PrecacheParticle("gas_explosion_main");
	
	if(L4D2Version)
	{
		g_sprite = PrecacheModel("materials/sprites/laserbeam.vmt");	
		PrecacheSound(SOUND1);
		PrecacheParticle("fireworks_03");
		
	}
	else
	{
		g_sprite = PrecacheModel("materials/sprites/laser.vmt");	
 
	}

}
 
 
public Action:StartRockTrace(Handle:timer, any:ent)
{
 
}
public Action:StartTrace(Handle:timer, any:ent)
{
 
}
Float:CalRay(Float:posmissile[3], Float:angle[3], Float:offset1, Float:offset2,  Float:force[3], ent, bool:printlaser=true) 
{
	
	new Float:dis=GetRayDistance(posmissile, angle, ent) ;
	decl Float:ang[3];
	CopyVector(angle, ang);
	ang[0]+=offset1;
	ang[1]+=offset2;
	GetAngleVectors(ang, force, NULL_VECTOR,NULL_VECTOR);
	if(printlaser)ShowLarserByAngleAndDistance(posmissile, ang, dis);
	return dis;
}

CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
		target[1]=source[1];
			target[2]=source[2];
}
 
 
public DeleteEntity(any:ent, String:name[])
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, name, false))
		 {
			AcceptEntityInput(ent, "Kill"); 
			RemoveEdict(ent);
		 }
	 }
}
 
public Action:DeletePushForce(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_push", false))
				{
 					AcceptEntityInput(ent, "Disable");
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
	 }
}
public Action:DeletePointHurt(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_hurt", false))
				{
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
		 }

}
public ShowParticle(Float:pos[3], Float:angle[3], String:particlename[], Float:time)
{
 new particle = CreateEntityByName("info_particle_system");
 if (IsValidEdict(particle))
 {
 	decl Float:v[3];
	CopyVector(angle, v);
	GetAngleVectors(angle, v, NULL_VECTOR, NULL_VECTOR);
	angle[2]+=0.0;
	angle[1]+=0.0;
	angle[0]+=90.0;
 	DispatchKeyValue(particle, "effect_name", particlename);
	DispatchKeyValue(particle, "targetname", "particle");
	DispatchSpawn(particle);
	ActivateEntity(particle);
	TeleportEntity(particle, pos, angle, NULL_VECTOR);
	AcceptEntityInput(particle, "start");
	CreateTimer(time, DeleteParticles, particle);
 } 
}
 
public PrecacheParticle(String:particlename[])
{
 new particle = CreateEntityByName("info_particle_system");
 if (IsValidEdict(particle))
 {
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(0.01, DeleteParticles, particle);
 } 
}

public Action:DeleteParticles(Handle:timer, any:particle)
{
	 if (IsValidEntity(particle))
	 {
		 decl String:classname[64];
		 GetEdictClassname(particle, classname, sizeof(classname));
		 if (StrEqual(classname, "info_particle_system", false))
			{
				AcceptEntityInput(particle, "stop");
				AcceptEntityInput(particle, "kill");
				RemoveEdict(particle);
			}
	 }
}
public bool:TraceRayDontHitSelfAndSurvivor(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==2)
		{
			return false;
		}
	}
	return true;
}
public bool:TraceRayDontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	return true;
}
public bool:TraceRayDontHitSelfAndLive(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity))
		{
			return false;
		}
	}
	return true;
}