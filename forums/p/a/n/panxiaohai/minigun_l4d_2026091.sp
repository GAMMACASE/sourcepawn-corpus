/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 

#define Model_Witch "models/infected/witch.mdl"
#define Model_Witch2 "models/infected/witch_bride.mdl"

#define Pai 3.14159265358979323846 

#define ZOMBIECLASS_SMOKER	1
#define ZOMBIECLASS_BOOMER	2
#define ZOMBIECLASS_HUNTER	3
#define ZOMBIECLASS_SPITTER	4
#define ZOMBIECLASS_JOCKEY	5
#define ZOMBIECLASS_CHARGER	6 
new ZOMBIECLASS_TANK=	5;

#define state_no 0
#define state_using 1
#define state_carray 2

#define MODEL_GUN "models/w_models/weapons/w_minigun.mdl"
#define MODEL_GUN2 "models/w_models/weapons/50cal.mdl"

new Float:tank_hurt_time[MAXPLAYERS+1];

new g_minigun_count=2;
new mini_gun_state[MAXPLAYERS+1];
new mini_gun_ent[MAXPLAYERS+1];
new Float:PunishDelay[MAXPLAYERS+1];
new Float:mini_gun_angle[MAXPLAYERS+1];
new Float:oprate_time[MAXPLAYERS+1];
new LastButton[MAXPLAYERS+1];
new Handle:l4d_minigun_count; 

new Handle:sdkVomitSurvivor = INVALID_HANDLE;
new Handle:g_hGameConf = INVALID_HANDLE;

new GameMode;
new L4D2Version;
new g_PointHurt = 0;
public Plugin:myinfo = 
{
	name = "move minigun",
	author = "Pan XiaoHai",
	description = "<- Description ->",
	version = "1.1",
	url = "<- URL ->"
}

public OnPluginStart()
{
	GameCheck(); 	

	l4d_minigun_count = CreateConVar("l4d_minigun_count", "2", "minigun limit" );
 
	
	AutoExecConfig(true, "l4d_minigun");  
  
	HookEvent("player_bot_replace", player_bot_replace );	
	HookEvent("player_spawn", player_spawn);	
	HookEvent("player_death", player_death); 
	
	HookEvent("round_start", round_end);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition", round_end);	 
	
	HookEvent("player_use", player_use);  
 	HookEvent("entity_shoved", entity_shoved); 
	HookEvent("player_hurt", player_hurt);
 
	RegConsoleCmd("sm_minigun", sm_minigun); 

	ResetAllState();
	
	g_hGameConf = LoadGameConfigFile("l4d_minigun");
	if(g_hGameConf == INVALID_HANDLE)
	{
		SetFailState("Couldn't find the offsets and signatures file. Please, check that it is installed correctly.");
	}
	
	StartPrepSDKCall(SDKCall_Player);
	PrepSDKCall_SetFromConf(g_hGameConf, SDKConf_Signature, "CTerrorPlayer_OnVomitedUpon");
	PrepSDKCall_AddParameter(SDKType_CBasePlayer, SDKPass_Pointer);
	PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Plain);
	sdkVomitSurvivor = EndPrepSDKCall();
	if(sdkVomitSurvivor == INVALID_HANDLE)
	{
		SetFailState("Unable to find the \"CTerrorPlayer_OnVomitedUpon\" signature, check the file version!");
	}
	
}

GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	//PrintToChatAll("mp_gamemode = %s", GameName);
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	
 
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		ZOMBIECLASS_TANK=8;
		L4D2Version=true;
	}	
	else
	{
		ZOMBIECLASS_TANK=5;
		L4D2Version=false;
	}
	L4D2Version=!!L4D2Version;
}

public OnMapStart()
{  
	PrecacheModel(MODEL_GUN);
	if(L4D2Version)
	{
		PrecacheModel(MODEL_GUN2);
	}

	ResetAllState();
	
	
}

public Action:player_hurt(Handle:event, const String:name[], bool:dontBroadcast)
{
	new  attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new  victim = GetClientOfUserId(GetEventInt(event, "userid"));
	
	
	if(attacker>0 && victim>0 && mini_gun_state[attacker]==state_using)
	{
		if(GetEngineTime()- PunishDelay[attacker]<1.0) return;
		PunishDelay[attacker]=GetEngineTime();
		new class = GetEntProp(victim, Prop_Send, "m_zombieClass"); 
		if(class==ZOMBIECLASS_TANK)
		{
			tank_hurt_time[attacker]=GetEngineTime();
			PrintToChat(attacker, "can not use mini gun when tank is alive");
			SDKCall(sdkVomitSurvivor, attacker, attacker, true);
			//Z_Spawn(attacker);
		}
	}
}

public Action:player_spawn(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(hEvent, "userid"));  
	ResetClientState(client);
	 	
}

public Action:player_death(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
	new victim = GetClientOfUserId(GetEventInt(hEvent, "userid")); 
	if(victim>0 && victim<=MaxClients)
	{
		StopCarray(victim);
	}
	return Plugin_Continue;	 
}
public player_bot_replace(Handle:Spawn_Event, const String:Spawn_Name[], bool:Spawn_Broadcast)
{
 	new client = GetClientOfUserId(GetEventInt(Spawn_Event, "player"));
	new bot = GetClientOfUserId(GetEventInt(Spawn_Event, "bot"));   
	if(client>0)
	{
		StopCarray(client);
	}

}
public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	ResetAllState();
}
ResetAllState()
{
	g_PointHurt=0;
	g_minigun_count=0;
	for(new i=1; i<=MaxClients; i++)
	{
		ResetClientState(i);
	}
}
ResetClientState(client)
{
	mini_gun_state[client]=state_no;
	mini_gun_ent[client]=0;
	LastButton[client]=0;
	oprate_time[client]=0;
	tank_hurt_time[client]=0.0;
	PunishDelay[client]=0.0;
}


public Action:sm_minigun(client,args)
{
	
	if(client>0 && IsClientInGame(client) && IsPlayerAlive(client))
	{
		new String:str[32];
		new type=GetCmdArg(1, str, 32);
		if(strlen(str)==0)type=GetRandomInt(0,1);
		else
		{
			if(StrEqual(str, "0"))type=0;
			else type=1;
		}
		CreateMachine(client, type);
	}
}

GetMinigun(client )
{ 
	new ent= GetClientAimTarget(client, false);
	if(ent>0 && IsValidEdict(ent) && IsValidEntity(ent))
	{			
		decl String:classname[64];
		GetEdictClassname(ent, classname, 64);			
		if(StrEqual(classname, "prop_minigun") || StrEqual(classname, "prop_minigun_l4d1"))
		{
		}
		else ent=0;
	}  
	return ent;
}
public Action:entity_shoved(Handle:event, String:event_name[], bool:dontBroadcast)
{
	new attacker  = GetClientOfUserId(GetEventInt(event, "attacker"));
	if(attacker>0 && IsClientInGame(attacker) && GetClientTeam(attacker)==2)
	{		
		new b=GetClientButtons(attacker);
		if(b & IN_USE )
		{
			new gun=GetMinigun(attacker);
			if(gun>0)
			{
				StartCarry(attacker, gun);
			} 
		}
	}
	return Plugin_Continue;
}
public Action:player_use(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	return Plugin_Continue;
	new client = GetClientOfUserId(GetEventInt(hEvent, "userid"));
	new ent=GetEventInt(hEvent, "targetid"); 

}
bool:IsMiniGun(ent)
{
	if(ent>0)
	{
		decl String:classname[64];
		GetEdictClassname(ent, classname, 64);			
		if(StrEqual(classname, "prop_minigun") || StrEqual(classname, "prop_minigun_l4d1"))
		{
			return true;
		}
	}
	return false;
}
public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	
	if(IsFakeClient(client))return Plugin_Continue; 
	new last_button=LastButton[client];
	LastButton[client]=buttons; 
	if(mini_gun_state[client]==state_carray && (buttons & IN_USE) && (buttons & IN_ATTACK2) && !(last_button & IN_ATTACK2))
	{
		StopCarray(client);
	} 

	new using_ent=0;
	//if(buttons & IN_USE) 
	{
		using_ent= GetEntPropEnt(client, Prop_Send, "m_hUseEntity");
		//PrintToChatAll("using_ent %d",using_ent);
		new bool:used=IsMiniGun(using_ent);
		if(!used) using_ent=0; 
	} 
	if(using_ent>0 && mini_gun_state[client]==state_no)
	{
		StartUse(client, using_ent);
	}
	if(using_ent==0 && mini_gun_state[client]==state_using)
	{ 
		
		StopUse(client);
	}
	
	if(mini_gun_state[client]!=state_using)return Plugin_Continue; 
	 
	
	decl Float:client_eye_angle[3];
	GetClientEyeAngles(client, client_eye_angle);
	
	decl Float:gun_angle[3]; 
 	GetEntPropVector(mini_gun_ent[client], Prop_Send, "m_angRotation", gun_angle);
	client_eye_angle[0]=0.0;
	gun_angle[0]=0.0;
	new Float:angle = GetAngle(client_eye_angle, gun_angle)*180.0/Pai;
	

	if(angle>89.0)TeleportEntity(mini_gun_ent[client], NULL_VECTOR, client_eye_angle,NULL_VECTOR);
	return Plugin_Continue;
}
Float:GetAngle(Float:x1[3], Float:x2[3])
{
	decl Float:a[3];
	decl Float:b[3];
	 
	GetAngleVectors(x1, a, NULL_VECTOR, NULL_VECTOR);
	GetAngleVectors(x2, b, NULL_VECTOR, NULL_VECTOR);
	
	return ArcCosine(GetVectorDotProduct(a, b)/(GetVectorLength(a)*GetVectorLength(b)));
}

CreateMachine(client,type)
{
	if(g_minigun_count>=GetConVarInt(l4d_minigun_count))
	{
		PrintToChat(client, "can not create more ");
		return 0;
	}
	if(!(GetEntityFlags(client) & FL_ONGROUND))return 0;
	
	new mini_gun=SpawnMiniGun(client, type); 
	g_minigun_count++;
	
	PrintToChatAll("%N create a mini gun,press E+mouse right button to carray it",client);
	return 1;
}

StopCarray(client)
{
	if(mini_gun_state[client]!=state_carray)return;  
	if(GetEngineTime()-oprate_time[client]<0.5)return;
	oprate_time[client]=GetEngineTime();
	
	decl String:classname[64];
	GetEdictClassname(mini_gun_ent[client], classname, 64);		
	AcceptEntityInput(mini_gun_ent[client], "ClearParent"); 
	RemoveEdict(mini_gun_ent[client]);	
	
	new type= StrEqual(classname,"prop_minigun_l4d1") ? 0:1;
	SpawnMiniGun(client, type);
	
	mini_gun_state[client]=state_no;
	mini_gun_ent[client]=0;

}
StartCarry(client, ent)
{
	
	new owner = GetEntPropEnt(ent, Prop_Send, "m_owner");
	if(owner>0)return;
	
	if(mini_gun_state[client]!=state_no)return;
	if(GetEngineTime()-oprate_time[client]<0.5)return;
	oprate_time[client]=GetEngineTime();
	
	SetEntPropEnt(ent, Prop_Data, "m_hOwnerEntity", client)	;
	SetEntProp(ent, Prop_Send, "m_CollisionGroup", 2); 
	SetEntProp(ent, Prop_Send, "m_firing", 0); 
	new Float:ang[3];
	SetVector(ang, 0.0, 0.0, 90.0);
	new Float:pos[3];
	SetVector(pos, -8.0, 10.0,  0.0);
	if(GetClientTeam(client)==2)	AttachEnt(client, ent, "medkit", pos, ang);
	else AttachEnt(client, ent, "medkit", pos, ang);
	
	mini_gun_state[client]=state_carray;
	mini_gun_ent[client]=ent;
	
	PrintHintText(client, "You crray a mini gun, press mouse middle button+mouse right button to put it down");
}

StopUse(client)
{
	if(mini_gun_state[client]!=state_using)return;
	
	decl Float:gun_angle[3]; 
 	GetEntPropVector(mini_gun_ent[client], Prop_Send, "m_angRotation", gun_angle);
	decl Float:gun_pos[3]; 
 	GetEntPropVector(mini_gun_ent[client], Prop_Send, "m_vecOrigin", gun_pos);
	
	
	
	decl String:classname[64];
	GetEdictClassname(mini_gun_ent[client], classname, 64);		
	decl Float:VecOrigin[3], Float:VecAngles[3], Float:VecDirection[3]; 

	decl String:playerModel[64];
	GetEntPropString(mini_gun_ent[client], Prop_Data, "m_ModelName", playerModel, sizeof(playerModel)); 

	RemoveEdict(mini_gun_ent[client]); 
	
	new gun=0;
	gun=CreateEntityByName ( classname);  
	SetEntityModel (gun, playerModel);

	DispatchKeyValueFloat(gun, "MaxPitch", 360.00);
	DispatchKeyValueFloat(gun, "MinPitch", -360.00);
	DispatchKeyValueFloat(gun, "MaxYaw", 190.00);
	 
	TeleportEntity(gun, gun_pos, gun_angle, NULL_VECTOR); 
	SetEntProp(gun, Prop_Send, "m_CollisionGroup", 2); 
	SetEntPropEnt(gun, Prop_Data, "m_hOwnerEntity", -1)	;
	DispatchSpawn(gun);
	
	//SetEntProp(gun, Prop_Send, "m_iGlowType", 3 ); //3
	//SetEntProp(gun, Prop_Send, "m_nGlowRange", 0 ); //0
	//SetEntProp(gun, Prop_Send, "m_glowColorOverride",110+256*63+256*256*0); //1	


	mini_gun_ent[client]=0;
	mini_gun_state[client]=	state_no;
 

}
StartUse(client, ent)
{
	if(mini_gun_state[client]!=state_no)return; 
	
	mini_gun_state[client]=	state_using;
	mini_gun_ent[client]=ent; 

	DispatchKeyValueFloat(ent, "MaxPitch", 360.00);
	DispatchKeyValueFloat(ent, "MinPitch", -360.00);
	DispatchKeyValueFloat(ent, "MaxYaw", 190.00); 
	SetEntPropEnt(ent, Prop_Data, "m_hOwnerEntity", client)	;
 
}
 
Z_Spawn(client)
{
	
	new bot = CreateFakeClient("Monster");
	if (bot > 0)	
	{		
		ChangeClientTeam(bot,3);
		 
		new random = GetRandomInt(1,6);
		if(!L4D2Version)random=GetRandomInt(1,3);
		switch(random)
		{
			case 1:
			SpawnCommand(client, "z_spawn", "smoker");
			case 2:
			SpawnCommand(client, "z_spawn", "boomer");
			case 3:
			SpawnCommand(client, "z_spawn", "hunter");
			case 4:
			SpawnCommand(client, "z_spawn", "spitter");
			case 5:
			SpawnCommand(client, "z_spawn", "jockey");
			case 6:
			SpawnCommand(client, "z_spawn", "charger");
		}
			
		 
		Kickbot(INVALID_HANDLE, bot);
		//CreateTimer(0.1,Kickbot,bot);
	}	  
}

SpawnCommand(client, String:command[], String:arguments[] = "")
{
	if (client)
	{ 
		new flags = GetCommandFlags(command);
		SetCommandFlags(command, flags & ~FCVAR_CHEAT);
		FakeClientCommand(client, "%s %s", command, arguments);
		SetCommandFlags(command, flags);
	}
} 
public Action:Kickbot(Handle:timer, any:client)
{
	if (IsClientInGame(client))
	{
		if (IsFakeClient(client))
		{
			KickClient(client);
		}
	}
}

AttachEnt(owner, ent, String:positon[]="medkit", Float:pos[3]=NULL_VECTOR,Float:ang[3]=NULL_VECTOR)
{
	decl String:tname[60];
	Format(tname, sizeof(tname), "target%d", owner);
	DispatchKeyValue(owner, "targetname", tname); 		
	DispatchKeyValue(ent, "parentname", tname);
	
	SetVariantString(tname);
	AcceptEntityInput(ent, "SetParent",ent, ent, 0); 	
	if(strlen(positon)!=0)
	{
		SetVariantString(positon); 
		AcceptEntityInput(ent, "SetParentAttachment");
	}
	TeleportEntity(ent, pos, ang, NULL_VECTOR);
}
/* code from  "Movable Machine Gun", author = "hihi1210" 
*/
SpawnMiniGun(client ,type)
{
	decl Float:VecOrigin[3], Float:VecAngles[3], Float:VecDirection[3]; 
	new gun=0;
	
	if(L4D2Version)
	{ 
		if(type==0)
		{
			gun=CreateEntityByName ( "prop_minigun_l4d1"); 
			SetEntityModel (gun, MODEL_GUN);
			
		}
		else if(type==1)
		{
			gun=CreateEntityByName ( "prop_minigun"); 
			SetEntityModel (gun, MODEL_GUN2);		
			
		} 
	}
	else
	{
		gun=CreateEntityByName ( "prop_minigun");  
		SetEntityModel (gun, MODEL_GUN);
		
	}
 	//SetColor(gun, 2);
	DispatchKeyValueFloat(gun, "MaxPitch", 360.00);
	DispatchKeyValueFloat(gun, "MinPitch", -360.00);
	DispatchKeyValueFloat(gun, "MaxYaw", 190.00);
	 
	GetClientAbsOrigin(client, VecOrigin);
	GetClientEyeAngles(client, VecAngles);
	GetAngleVectors(VecAngles, VecDirection, NULL_VECTOR, NULL_VECTOR);
	VecOrigin[0] += VecDirection[0] * 45;
	VecOrigin[1] += VecDirection[1] * 45;
	VecOrigin[2] += VecDirection[2] * 1;   
	VecAngles[0] = 0.0;
	VecAngles[2] = 0.0; 
	SetEntProp(gun, Prop_Send, "m_CollisionGroup", 2); 	
	TeleportEntity(gun, VecOrigin, VecAngles, NULL_VECTOR); 
	DispatchSpawn(gun);
	
	SetEntPropEnt(gun, Prop_Data, "m_hOwnerEntity", -1)	;
	
	//SetEntProp(gun, Prop_Send, "m_iGlowType", 3 ); //3
	//SetEntProp(gun, Prop_Send, "m_nGlowRange", 0 ); //0
	//SetEntProp(gun, Prop_Send, "m_glowColorOverride",110+256*63+256*256*0); //1		
	return gun;
}


public bool:TraceRayDontHitSelfAndHuman(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	} 
	if(entity<=MaxClients && entity>0)
	{
		if(IsClientInGame(entity) && IsPlayerAlive(entity) && GetClientTeam(entity)==2)
		{
			return false; 
		}
	}
	return true;
} 
public Action:Hook_SetTransmit(entity, client)
{ 
	if(entity==mini_gun_ent[client])
	{
		//if(WitchViewOn[client])return Plugin_Continue;
		return Plugin_Handled;
	}
	return Plugin_Continue;
}
SetVector(Float:target[3], Float:x, Float:y, Float:z)
{
	target[0]=x;
	target[1]=y;
	target[2]=z;
}


CreatePointHurt()
{
	new pointHurt=CreateEntityByName("point_hurt");
	if(pointHurt)
	{

		DispatchKeyValue(pointHurt,"Damage","10");
		DispatchKeyValue(pointHurt,"DamageType","2");
		DispatchSpawn(pointHurt);
	}
	return pointHurt;
}
new String:N[20];
DoPointHurtForInfected(victim, attacker=0,  Float:damage=0.0)
{
	if(g_PointHurt > 0)
	{
		if(IsValidEdict(g_PointHurt))
		{
			if(victim>0 && IsValidEdict(victim))
			{		
				Format(N, 20, "target%d", victim);
				DispatchKeyValue(victim,"targetname", N);
				DispatchKeyValue(g_PointHurt,"DamageTarget", N);
				//DispatchKeyValue(g_PointHurt,"classname","");
				DispatchKeyValueFloat(g_PointHurt,"Damage", damage*1.0);
				DispatchKeyValue(g_PointHurt,"DamageType","-2130706430");
				AcceptEntityInput(g_PointHurt,"Hurt",(attacker>0)?attacker:-1);
			}
		}
		else g_PointHurt=CreatePointHurt();
	}
	else g_PointHurt=CreatePointHurt();
}

bool:IsInfectedTeam(ent)
{
	if(ent>0)
	{		 
		if(ent<=MaxClients)
		{
			if(IsClientInGame(ent) && IsPlayerAlive(ent) && GetClientTeam(ent)==3)
			{
				return true;
			}
		}
		else if(IsValidEntity(ent) && IsValidEdict(ent))
		{
			
			decl String:classname[32];
			GetEdictClassname(ent, classname,32);
			
			if(StrEqual(classname, "infected", true) || StrEqual(classname, "witch", true) )
			{
				return true;
			}
		}
	} 
	return false;
}