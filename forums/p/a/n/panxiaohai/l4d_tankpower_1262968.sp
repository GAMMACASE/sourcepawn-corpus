/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdkhooks>
#include <sdktools>
#include <sdktools_functions>
 
#define Tag2 "T2"
#define Tag3 "T3"

#define TagRain -5 
 
new Handle:tankpower_rock_enable ;
 
new Handle:tankpower_rock_trace_chance; 
 
new GameMode;
new g_sprite;
new g_iVelocity;
new bool:L4D2Version;
public Plugin:myinfo = 
{
	name = "tank's power",
	author = "Pan Xiaohai",
	description = "tank's power",
	version = "1.1",
	url = "<- URL ->"
}
new bool:gamestart=false;
public OnPluginStart()
{
  	tankpower_rock_enable = CreateConVar("l4d_tankpower_enable", "1", "  0:disable, 1:enable in coop mode, 2: enable in all mode ", FCVAR_PLUGIN);
 	 
	tankpower_rock_trace_chance = 	CreateConVar("l4d_tankpower_rock_trace_chance", "70", "the chance of trace of rock [0-100](int)");	
  	
	g_iVelocity = FindSendPropOffs("CBasePlayer", "m_vecVelocity[0]");
	
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		L4D2Version=true;
	}	
	else
	{
		L4D2Version=false;
	}

	AutoExecConfig(true, "l4d_tankpower"); 
 
	HookEvent("round_start", RoundStart);
	HookEvent("round_end", RoundStart);
	HookEvent("finale_win", RoundStart);
	HookEvent("mission_lost", RoundStart);
	HookEvent("map_transition", RoundStart);	
 
	HookEvent("ability_use", Ability_Use);
	Reset();
	gamestart=false;
}

Reset()
{
	
}
public Action:RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	Reset();
	gamestart=false;
}
public Action:Ability_Use(Handle:event, const String:name[], bool:dontBroadcast)
{
	decl String:s[32];
	GetEventString(event, "ability", s, 32);
 
	if(StrEqual(s, "ability_throw", true))
	{	
		new mode=GetConVarInt(tankpower_rock_enable);
		if(mode==0)return;
		if(mode==1 && GameMode==2)return;
		gamestart=true;
	}
	
} 

 
public OnMapStart()
{ 
}
 
public OnEntityCreated(entity, const String:classname[])
{
	if(!gamestart)return;
	new mode=GetConVarInt(tankpower_rock_enable);
	if(mode==0)return;
	if(mode==1 && GameMode==2)return;
	if(StrEqual(classname, "tank_rock", true))
	{
		
		if(GetRandomInt(0, 100)<GetConVarInt(tankpower_rock_trace_chance)   )
		{
			StartRockTrace(entity);
		}
		gamestart=false;
	}
 
}
 StartRockTrace(ent)
{
	 
	new team=GetEntProp(ent, Prop_Send, "m_iTeamNum");  
	if(team>=0)
	{
		SDKHook( ent, SDKHook_Think,  PreThink); 
	} 
}
public PreThink(ent)
{
	if(ent>0 && IsValidEntity(ent) && IsValidEdict(ent))
	{
		new Float:time=GetEngineTime( ); 
		TracingRock(ent, time );  
	}
	else
	{
		SDKUnhook(ent, SDKHook_Think,  PreThink);
	}

}
TracingRock(ent,Float:time)
{
   		
	decl Float:rockPos[3];			
	decl Float:rockVelocity[3];	
	
	GetEntPropVector(ent, Prop_Send, "m_vecOrigin", rockPos);	
	GetEntDataVector(ent, g_iVelocity, rockVelocity);
	
	new Float:vel=GetVectorLength(rockVelocity);
	if(vel<100.0)return;
	
	NormalizeVector(rockVelocity, rockVelocity);
 	new enemy=GetEnemy(rockPos, rockVelocity, 2);
 
	if(enemy>0)	
	{
		decl Float:posEnemy[3];
		decl Float:velocityEnemy[3];
		GetClientEyePosition(enemy, posEnemy);
		GetEntDataVector(enemy, g_iVelocity, velocityEnemy);
		new bool:visible=IfTwoPosVisible(rockPos, posEnemy, ent);
		
		if(!visible)return;
		
		new Float:disenemy=GetVectorDistance(rockPos, posEnemy);
		
		if(disenemy>500.0)return;
		SetEntityGravity(ent, 0.01);
		//PrintToChatAll("%N %f", enemy, disenemy);	
		decl Float:targetDir[3];
		decl Float:newVelocity[3];
		SubtractVectors(posEnemy, rockPos, targetDir);
		NormalizeVector(targetDir,targetDir);
		ScaleVector(targetDir, 0.5);
		AddVectors(rockVelocity,targetDir,newVelocity);
		NormalizeVector(newVelocity,newVelocity);
		ScaleVector(newVelocity, vel);
		TeleportEntity(ent, NULL_VECTOR, NULL_VECTOR, newVelocity);
	} 
 	  
}
 
Float:CalRay(Float:rockPos[3], Float:angle[3], Float:offset1, Float:offset2,   Float:force[3], ent, bool:printlaser=true) 
{
	

	decl Float:ang[3];
	CopyVector(angle, ang);
	ang[0]+=offset1;
	ang[1]+=offset2;
	GetAngleVectors(ang, force, NULL_VECTOR,NULL_VECTOR);
	new Float:dis=GetRayDistance(rockPos, ang, ent, false) ;	
	if(printlaser)ShowLarserByAngleAndDistance(rockPos, ang, dis*0.5);
	//PrintToChatAll("%f %f, %f", dis, offset1, offset2);
	return dis;
}
 
GetRayHitPos2(Float:pos[3], Float: angle[3], Float:hitpos[3], ent=0, bool:useoffset=false)
{
	new Handle:trace ;
	new hit=0;
	
	trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, TraceRayDontHitSelfAndLive, ent);
	if(TR_DidHit(trace))
	{
		TR_GetEndPosition(hitpos, trace);
		hit=TR_GetEntityIndex( trace);
	}
	CloseHandle(trace);
	
	if(useoffset)
	{
		decl Float:v[3];
		MakeVectorFromPoints(hitpos, pos, v);
		NormalizeVector(v, v);
		ScaleVector(v, 15.0);
		AddVectors(hitpos, v, hitpos);
		
	}
	return hit;
}
CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
		target[1]=source[1];
			target[2]=source[2];
}
GetRayHitPos(Float:pos[3], Float: angle[3], Float:hitpos[3], self, bool:nothitsurvivor=true)
{
	new Handle:trace ;
	new hit=0;
	if(nothitsurvivor)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, TraceRayDontHitSelfAndSurvivor, self);
	}
	else
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, TraceRayDontHitSelf, self);
	}
	if(TR_DidHit(trace))
	{
			
		TR_GetEndPosition(hitpos, trace);
		hit=TR_GetEntityIndex( trace);
			
	}
	CloseHandle(trace);
	return hit;
}
Float:GetRayDistance(Float:pos[3], Float: angle[3], self, bool:nothitsurvivor=true)
{
	decl Float:hitpos[3];
	GetRayHitPos(pos, angle,hitpos, self, nothitsurvivor);
	return GetVectorDistance( pos,  hitpos);
}
bool:IfTwoPosVisible(Float:pos1[3], Float:pos2[3], self)
{
	new bool:r=true;
	new Handle:trace = TR_TraceRayFilterEx(pos2, pos1, MASK_SOLID, RayType_EndPoint, TraceRayDontHitSelfAndLive,self);
	if(TR_DidHit(trace))
	{
		r=false;
	}
 	CloseHandle(trace);
	return r;
}
Float:GetAngle(Float:x1[3], Float:x2[3])
{
	return ArcCosine(GetVectorDotProduct(x1, x2)/(GetVectorLength(x1)*GetVectorLength(x2)));
}
GetEnemy(Float:pos[3], Float:vec[3], gteam=2)
{
	new Float:min=4.0;
	decl Float:pos2[3];
	new Float:t;
	new s=0;
	for(new client = 1; client <= MaxClients; client++)
	{
		if(IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client)==gteam )
		{
			GetClientEyePosition(client, pos2);
			MakeVectorFromPoints(pos, pos2, pos2);
			t=GetAngle(vec, pos2);
			//PrintToChatAll("%N %f", client, 360.0*t/3.1415926/2.0);
			if(t<=min)
			{
				min=t;
				s=client;
			}
		}
	}
	return s;
}
 
public bool:TraceRayDontHitSelfAndSurvivor(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==2)
		{
			return false;
		}
	}
	return true;
}
public bool:TraceRayDontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	return true;
}
public bool:TraceRayDontHitSelfAndLive(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity))
		{
			return false;
		}
	}
	return true;
}