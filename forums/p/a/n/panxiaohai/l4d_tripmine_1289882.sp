/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 

#define MAX 200
#define SOUND_BLIP		"UI/Beep07.wav"

new Handle:l4d_tripmine_radius ;
new Handle:l4d_tripmine_damage ;
new Handle:l4d_tripmine_push ;
new Handle:l4d_tripmine_maxlength ;

new Handle:l4d_tripmine_limit ;
new Handle:l4d_tripmine_init ;
new Handle:l4d_tripmine_producetime ;
new Handle:l4d_tripmine_life ;


new Float:PlayerTime[MAXPLAYERS+1];
new Float:PlayerCount[MAXPLAYERS+1];
 

new Float:tripmine_pos[MAXPLAYERS+1][6];
new tripmine_planted[MAXPLAYERS+1];
new Handle:tripmine_timer[MAXPLAYERS+1]

new Handle:g_update_timer=INVALID_HANDLE;

new Tripmine[MAX];
new TripmineOwner[MAX];

new Float:TripmineTime[MAX];
new Float:TripminePos1[MAX][3];
new Float:TripminePos2[MAX][3];
new g_Index;
new g_Count;
new g_PointHurt=0;
new Float: damage;
new Float: radius;
new Float: force;

 
new L4D2Version;
new GameMode;
new g_sprite;
new bool:gamestart=true;

new color[4];
public Plugin:myinfo = 
{
	name = "Tripmine",
	author = "Pan Xiaohai",
	description = "Tripmine",
	version = "1.0",
	url = "<- URL ->"
}

public OnPluginStart()
{
  
 	l4d_tripmine_radius = 	CreateConVar("l4d_tripmine_radius", "100.0", "radius", FCVAR_PLUGIN);
	l4d_tripmine_damage = 	CreateConVar("l4d_tripmine_damage", "400.0", "damage", FCVAR_PLUGIN);
	l4d_tripmine_push =		CreateConVar("l4d_tripmine_push", "800", "push forece", FCVAR_PLUGIN);	

	l4d_tripmine_maxlength =CreateConVar("l4d_tripmine_maxlength", "800", "tripmine's maxlength [100, -]", FCVAR_PLUGIN);
	l4d_tripmine_life = 	CreateConVar("l4d_tripmine_life", "60.0", "tripmine's life", FCVAR_PLUGIN);
	
	l4d_tripmine_limit = 	CreateConVar("l4d_tripmine_limit", "10", "tripmine limit[0, 10]", FCVAR_PLUGIN);
	l4d_tripmine_init = 	CreateConVar("l4d_tripmine_init", "2" , "tripmine count when round start[0, 10]", FCVAR_PLUGIN);
 l4d_tripmine_producetime = CreateConVar("l4d_tripmine_producetime", "60.0", "how many seconds produce a tripmine[1.0, -]", FCVAR_PLUGIN);	
 
	AutoExecConfig(true, "l4d_tripmine");
	
	 GameCheck();
 
	HookConVarChange(l4d_tripmine_radius, CvarChanged);
	HookConVarChange(l4d_tripmine_damage, CvarChanged);
	HookConVarChange(l4d_tripmine_push, CvarChanged);
	
	HookEvent("round_start", round_start);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition", round_end);
	
	RegConsoleCmd("sm_tripmines", sm_tripmines);
	
	ResetAllState();
	Set();
	gamestart=true;
	
}


 GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		L4D2Version=true;
	}	
	else
	{
		L4D2Version=false;
	}
}
new Float:w_offset=25.0;
public Action:sm_tripmines(client, args)
{
 	if(GameMode==2)return Plugin_Handled;
	if (!IsValidAliveClient(client) )
		return Plugin_Handled;
	if(GetClientTeam(client)!=2)return Plugin_Handled;
	
	decl Float:vAngles[3];
	decl Float:vOrigin[3];
	decl Float:pos[3];

	GetClientEyePosition(client,vOrigin);
	GetClientEyeAngles(client, vAngles);

 	new Handle:trace = TR_TraceRayFilterEx(vOrigin, vAngles, MASK_SOLID, RayType_Infinite, TraceRayDontHitLive);

	if(TR_DidHit(trace))
	{
		TR_GetEndPosition(pos, trace);
	}
	CloseHandle(trace)
	
	decl Float:v1[3];
	decl Float:v2[3];
	 
	SubtractVectors(vOrigin, pos, v1);
	NormalizeVector(v1, v2);
	
	ScaleVector(v2, w_offset*2.0);

	AddVectors(pos, v2, v1); 

	new button=GetClientButtons(client);
	new Float:time=GetEngineTime();
	if(button & IN_USE)
	{
		 
		
		PlayerCount[client]+=(time-PlayerTime[client])/GetConVarFloat(l4d_tripmine_producetime);
		PlayerTime[client]=time;
		if(PlayerCount[client]>GetConVarFloat(l4d_tripmine_limit))PlayerCount[client]=GetConVarFloat(l4d_tripmine_limit)
		
		if(tripmine_planted[client]==0 )
		{
			if(RoundFloat(PlayerCount[client])<=0)
			{
				PrintHintText(client, "you are lack of tripmine");
				return Plugin_Handled;
			}

			tripmine_pos[client][0]=v1[0];
			tripmine_pos[client][1]=v1[1];
			tripmine_pos[client][2]=v1[2]; 
			tripmine_planted[client]=1;
			tripmine_timer[client]=CreateTimer(0.05, TripminePlantTimer, client, TIMER_REPEAT);
			EmitAmbientSound(SOUND_BLIP, v1, client, SNDLEVEL_RAIDSIREN);	
			
		
		}
		else if (tripmine_planted[client]==1)
		{
		
			decl Float:v3[3];
		
			tripmine_pos[client][3]=v1[0];
			tripmine_pos[client][4]=v1[1];
			tripmine_pos[client][5]=v1[2];
		
			v3[0]=tripmine_pos[client][0];
			v3[1]=tripmine_pos[client][1];
			v3[2]=tripmine_pos[client][2];
		

			TR_TraceRayFilter(v3, v1, MASK_SOLID, RayType_EndPoint, TraceRayDontHitLive, client);
			if (TR_DidHit(INVALID_HANDLE))
			{
				TR_GetEndPosition(pos, INVALID_HANDLE);
				
				SubtractVectors(v3, pos, v1);
				NormalizeVector(v1, v2);
				
				ScaleVector(v2, w_offset*2.0);

				AddVectors(pos, v2, pos); 
				
			}
			else
			{
				pos[0]=v1[0];	
				pos[1]=v1[1];	
				pos[2]=v1[2];
			}
			
			tripmine_pos[client][3]=pos[0];
			tripmine_pos[client][4]=pos[1];
			tripmine_pos[client][5]=pos[2];
		
			
			new Float:distance = GetVectorDistance(v3, pos);

			if(distance>GetConVarFloat(l4d_tripmine_maxlength) || distance<80.0)
			{
				KillTimer(tripmine_timer[client]);
				tripmine_timer[client]=INVALID_HANDLE;
				tripmine_planted[client]=0;
				PrintHintText(client, "tripmine is too long or too short");
			}
			else
			{
 
				PlayerCount[client]-=1.0;
				AddTripmine(client, GetEngineTime());		
 		 	 	tripmine_planted[client]=0;
				if(g_update_timer==INVALID_HANDLE)
				{
					g_update_timer=CreateTimer(0.1, UpdateTimer, 0, TIMER_REPEAT | TIMER_FLAG_NO_MAPCHANGE);
				}
				
				if(tripmine_timer[client]!=INVALID_HANDLE)KillTimer(tripmine_timer[client]);	
				tripmine_timer[client]=INVALID_HANDLE;			
				EmitAmbientSound(SOUND_BLIP, v1, client, SNDLEVEL_RAIDSIREN);		
				PrintHintText(client, "plant tripmine successfully , %d left", RoundFloat(PlayerCount[client]));
			}

		}
	}
	else
 	{
 		new find=FindTripmine(client, v1);
		if(find>=0)
		{
			tripmine_planted[client]=0;		
			RemoveTripmine(find);
			PrintHintText(client, "defuse tripmine successfully , %d left", RoundFloat(PlayerCount[client]));
			EmitAmbientSound(SOUND_BLIP, v1, client, SNDLEVEL_RAIDSIREN);
		}
		else if(find==-1)
		{		
			PrintHintText(client, "it is too far");
		}
		else 
		{
			PrintHintText(client, "you have no tripmine");
		}
		if(tripmine_planted[client]!=0)
		{
			if(tripmine_timer[client]!=INVALID_HANDLE)KillTimer(tripmine_timer[client]);
			tripmine_timer[client]=INVALID_HANDLE;
			tripmine_planted[client]=0;
		}
			
		return Plugin_Handled;
		
	}
	
	return Plugin_Handled;
}
public Action:TripminePlantTimer(Handle:timer, any:client)
{
	if (!IsValidAliveClient(client))
	{
		tripmine_planted[client]=0;
		tripmine_timer[client]=INVALID_HANDLE;
 		return Plugin_Stop;
	}
	 
	if (tripmine_planted[client]==1 )
	{

		decl Float:vAngles[3]
		decl Float:vOrigin[3]
		decl Float:pos[3]

		GetClientEyePosition(client,vOrigin)
		GetClientEyeAngles(client, vAngles)

 		new Handle:trace = TR_TraceRayFilterEx(vOrigin, vAngles, MASK_SOLID, RayType_Infinite, TraceRayDontHitLive)

		if(TR_DidHit(trace))
		{
			TR_GetEndPosition(pos, trace)
		}
		CloseHandle(trace)
		
		decl Float:v1[3];
		decl Float:v2[3];
		decl Float:v3[3];
		
		SubtractVectors(vOrigin, pos, v1);
		NormalizeVector(v1, v2);
		
		ScaleVector(v2, w_offset*2.0);

		AddVectors(pos, v2, v1); 

		v3[0]=tripmine_pos[client][0];
		v3[1]=tripmine_pos[client][1];
		v3[2]=tripmine_pos[client][2];
		
		
		TR_TraceRayFilter(v3, v1, MASK_SOLID, RayType_EndPoint, TraceRayDontHitLive, client);
		if (TR_DidHit(INVALID_HANDLE))
		{
			TR_GetEndPosition(pos, INVALID_HANDLE);	
			
			SubtractVectors(v3, pos, v1);
			NormalizeVector(v1, v2);
			
			
			ScaleVector(v2, w_offset*2.0);

			AddVectors(pos, v2, pos);			
		}
		else
		{
			pos[0]=v1[0];	
			pos[1]=v1[1];	
			pos[2]=v1[2];
		}
		
		tripmine_pos[client][3]=pos[0];
		tripmine_pos[client][4]=pos[1];
		tripmine_pos[client][5]=pos[2];
 
		
		new Float:life=0.1;
		
		new Float:width;
		if(L4D2Version)width = 4.0;
		else width = 10.0;
		
		TE_SetupBeamPoints(v3, pos, g_sprite, 0, 0, 0, life, width, width, 1, 0.0, color, 0);
		TE_SendToAll();
		
		//PrintCenterText(client, "tripmine");
		
		if(GetVectorDistance(v3, pos)>GetConVarFloat(l4d_tripmine_maxlength)*2.0)
		{
		
			tripmine_planted[client]=0;
			tripmine_timer[client]=INVALID_HANDLE;
			PrintHintText(client, "trimpine is out of range");
			return Plugin_Stop;
		}
		
		return Plugin_Continue;
	}
	else
	{
		tripmine_planted[client]=0;
		tripmine_timer[client]=INVALID_HANDLE;
		return Plugin_Stop;
	}

}
FindTripmine(client, Float:pos[3])
{
	new Float:d1; 
	new Float:d2;
	new Float:d0;
	new Float:min=9999.0;
	new find=-2;
	 
	for(new i=0; i<=g_Index && i<MAX; i++)
	{
		if(Tripmine[i]==1 && TripmineOwner[i]==client)
		{
			d1=GetVectorDistance(pos, TripminePos1[i]);
			d2=GetVectorDistance(pos, TripminePos2[i]);
			if(d1<d2)d0=d1;
			else d0=d2;
			//PrintToChatAll("%d, %f, %f ,%f, %f", i, d1, d2, d0, min);
			if(d0 <= min)
			{
				min=d0;
				find=i;
			}
			
		}
	}
	if(find>=0 && min<150.0)
	{
		return find;
	}
	else if(find>=0)
	{
		return -1;
	}
	return -2;
}
AddTripmine(client, time, flag=0)
{
	new pos=0;
	for(new i=0; i<=g_Index+1 && i<MAX; i++)
	{
		if(Tripmine[i]==0)
		{
			pos=i;
			break;
		}
	}
	TripminePos1[pos][0]=tripmine_pos[client][0];
	TripminePos1[pos][1]=tripmine_pos[client][1];
	TripminePos1[pos][2]=tripmine_pos[client][2];

	TripminePos2[pos][0]=tripmine_pos[client][3];
	TripminePos2[pos][1]=tripmine_pos[client][4];
	TripminePos2[pos][2]=tripmine_pos[client][5];
	
	TripmineOwner[pos]=client;
	TripmineTime[pos]=time;
	Tripmine[pos]=1;
	
	if(pos>g_Index)g_Index=pos;
	g_Count++;
	//PrintToChatAll("add , %d", pos);
}
RemoveTripmine(index)
{
	if(Tripmine[index]==1)
	{
		Tripmine[index]=0;	
		TripmineOwner[index]=0;
		TripmineTime[index]=0;
		g_Count--;
	}
}
public Action:UpdateTimer(Handle:timer, any:client)
{
	if (!gamestart)
	{
		g_update_timer=INVALID_HANDLE;
 		return Plugin_Stop;
	}
	if(g_Count==0)return Plugin_Continue;
	new client=0;
	new Float:time=GetEngineTime();
	new Float:life=GetConVarFloat(l4d_tripmine_life);
 
	new Float:laserlife=0.08;
	new Float:width;
	if(L4D2Version)width = 2.0
	else width = 5.0;
	decl Float:pos[3];
	for (new i=0; i<=g_Index && i<MAX; i++)
	{
		new ok=false;
		if(Tripmine[i]==1)
		{
			
			client = TripmineOwner[i];
		
			if(IsValidAliveClient(client))
			{	
				
				if(time-TripmineTime[i]<GetConVarFloat(l4d_tripmine_life))
				{
					ok=true;
					TR_TraceRayFilter(TripminePos1[i], TripminePos2[i], MASK_SOLID, RayType_EndPoint, TraceRayDontHitSelf, 0);
				
					if (TR_DidHit(INVALID_HANDLE))
					{
						TR_GetEndPosition(pos, INVALID_HANDLE);
						ExplodeTripmine(pos);
						TE_SetupBeamPoints(TripminePos1[i],  TripminePos2[i], g_sprite, 0, 0, 0, laserlife, width*4.0, width*4.0, 1, 0.0, color, 0);
						TE_SendToAll();
						
					}
					else
					{
						TE_SetupBeamPoints(TripminePos1[i],  TripminePos2[i], g_sprite, 0, 0, 0, laserlife, width, width, 1, 0.0, color, 0);
						TE_SendToAll();
					}

				}
			}
		}
		if(!ok)
		{
			RemoveTripmine(i);
		}
	}
	return Plugin_Continue;
}
public Action:ExplodeTripmine(Float:pos[3])
{
 
 
	if(g_PointHurt > 0)
	{
		if(IsValidEdict(g_PointHurt))
		{
			TeleportEntity(g_PointHurt, pos, NULL_VECTOR, NULL_VECTOR);  
			AcceptEntityInput(g_PointHurt, "Hurt", -1);     
		}
		else g_PointHurt=CreatePointHurt();
	}
	else 
	{
		g_PointHurt=CreatePointHurt();
	}
  
 	new push = CreateEntityByName("point_push");         
  	DispatchKeyValueFloat (push, "magnitude", force);                     
	DispatchKeyValueFloat (push, "radius", radius*1.0);                     
  	SetVariantString("spawnflags 24");                     
	AcceptEntityInput(push, "AddOutput");
 	DispatchSpawn(push);   
	TeleportEntity(push, pos, NULL_VECTOR, NULL_VECTOR);  
 	AcceptEntityInput(push, "Enable", -1, -1);
	CreateTimer(0.2, DeletePushForce, push);
	 
 	decl Float:vec[3];
	vec[0]=GetRandomFloat(-1.0, 1.1);
	vec[1]=GetRandomFloat(-1.0, 1.1);
	vec[2]=GetRandomFloat(-1.0, 1.1);
	TE_SetupSparks(pos,vec,1, 3);
	TE_SendToAll();
 
	return;
}
CreatePointHurt()
{
	new pointHurt=CreateEntityByName("point_hurt");
	if(pointHurt)
	{
		DispatchKeyValueFloat(pointHurt, "Damage", damage);        
		DispatchKeyValueFloat(pointHurt, "DamageRadius", radius);     
		DispatchKeyValue(pointHurt, "DamageDelay", "0.0");   
		DispatchSpawn(pointHurt);
	}
	return pointHurt;
}
public Action:DeletePushForce(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_push", false))
				{
 					AcceptEntityInput(ent, "Disable");
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
	 }
}
public Action:DeletePointHurt(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_hurt", false))
				{
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
		 }

}
 
public Action:round_start(Handle:Spawn_Event, const String:Spawn_Name[], bool:Spawn_Broadcast)
{
	ResetAllState();
 
	gamestart=true;
}
public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	gamestart=false;
}
 
ResetAllState()
{
	new time=GetEngineTime();
 
	for (new x = 0; x < MAXPLAYERS+1; x++)
	{
		PlayerCount[x]=GetConVarFloat(l4d_tripmine_init);
		PlayerTime[x]=time;
		tripmine_planted[x]=0;
		tripmine_timer[x]=INVALID_HANDLE;
		
  	}
	for(new x=0; x<MAX; x++)
	{
		Tripmine[x]=0;
	}
	g_Count=0;
	g_Index=0;
	g_PointHurt=0;
	g_update_timer=INVALID_HANDLE;
}
public OnConfigExecuted()
{
	 
	Set();
}
Set()
{
	radius=GetConVarFloat(l4d_tripmine_radius);
	damage=GetConVarFloat(l4d_tripmine_damage);
	force=GetConVarFloat(l4d_tripmine_push);
 
}
public CvarChanged(Handle:convar, const String:oldValue[], const String:newValue[])
{
	Set();
}
public OnMapStart()
{
	color[0] = 200; 
	color[1] = 0; 
	color[2] = 0; 
	color[3] = 255; 
	if(L4D2Version)
	{
		g_sprite = PrecacheModel("materials/sprites/laserbeam.vmt");	
	}
	else
	{
		g_sprite = PrecacheModel("materials/sprites/laser.vmt");	
 	}

}
bool:IsValidAliveClient(client)
{
 if (client <= 0) return false;
 else if (client > MaxClients) return false;
 else if(!IsClientInGame(client))return false;
 else if (!IsPlayerAlive(client)) return false;
	else return true;
}
public bool:TraceRayDontHitLive(entity, mask, any:data)
{
	if( entity <= GetMaxClients())
	{
		return false;
	}
	if(entity == data) 
	{
		return false; 
	}
	decl String:edictname[128];
	GetEdictClassname(entity, edictname, 128);
	if(StrContains(edictname, "infected")>=0)
	{
		return false;
	}
	return true;
}
public bool:TraceRayDontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	return true;
}