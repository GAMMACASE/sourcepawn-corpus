/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdkhooks>
#include <sdktools>
#include <sdktools_functions> 
#define TagRain -5
#define SOUND1  "physics/flesh/flesh_impact_bullet5.wav"
new Handle:l4d_neigong_range ;
new Handle:l4d_neigong_radius ;
new Handle:l4d_neigong_damage ;
new Handle:l4d_neigong_push ;
new Handle:l4d_neigong_energemax ;
new Handle:l4d_neigong_energeuse ;
new Handle:l4d_neigong_energerecover ;      
new Float: UseTime[MAXPLAYERS+1];
new Float: Energe[MAXPLAYERS+1];
new Float: FireTime[MAXPLAYERS+1];
new Handle: Runing[MAXPLAYERS+1];
new Float: ShoveTime[MAXPLAYERS+1];

new Float: Origins[MAXPLAYERS+1][3];

new Float: Angles[MAXPLAYERS+1][3];

new Float:Truns[MAXPLAYERS+1];
new Float:Distances[MAXPLAYERS+1];
new Float:Radius[MAXPLAYERS+1];
new Float:TrunSpeed[MAXPLAYERS+1];
new Float:RunSpeed[MAXPLAYERS+1];
new Float:RadiusSpeed[MAXPLAYERS+1];

new  String:rangestring[32];

new Float: energeuse;
new Float: energemax;
new Float: energerecover;
new 	g_iVelocity ;
new L4D2Version;
new GameMode;
new g_sprite;
 new g_PointHurt=0;
public Plugin:myinfo = 
{
	name = "Neigong",
	author = "Pan Xiaohai",
	description = "Neigong",
	version = "1.0",
	url = "<- URL ->"
}

public OnPluginStart()
{
	l4d_neigong_range = CreateConVar("l4d_neigong_range", "300.0", " ", FCVAR_PLUGIN);
 	l4d_neigong_radius = CreateConVar("l4d_neigong_radius", "10.0", " ", FCVAR_PLUGIN);
	l4d_neigong_damage = CreateConVar("l4d_neigong_damage", "100", " ", FCVAR_PLUGIN);
	 
	l4d_neigong_energemax = CreateConVar("l4d_neigong_energemax", "100.0", " ", FCVAR_PLUGIN);
	l4d_neigong_energeuse = CreateConVar("l4d_neigong_energeuse", "5.0", " ", FCVAR_PLUGIN);
	l4d_neigong_energerecover = CreateConVar("l4d_neigong_energerecover", "0.2", " ", FCVAR_PLUGIN);	
	
	
	g_iVelocity = FindSendPropOffs("CBasePlayer", "m_vecVelocity[0]");
	
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		L4D2Version=true;
	}	
	else
	{
		L4D2Version=false;
	}

	AutoExecConfig(true, "l4d_neigong");
 
	HookConVarChange(l4d_neigong_energemax, CvarChanged);
	HookConVarChange(l4d_neigong_energeuse, CvarChanged);
	HookConVarChange(l4d_neigong_energerecover, CvarChanged);	
	HookConVarChange(l4d_neigong_range, CvarChanged);
	HookEvent("weapon_fire", weapon_fire);

	HookEvent("round_start", RoundStart);
	ResetAllState();
	Set();
 
}
public OnGameFrame()
{
	 
	new Float:currenttime=GetEngineTime();
 
	for (new client = 1; client <= MaxClients; client++)
	{
		if(IsClientInGame(client) && GetClientTeam(client)==2 && IsPlayerAlive(client) && !IsFakeClient(client))
		{
			Do(client, currenttime);
		}
	}
    
}
NeiGong(client, Float:time)
{
	Energe[client]+=(time-FireTime[client])*energerecover;
	FireTime[client]=time;
	if( time-UseTime[client]>0.1)
	{
		if(Energe[client]-energeuse>0.0)
		{
			
			if(Energe[client]>energemax)Energe[client]=energemax;
			Energe[client]=Energe[client]-energeuse;
			UseTime[client]=time;
			
			GetClientEyePosition(client, Origins[client]);
			GetClientEyeAngles(client, Angles[client]);
			
			Truns[client]=GetRandomFloat(-360.0, 360.0);
			if(GetRandomInt(0, 1)==0)TrunSpeed[client]=7.0;
			else TrunSpeed[client]=-7.0;
			
			Distances[client]=20.0;
			RunSpeed[client]=16.0;		
			
			Radius[client]=GetConVarFloat(l4d_neigong_radius);
			RadiusSpeed[client]=5.0;

			Runing[client] = 1;
			
			PrintHintText(client, "energe %d", RoundFloat(Energe[client]));
		 
			
			EmitSoundToAll(SOUND1, client); 
			 
		}
		else
		{
			PrintHintText(client, "not enough energe");
		}
	}	
}
Do(client, Float:currenttime )
{
	new button=GetClientButtons(client);
	if((button & IN_ATTACK2) && (button & IN_USE) && !L4D2Version)
	{
		new Float:f=GetEntPropFloat(client, Prop_Send, "m_flNextShoveTime");
		
		if(f!=ShoveTime[client])
		{
			NeiGong(client, currenttime);
		}
		ShoveTime[client]=f;
	}
	 
	if(Runing[client]==1 && Distances[client]>GetConVarFloat(l4d_neigong_range))
	{
		Runing[client]=0;
	}
	if(Runing[client]==0)return;
	
	Distances[client]+=RunSpeed[client];
	Truns[client]+=TrunSpeed[client];
	Radius[client]+=RadiusSpeed[client];
	 
	
	
	//PrintToChat(client, "d %f %f", Distances[client], Truns[client]);
	decl Float:angle[3], pos1[3], pos2[3];
	CopyVector(Angles[client], angle);
	angle[1]+=90.0;
	angle[0]+=Truns[client];	
	GetAngleVectors(angle, angle, NULL_VECTOR,NULL_VECTOR);
	NormalizeVector(angle, angle);
	ScaleVector(angle, Radius[client]);	
	AddVectors(Origins[client], angle, pos1);
	
	//PrintToChat(client, "%f %f %f", pos1[0], pos1[1], pos1[2]);
	
	CopyVector(Angles[client], angle);
	angle[1]+=90.0;
	angle[0]+=Truns[client]+180.0;	
	GetAngleVectors(angle, angle, NULL_VECTOR,NULL_VECTOR);
	NormalizeVector(angle, angle);
	ScaleVector(angle, Radius[client]);	
	AddVectors(Origins[client], angle, pos2);
  	
	CopyVector(Angles[client], angle);
	GetAngleVectors(angle, angle, NULL_VECTOR,NULL_VECTOR);
	NormalizeVector(angle, angle);
	ScaleVector(angle, Distances[client]);
	AddVectors(pos1, angle, pos1);
	AddVectors(pos2, angle, pos2);
 
	new hittarget=0;
	new Handle:trace = TR_TraceRayFilterEx(pos1, pos2, MASK_SOLID, RayType_EndPoint, TraceRayHitInfected, client);
	
	decl Float:pos[3];
	if(TR_DidHit(trace))
	{
	
		TR_GetEndPosition(pos, trace);
		hittarget=TR_GetEntityIndex( trace);
			
	}
	CloseHandle(trace);
	new tag=0;
	if(hittarget>0)		
	{
		DoPointHurtForInfected(hittarget, client , pos);
		tag=1;
	}
	ShowLarserByPos(pos1, pos2, tag, 0.09);
	 
}

new String:N[20];
DoPointHurtForInfected(victim, attacker=0, Float:pos[3])
{
	if(g_PointHurt > 0)
	{
		if(IsValidEdict(g_PointHurt))
		{
			if( true)
			{		
				DispatchKeyValueFloat(g_PointHurt, "DamageRadius", 50.0); 
				DispatchKeyValueFloat(g_PointHurt, "Damage", GetConVarFloat(l4d_neigong_damage)); 
				if(L4D2Version)
				{
					 
					DispatchKeyValue(g_PointHurt, "DamageType", "64"); 
				}
				else 
				{
				 
					DispatchKeyValue(g_PointHurt, "DamageType", "64"); 
				}
				DispatchKeyValue(g_PointHurt, "DamageDelay", "0.0"); 
				//DispatchSpawn(g_PointHurt);
				TeleportEntity(g_PointHurt, pos, NULL_VECTOR, NULL_VECTOR); 
				AcceptEntityInput(g_PointHurt, "Hurt", attacker); 
			}
		}
		else
		{
			g_PointHurt=CreatePointHurt();
		}
	}
	else g_PointHurt=CreatePointHurt();
}
CreatePointHurt()
{
	new pointHurt=CreateEntityByName("point_hurt");
	if(pointHurt)
	{
 		DispatchSpawn(pointHurt);
	}
	return pointHurt;
}
 public Action:weapon_fire(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(!L4D2Version)return;
 	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	 
	if(GetClientTeam(client)==2)
	{
		if(GetClientButtons(client) & IN_USE )
		{
			
			decl String:item[65];
			GetEventString(event, "weapon", item, 65);
			if( StrContains(item, "melee")>=0 )
			{
				new Float:time=GetEngineTime();
				NeiGong(client, time);
			}
			
		}
		
	}
}

 
ShowLarserByPos(Float:pos1[3], Float:pos2[3], flag=0, Float:life=0.06)
{
	decl color[4];
	if(flag==0)
	{
		color[0] = 200; 
		color[1] = 200;
		color[2] = 200;
		color[3] = 230;
	}
	else
	{
		color[0] = 200; 
		color[1] = 0;
		color[2] = 0;
		color[3] = 230;
	}
	
	 
	new Float:width1=0.5;
	new Float:width2=0.5;		
	if(L4D2Version)
	{
		width2=0.3;
		width2=0.3;
	}
 	
	TE_SetupBeamPoints(pos1, pos2, g_sprite, 0, 0, 0, life, width1, width2, 1, 0.0, color, 0);
	TE_SendToAll();
}
public bool:TraceRayHitInfected(entity, mask, any:self)
{
	if(entity<=0)return false;
	if(entity == self) return false;
    if(entity>0 && entity<=MaxClients)
	{
		//if(IsClientInGame(entity) && GetClientTeam(entity)==3)
		{
			return true;
		}
	}
	else if(IsValidEdict(entity))
	{
		decl String:classname[20];
		GetEdictClassname(entity, classname, 20);
		if(StrContains(classname, "infected")>=0)
		{
			return true;
		}
	}
	return false;
}
  
  
public Action:RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	ResetAllState();
	g_PointHurt=0;
	return Plugin_Continue;
}
ResetAllState()
{
	new Float:t=GetEngineTime();
	for (new x = 0; x < MAXPLAYERS+1; x++)
	{
		UseTime[x]=t;
		Energe[x]=0.0;
		FireTime[x]=t;
		ShoveTime[x]=0;
		Runing[x]=INVALID_HANDLE;
		
	}
}
public OnConfigExecuted()
{
	ResetAllState();
	Set();
}
Set()
{
	energeuse=GetConVarFloat(l4d_neigong_energeuse);
	energemax=GetConVarFloat(l4d_neigong_energemax);
	energerecover=GetConVarFloat(l4d_neigong_energerecover);
	GetConVarString(l4d_neigong_range, rangestring, 32);
}
public CvarChanged(Handle:convar, const String:oldValue[], const String:newValue[])
{
	Set();
}
public OnMapStart()
{
	PrecacheModel("models/props_junk/propanecanister001a.mdl", true);
	PrecacheModel("models/props_junk/gascan001a.mdl", true);
	 
	PrecacheParticle("gas_explosion_pump");
	PrecacheParticle("gas_explosion_main");
	
	if(L4D2Version)
	{
		g_sprite = PrecacheModel("materials/sprites/laserbeam.vmt");	
		PrecacheSound(SOUND1);
		PrecacheParticle("fireworks_03");
		
	}
	else
	{
		g_sprite = PrecacheModel("materials/sprites/laser.vmt");	
 
	}

}
 
 

CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
		target[1]=source[1];
			target[2]=source[2];
}
 
 
public DeleteEntity(any:ent, String:name[])
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, name, false))
		 {
			AcceptEntityInput(ent, "Kill"); 
			RemoveEdict(ent);
		 }
	 }
}
 
public Action:DeletePushForce(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_push", false))
				{
 					AcceptEntityInput(ent, "Disable");
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
	 }
}
public Action:DeletePointHurt(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_hurt", false))
				{
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
		 }

}
public ShowParticle(Float:pos[3], Float:angle[3], String:particlename[], Float:time)
{
 new particle = CreateEntityByName("info_particle_system");
 if (IsValidEdict(particle))
 {
 	decl Float:v[3];
	CopyVector(angle, v);
	GetAngleVectors(angle, v, NULL_VECTOR, NULL_VECTOR);
	angle[2]+=0.0;
	angle[1]+=0.0;
	angle[0]+=90.0;
 	DispatchKeyValue(particle, "effect_name", particlename);
	DispatchKeyValue(particle, "targetname", "particle");
	DispatchSpawn(particle);
	ActivateEntity(particle);
	TeleportEntity(particle, pos, angle, NULL_VECTOR);
	AcceptEntityInput(particle, "start");
	CreateTimer(time, DeleteParticles, particle);
 } 
}
 
public PrecacheParticle(String:particlename[])
{
 new particle = CreateEntityByName("info_particle_system");
 if (IsValidEdict(particle))
 {
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(0.01, DeleteParticles, particle);
 } 
}

public Action:DeleteParticles(Handle:timer, any:particle)
{
	 if (IsValidEntity(particle))
	 {
		 decl String:classname[64];
		 GetEdictClassname(particle, classname, sizeof(classname));
		 if (StrEqual(classname, "info_particle_system", false))
			{
				AcceptEntityInput(particle, "stop");
				AcceptEntityInput(particle, "kill");
				RemoveEdict(particle);
			}
	 }
}
public bool:TraceRayDontHitSelfAndSurvivor(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==2)
		{
			return false;
		}
	}
	return true;
}
public bool:TraceRayDontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	return true;
}
public bool:TraceRayDontHitSelfAndLive(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity))
		{
			return false;
		}
	}
	return true;
}