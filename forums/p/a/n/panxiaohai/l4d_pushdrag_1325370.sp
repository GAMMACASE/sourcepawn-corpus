/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 
new g_iVelocity ;
public Plugin:myinfo = 
{
	name = "Push And Drag",
	author = "Pan Xiaohai",
	description = "<- Description ->",
	version = "1.0",
	url = "<- URL ->"
}

public OnPluginStart()
{	
	g_iVelocity = FindSendPropOffs("CBasePlayer", "m_vecVelocity[0]");
}
new Float:currenttime;
new Float:lasttime;
new Float:ShoveTime[MAXPLAYERS+1];
public OnGameFrame()
{
	currenttime=GetEngineTime();
	new Float:duration=currenttime-lasttime;
	if(duration<0.0 || duration>1.0)duration=0.0;
  	for(new client = 1; client <= MaxClients; client++)
	{
		if(IsClientInGame(client) && IsPlayerAlive(client) && !IsFakeClient(client))
		{
			if(GetClientTeam(client)==3 && IsPlayerGhost(client))
			{
			}
			else 
			{
				Do(client, currenttime);
			}
		}
	}
	lasttime=currenttime;
}
Do(client , Float:ctime)
{
	new button=GetClientButtons(client);

	if ((button & IN_ZOOM) || (button & IN_USE)) 
	{
		new bool:ok=false;
		new Float:force=1.0;
		new Float:mindis=80.0;
		if(button & IN_ATTACK2)
		{
			new Float:f=GetEntPropFloat(client, Prop_Send, "m_flNextShoveTime");
		
			if(f!=ShoveTime[client])
			{
				ok=true;
				force=3.0
				mindis=100.0;
			}
			ShoveTime[client]=f;
		}
		if(ok){}
		else if(button & IN_FORWARD)ok=true;
		else if(button & IN_BACK)
		{
			ok=true;
			force=-0.5;
			mindis=100.0;
		}
		if(ok)
		{
			decl Float:vAngles[3];
			decl Float:vOrigin[3];
			decl Float:pos[3];

			GetClientEyePosition(client,vOrigin);
			GetClientEyeAngles(client, vAngles);

			new Handle:trace = TR_TraceRayFilterEx(vOrigin, vAngles, MASK_SOLID, RayType_Infinite, TraceRayDontHitSelf, client);

			if(TR_DidHit(trace))
			{
				TR_GetEndPosition(pos, trace);
				new ent=TR_GetEntityIndex(trace);
				if(ent>0)
				{
					new Float:dis=GetVectorDistance(vOrigin, pos);
					
					if(dis<mindis)
					{
						decl String:classname[64];
						GetEdictClassname(ent, classname, 64);		
						//PrintToChatAll("%s", classname);
						if(StrContains(classname, "ladder")!=-1){}
						else if(StrContains(classname, "door")!=-1){}
						else 
						{
							decl Float:volicity[3];
							if(force<0.0)
							{
								GetClientAbsOrigin(client,vOrigin);
								SubtractVectors(pos, vOrigin, volicity);
							}
							else 
							{
								GetAngleVectors(vAngles, volicity, NULL_VECTOR, NULL_VECTOR);
							}
							NormalizeVector(volicity, volicity);
							if(dis<30.0 && force<0.0)ScaleVector(volicity, force*0.0);
							else ScaleVector(volicity, force*300.0);
							TeleportEntity(ent, NULL_VECTOR, NULL_VECTOR, volicity);
							
							if(StrContains(classname, "prop_")!=-1)
							{
								SetEntPropEnt(ent, Prop_Data, "m_hPhysicsAttacker", client);
								SetEntPropFloat(ent, Prop_Data, "m_flLastPhysicsInfluenceTime", ctime);
							}
						}
					}
				}
			}
			CloseHandle(trace)
		}	 
	}

 	 
}
bool:IsPlayerGhost (client)
{
	if (GetEntData(client, FindSendPropInfo("CTerrorPlayer", "m_isGhost"), 1))
		return true;
	return false;
}
public bool:TraceRayDontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	return true;
}