/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 
#include <sdkhooks>
#define Model_Witch "models/infected/witch.mdl"
#define Model_Witch2 "models/infected/witch.mdl"
#define MODEL_W_MOLOTOV "models/w_models/weapons/w_eq_molotov.mdl"

new Anim[90];
new AnimCount=2;
new WitchEnt[MAXPLAYERS+1];
new Float:PressTime[MAXPLAYERS+1];
new Float:LastTime[MAXPLAYERS+1];
new WeaponFireEnt[MAXPLAYERS+1];
new bool:WitchViewOn[MAXPLAYERS+1];
new Float:OffSets[100][3];


new GameMode;
new L4D2Version;
public Plugin:myinfo = 
{
	name = "Witch Guard",
	author = "Pan XiaoHai",
	description = "<- Description ->",
	version = "1.1",
	url = "<- URL ->"
}
new Handle:l4d_witch_onback_bestpose;
new Handle:l4d_witch_guard_damage;
new Handle:l4d_witch_guard_range;
new Handle:l4d_witch_guard_gun_count; 
new Handle:l4d_witch_guard_shotonback; 

new WitchGaurdDummy[MAXPLAYERS+1]; 
new WitchGaurdButton[MAXPLAYERS+1]; 
new WitchGaurdEnt[MAXPLAYERS+1]; 
new Float:WitchGaurdScanTime[MAXPLAYERS+1]; 
new WitchGaurdWeaponEnt[MAXPLAYERS+1][21]; 
new WitchGaurdCount=0;

public OnPluginStart()
{
	GameCheck(); 	
	if(L4D2Version)SetAnimL4d2();
	else SetAnimL4d1();
	if(GameMode!=1)return;
	l4d_witch_onback_bestpose = CreateConVar("l4d_witch_onback_bestpose", "0", "0: random pose, 1: best pose", FCVAR_PLUGIN);
	l4d_witch_guard_damage = CreateConVar("l4d_witch_guard_damage", "0.5", "attack dmage, 1.0: normal [0.1, 1.0]", FCVAR_PLUGIN);
	l4d_witch_guard_range = CreateConVar("l4d_witch_guard_range", "600.0", "attack range", FCVAR_PLUGIN);
	l4d_witch_guard_gun_count = CreateConVar("l4d_witch_guard_gun_count", "3", "gun count [0, 6]", FCVAR_PLUGIN); 
	l4d_witch_guard_shotonback = CreateConVar("l4d_witch_guard_shotonback", "0", "0: do not shot on back, 1: shot", FCVAR_PLUGIN); 

	
	AutoExecConfig(true, "witch_guard_l4d");  
 
 	HookEvent("witch_killed", witch_killed );  
	HookEvent("player_bot_replace", player_bot_replace );	 
	HookEvent("round_start", round_end);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition", round_end);	 
 	
	RegConsoleCmd("sm_witch", sm_witch); 
	RegConsoleCmd("sm_witchpose", sm_witchpose);  
	ResetAllState();
}
GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	GameMode=GameMode+0;
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
 
		L4D2Version=true;
	}	
	else
	{
 
		L4D2Version=false;
	}
 
}
public OnMapStart()
{  
	PrecacheModel(Model_Witch);
	if(L4D2Version)PrecacheModel(Model_Witch2);
	PrecacheModel(MODEL_W_MOLOTOV);
}
new best_amin=0;
SetAnimL4d2()
{
	OffSets[1]={-5.000000,26.000000,-100.000000};
	OffSets[2]={-3.000000,32.000000,-100.000000};
	OffSets[3]={-1.000000,28.000000,-100.000000};
	OffSets[5]={-1.000000,28.000000,-100.000000};
	OffSets[7]={1.000000,26.000000,-100.000000};
	OffSets[8]={-3.000000,26.000000,-100.000000};
	OffSets[10]={-3.000000,24.000000,-100.000000};
	OffSets[16]={1.000000,28.000000,-100.000000};
	OffSets[18]={1.000000,32.000000,-100.000000}; 
	OffSets[35]={-5.000000,4.000000,-100.000000};
	OffSets[37]={1.000000,28.000000,-100.000000}; 
	OffSets[44]={-1.000000,28.000000,-100.000000};
	OffSets[45]={-1.000000,30.000000,-100.000000};
	OffSets[46]={-1.000000,32.000000,-100.000000};
	OffSets[49]={-3.000000,32.000000,-100.000000};
	OffSets[51]={-1.000000,30.000000,-100.000000};
	OffSets[54]={3.000000,32.000000,-100.000000};
	OffSets[55]={-1.000000,30.000000,-100.000000};
	OffSets[59]={-1.000000,28.000000,-100.000000};
	OffSets[61]={-5.000000,24.000000,-100.000000};
	OffSets[62]={-5.000000,22.000000,-100.000000};
	OffSets[66]={-5.000000,30.000000,-100.000000};
	OffSets[73]={-5.000000,0.000000,-100.000000};
	OffSets[74]={1.000000,10.000000,-100.000000};
	OffSets[76]={-5.000000,32.000000,-100.000000};
	OffSets[77]={-5.000000,34.000000,-100.000000}; //best
	OffSets[79]={-9.000000,20.000000,-100.000000};
	OffSets[80]={-15.000000,18.000000,-100.000000};
	AnimCount=0;
	for(new i=0;i<90; i++)
	{
		if(OffSets[i][2]==-100.0)
		{		
			Anim[AnimCount]=i;
			AnimCount++;
		}
	}
	best_amin=77;
}
SetAnimL4d1()
{
	OffSets[1]={1.000000,32.000000,-100.000000};
	OffSets[3]={-1.000000,28.000000,-100.000000};
	OffSets[4]={1.000000,28.000000,-100.000000};
	OffSets[5]={1.000000,32.000000,-100.000000};
	OffSets[6]={1.000000,22.000000,-100.000000};
	OffSets[9]={3.000000,26.000000,-100.000000};
	OffSets[29]={-1.000000,30.000000,-100.000000};
	OffSets[32]={-1.000000,30.000000,-100.000000};
	OffSets[36]={1.000000,32.000000,-100.000000};
	OffSets[37]={-1.000000,32.000000,-100.000000};
	OffSets[41]={-1.000000,32.000000,-100.000000};
	OffSets[43]={-1.000000,32.000000,-100.000000};
	OffSets[46]={1.000000,32.000000,-100.000000};
	OffSets[47]={1.000000,26.000000,-100.000000};
	OffSets[51]={1.000000,24.000000,-100.000000};
	OffSets[53]={-1.000000,20.000000,-100.000000};
	OffSets[54]={-5.000000,20.000000,-100.000000};
	OffSets[57]={-3.000000,20.000000,-100.000000};
	OffSets[65]={-9.000000,2.000000,-100.000000};
	OffSets[66]={-1.000000,14.000000,-100.000000};
	OffSets[68]={-1.000000,36.000000,-100.000000};
	OffSets[69]={-3.000000,32.000000,-100.000000}; //best 
	OffSets[70]={-1.000000,32.000000,-100.000000};
	OffSets[72]={-9.000000,18.000000,-100.000000};
	AnimCount=0;
	for(new i=0;i<90; i++)
	{
		if(OffSets[i][2]==-100.0)
		{		
			Anim[AnimCount]=i;
			AnimCount++;
		}
	}	
	best_amin=69;
}
 
public Action: sm_witchpose(client,args)
{
	for(new i=1; i<=MaxClients; i++)
	{
			
		if( IsWitch(WitchEnt[i]) )
		{
			client=i;
			if(client>0 && IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client)==2)
			{
				new anim=Anim[ GetRandomInt(0,AnimCount-1) ]; 
				new Float:ang[3]; 
				SetVector(ang, 0.0, 0.0, 90.0);
				new Float:pos[3];
				pos[0]=OffSets[anim][0];
				pos[1]=OffSets[anim][1];
				
				TeleportEntity(WitchEnt[client], pos, ang, NULL_VECTOR);		
				
				SetEntProp(WitchEnt[client], Prop_Send, "m_nSequence", anim);
				SetEntPropFloat(WitchEnt[client], Prop_Send, "m_flPlaybackRate", 1.0);		 
				
				//PrintToChatAll("pose m_nSequence %d ", anim);

				
			}
		}
	} 
	return Plugin_Continue;
	
} 
new g_testanim=0;
public Action:sm_witch(client,args)
{
	if(client>0)
	{
		WitchViewOn[client]=!WitchViewOn[client];
		if(WitchViewOn[client])PrintToChat(client, "\x04witch \x03view is \x04on");
		else PrintToChat(client, "\x04witch \x03view is \x04off, \x03but others still can see it on your back");
		
		/*
		g_testanim++;
		SetEntProp(WitchGaurdEnt[0], Prop_Send, "m_nSequence", g_testanim);
		PrintToChatAll("anim %d", g_testanim);
		SetEntPropFloat(WitchGaurdEnt[0], Prop_Send, "m_flPlaybackRate", 1.0);		 
		*/
		

	}
}
 
public Action:player_death(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
	new victim = GetClientOfUserId(GetEventInt(hEvent, "userid")); 
	if(victim>0 && victim<=MaxClients)
	{
		DeleteDecoration(victim);
		SDKUnhook(victim, SDKHook_PreThink,  PreThinkClient);  
	}
	return Plugin_Continue;	 
}
public player_bot_replace(Handle:Spawn_Event, const String:Spawn_Name[], bool:Spawn_Broadcast)
{
 	new client = GetClientOfUserId(GetEventInt(Spawn_Event, "player"));
	new bot = GetClientOfUserId(GetEventInt(Spawn_Event, "bot"));   
	if(client>0)
	{
		if(WitchEnt[client]>0)DeleteDecoration(client);
		SDKUnhook(client, SDKHook_PreThink,  PreThinkClient);  
	}
	if(bot>0)
	{
		if(WitchEnt[bot]>0)DeleteDecoration(bot);
		SDKUnhook(client, SDKHook_PreThink,  PreThinkClient);  
	}
}
public Action:witch_killed(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
	new attacker = GetClientOfUserId(GetEventInt(hEvent, "userid")); 
	if(attacker>0 && attacker<=MaxClients)
	{
		if(IsClientInGame(attacker) && IsPlayerAlive(attacker) && GetClientTeam(attacker)==2)
		{ 
			CreateDecoration(attacker);
			PrintToChatAll("\x04%N \x03put witch on his back", attacker);
			PrintToChat(attacker, "\x04!witch \x03 : toggle to see or hide your own witch");
			PrintToChat(attacker, "\x03press\x04!use button \x03to put witch down");
	
		}
	}
	return Plugin_Continue;	 
}
public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	ResetAllState();
}
ResetAllState()
{
	WitchGaurdCount=0;
	for(new i=0; i<=MaxClients; i++)
	{
		WitchEnt[i]=0;
		WeaponFireEnt[i]=0;
		WitchViewOn[i]=false;
		WitchGaurdButton[i]=0; 
		WitchGaurdDummy[i]=0;
		for(new j=0 ; j<21; j++)
		{
		 	WitchGaurdWeaponEnt[i][j]=0;
		}
	}
}
bool:IsWitch(ent)
{
	if(ent>0 && IsValidEdict(ent) && IsValidEntity(ent))
	{
		return true;
	}
	else return false;
}
 
DeleteDecoration(client)
{
	new witchent=	WitchEnt[client] ;
	new fireent=WeaponFireEnt[client];

	WitchEnt[client]=0;
	WeaponFireEnt[client]=0;
	
	if(IsWitch(witchent))
	{  
		AcceptEntityInput(witchent, "kill"); 
	}
	if(fireent>0 && IsValidEdict(fireent) && IsValidEntity(fireent))
	{
		AcceptEntityInput(fireent, "kill");
	} 
	if(client>0 && IsClientInGame(client))
	{
		SDKUnhook(client, SDKHook_PreThink,  PreThinkClient); 
	}
}
CreateDecoration(client)
{
	if(IsWitch(WitchEnt[client]) )return;
	//PrintToChatAll("create decoration");
		
	new witch=CreateEntityByName("prop_dynamic_override"); 
	if(L4D2Version)
	{
		if(GetRandomInt(0,1)==0)DispatchKeyValue(witch, "model", Model_Witch2); 
		else DispatchKeyValue(witch, "model", Model_Witch);  
	}
	else DispatchKeyValue(witch, "model", Model_Witch);  
	DispatchSpawn(witch); 
	
	decl String:tname[60];
	Format(tname, sizeof(tname), "target%d", client);
	DispatchKeyValue(client, "targetname", tname); 		
	DispatchKeyValue(witch, "parentname", tname);
	
	SetVariantString(tname);
	AcceptEntityInput(witch, "SetParent",witch, witch, 0); 	
	SetVariantString("medkit"); 
	AcceptEntityInput(witch, "SetParentAttachment"); 
	
	new anim=0;
	if(GetConVarInt(l4d_witch_onback_bestpose)==0)anim=Anim[ GetRandomInt(0,AnimCount-1) ];
	else anim=best_amin;
	
	new Float:pos[3];
	new Float:ang[3];
	SetVector(pos, -5.0, 32.0, 0.0); 
	pos[0]=OffSets[anim][0];
	pos[1]=OffSets[anim][1]; 
	SetVector(ang, 0.0, 00.0, 90.0);
 	
	TeleportEntity(witch, pos, ang, NULL_VECTOR);
	SetEntityRenderMode(witch, RENDER_TRANSCOLOR);
	SetEntityRenderColor(witch, 255,0,0,255);
	SetEntProp(witch, Prop_Send, "m_CollisionGroup", 2);   


	SetEntProp(witch, Prop_Send, "m_nSequence", anim);
	SetEntPropFloat(witch, Prop_Send, "m_flPlaybackRate", 1.0);		
	
	WitchEnt[client]= witch ; 
 	if(GetConVarInt(l4d_witch_onback_bestpose)==0)CreateTimer(30.0, TimerAnimWitch, client, TIMER_FLAG_NO_MAPCHANGE| TIMER_REPEAT);
	SDKHook(WitchEnt[client], SDKHook_SetTransmit, Hook_SetTransmit);
	 
	 
	new ent=CreateEntityByName("env_weaponfire"); 
 
	new Float:eye[3];
	GetClientEyePosition(client, eye); 
	DispatchSpawn(ent);
	
	
	
	decl String:tName[128];
	Format(tName, sizeof(tName), "target%d",client );
	DispatchKeyValue(client , "targetname", tName);
	
	DispatchKeyValueFloat(ent, "targetarc", 360.0);
	DispatchKeyValueFloat(ent, "targetrange", GetConVarFloat(l4d_witch_guard_range));
	if(GetClientButtons(client) & IN_DUCK)DispatchKeyValue(ent, "weapontype", "1");
	else DispatchKeyValue(ent, "weapontype", "3");
	DispatchKeyValue(ent, "targetteam", "3");
	DispatchKeyValueFloat(ent, "damagemod", GetConVarFloat(l4d_witch_guard_damage));
	 	  
	if(true)
	{
		DispatchKeyValue(ent, "parentname", tName);
		SetVariantString(tName);
		AcceptEntityInput(ent, "SetParent", ent, ent, 0); 
		SetVariantString("eyes"); //muzzle_flash
		AcceptEntityInput(ent, "SetParentAttachment");
	}
	SetVector(eye, 0.0, 0.0, 15.0);
	TeleportEntity(ent, eye,NULL_VECTOR, NULL_VECTOR); 
	if(GetConVarInt(l4d_witch_guard_shotonback)==1)AcceptEntityInput(ent, "Enable" ); 
	else AcceptEntityInput(ent, "Disable" ); 
	WeaponFireEnt[client]=ent;
	
	PressTime[client]=GetEngineTime();
	LastTime[client]=GetEngineTime();
	SDKUnhook(client, SDKHook_PreThink,  PreThinkClient);  	
	SDKHook( client, SDKHook_PreThink,  PreThinkClient);   
	
}
CreateWitchGuard(client)
{ 
	new dummy = CreateEntityByName("molotov_projectile");	 
	SetEntityModel(dummy, "models/w_models/weapons/w_eq_pipebomb.mdl"); 
	DispatchSpawn(dummy);
	SetEntityRenderMode(dummy, RENDER_TRANSCOLOR);
	SetEntityRenderColor(dummy, 0, 0, 0, 0);
	SetEntityMoveType(dummy, MOVETYPE_NONE);
	SetEntProp(dummy, Prop_Data, "m_CollisionGroup", 2);  
	
	new anim=1;
	if(L4D2Version)anim=3;
	new Float:pos[3];
	new Float:ang[3];
	new Float:t[3];
	GetClientAbsOrigin(client, pos);
	GetClientEyeAngles(client, ang);
	ang[0]=0.0;
	GetAngleVectors(ang, t, NULL_VECTOR,NULL_VECTOR);
	NormalizeVector(t, t);
	ScaleVector(t, 20.0);
	AddVectors(pos, t, pos);
	
 	
	GetClientEyeAngles(client, t);
	t[0]=0.0;
	t[1]+=90.0;
	TeleportEntity(dummy, pos, ang, NULL_VECTOR);
	
	
	new witch=CreateEntityByName("prop_dynamic_override");  
	if(L4D2Version)
	{
		if(GetRandomInt(0,1)==0)DispatchKeyValue(witch, "model", Model_Witch2); 
		else DispatchKeyValue(witch, "model", Model_Witch);  
	}
	else DispatchKeyValue(witch, "model", Model_Witch);  
	DispatchSpawn(witch);     
	SetEntProp(witch, Prop_Send, "m_nSequence", anim);
	SetEntPropFloat(witch, Prop_Send, "m_flPlaybackRate", 1.0);	 
	
	DispatchKeyValueFloat(witch, "fademindist", 10000.0);
	DispatchKeyValueFloat(witch, "fademaxdist", 20000.0);
	DispatchKeyValueFloat(witch, "fadescale", 0.0); 
 
	SetEntityRenderMode(witch, RENDER_TRANSCOLOR);
	SetEntityRenderColor(witch, 255, 0, 0, 255);
 
	if(L4D2Version)
	{
		SetEntProp(witch, Prop_Send, "m_iGlowType", 3);
		SetEntProp(witch, Prop_Send, "m_nGlowRange", 0);
		SetEntProp(witch, Prop_Send, "m_nGlowRangeMin", 600);
		new red=0;
		new gree=151;
		new blue=0;
		SetEntProp(witch, Prop_Send, "m_glowColorOverride", red + (gree * 256) + (blue* 65536)); 
	}	
	//TeleportEntity(witch, Float:{0.0, 0.0, 0.0}, NULL_VECTOR, NULL_VECTOR);
	TeleportEntity(witch, pos, ang, NULL_VECTOR);
	decl String:tName[128];
	Format(tName, sizeof(tName), "target%d",dummy );
	DispatchKeyValue(dummy , "targetname", tName);	
	
	DispatchKeyValue(witch, "parentname", tName);
	SetVariantString(tName);
	AcceptEntityInput(witch, "SetParent", witch, witch, 0);  	
	
	
	new Float:pos2[3];
	new Float:front=0.0;
	new Float:up=35.0;
	new Float:side=25.0;
	new count=GetConVarInt(l4d_witch_guard_gun_count);
	if(count<1)count=1;
	if(count>21)count=21;
	for(new i=0; i<count; i++)
	{ 
		new ent=CreateEntityByName("env_weaponfire"); 
		DispatchSpawn(ent);  
		DispatchKeyValueFloat(ent, "targetarc", 360.0);
		DispatchKeyValueFloat(ent, "targetrange", GetConVarFloat(l4d_witch_guard_range));
		if(GetClientButtons(client) & IN_DUCK)DispatchKeyValue(ent, "weapontype", "1");
		else DispatchKeyValue(ent, "weapontype", "3");
		DispatchKeyValue(ent, "targetteam", "3");
		DispatchKeyValueFloat(ent, "damagemod", GetConVarFloat(l4d_witch_guard_damage));
		
		new Float:p[3];
		p[0]=p[1]=p[2]=0.0;
		
		/*
		if(i%3==0)CalcOffset(p, ang, 0.0,55.0, 0.0, pos2);
		else if(i%3==1)CalcOffset(p, ang, front, up, side, pos2);
		else if(i%3==2)CalcOffset(p, ang, front, up, 0.0-side, pos2);
		*/
		if(i%3==0)SetVector(pos2, 0.0,0.0, 55.0);
		else if(i%3==1)SetVector(pos2, front,  side,up);
		else if(i%3==2)SetVector(pos2, front, 0.0- side,up);	
		
		//pos2[0]+=GetRandomFloat(-2.0, 2.0);
		//pos2[1]+=GetRandomFloat(-2.0, 2.0);
		//pos2[2]+=GetRandomFloat(-2.0, 2.0);
		
		if(true)
		{

			DispatchKeyValue(ent, "parentname", tName);
			SetVariantString(tName);
			AcceptEntityInput(ent, "SetParent", ent, ent, 0);  
		}
		
		
		TeleportEntity(ent, pos2,NULL_VECTOR, NULL_VECTOR); 
		AcceptEntityInput(ent, "Enable" ); 
		
		WitchGaurdWeaponEnt[WitchGaurdCount][i]=ent;
	}
	CalcOffset(pos, ang, 0.0,50.0, 0.0, pos2);
	new b=CreateButton(pos2);
	WitchGaurdButton[WitchGaurdCount]=b;
	WitchGaurdEnt[WitchGaurdCount]=witch;
	WitchGaurdDummy[WitchGaurdCount]=dummy;
	WitchGaurdScanTime[WitchGaurdCount]=0.0;
	WitchGaurdCount++;  
	 
}
public OnGameFrame()
{
	return;
	for(new index=0; index<WitchGaurdCount; index++)
	{
		new dummy=WitchGaurdDummy[index];
		new Float:ang[3];
		GetEntPropVector(dummy, Prop_Send, "m_angRotation", ang);
		ang[1]+=10.0;
		TeleportEntity(dummy, NULL_VECTOR, ang,NULL_VECTOR);
	}
}
CreateButton(Float:pos[3] )
{ 
	decl String:sTemp[16];
	new button;
	new bool:type=false;
	if(type)button = CreateEntityByName("func_button");
	else button = CreateEntityByName("func_button_timed"); 
 
	DispatchKeyValue(button, "rendermode", "3");
 
	if(type )
	{
		DispatchKeyValue(button, "spawnflags", "1025");
		DispatchKeyValue(button, "wait", "1");
	}
	else
	{
		DispatchKeyValue(button, "spawnflags", "0");
		DispatchKeyValue(button, "auto_disable", "1");
		Format(sTemp, sizeof(sTemp), "%f", 1.5);
		DispatchKeyValue(button, "use_time", sTemp);
	}
	DispatchSpawn(button);
	AcceptEntityInput(button, "Enable");
	ActivateEntity(button);
 
	TeleportEntity(button, pos, NULL_VECTOR, NULL_VECTOR);

	SetEntProp(button, Prop_Send, "m_nSolidType", 0, 1);
	SetEntProp(button, Prop_Send, "m_usSolidFlags", 4, 2);

	new Float:vMins[3] = {-5.0, -5.0, -5.0}, Float:vMaxs[3] = {10.0, 10.0, 10.0};
	SetEntPropVector(button, Prop_Send, "m_vecMins", vMins);
	SetEntPropVector(button, Prop_Send, "m_vecMaxs", vMaxs);

	if( L4D2Version )
	{
		SetEntProp(button, Prop_Data, "m_CollisionGroup", 1);
		SetEntProp(button, Prop_Send, "m_CollisionGroup", 1);
	}
	if( type )
	{	
		HookSingleEntityOutput(button, "OnPressed", OnPressed);
	}
	else
	{
		SetVariantString("OnTimeUp !self:Enable::1:-1");
		AcceptEntityInput(button, "AddOutput");
		HookSingleEntityOutput(button, "OnTimeUp", OnPressed);
	}
	return button;
}
public OnPressed(const String:output[], caller, activator, Float:delay)
{ 
	
	if(activator>0 && activator<=MaxClients && IsClientInGame(activator) )
	{ 
		if(IsWitch(WitchEnt[activator]) )return;
		AcceptEntityInput(caller, "kill");  
		new find=-1;
		for(new i=0; i<WitchGaurdCount; i++)
		{
			if(WitchGaurdButton[i]==caller)
			{
				find=i;
				break;
			}
		}
		if(find==-1)return;
		for(new i=0 ; i<21; i++)
		{
			if(WitchGaurdWeaponEnt[find][i]>0)AcceptEntityInput(WitchGaurdWeaponEnt[find][i], "kill"); 
			WitchGaurdWeaponEnt[find][i]=0;
		}		
		AcceptEntityInput(WitchGaurdEnt[find], "kill"); 
		AcceptEntityInput(WitchGaurdDummy[find], "kill"); 

		for(new i=find; i<WitchGaurdCount; i++)
		{
			WitchGaurdEnt[i]=WitchGaurdEnt[i+1];
			WitchGaurdButton[i]=WitchGaurdButton[i+1];
			WitchGaurdDummy[i]=WitchGaurdDummy[i+1]; 
			WitchGaurdScanTime[i]=WitchGaurdScanTime[i+1];
			for(new j=0 ; j<21; j++)
			{
				WitchGaurdWeaponEnt[i][j]=WitchGaurdWeaponEnt[i+1][j];
			}
		}
		WitchGaurdCount--;
		CreateDecoration(activator);	
		PrintHintText(activator, "you put witch on back" ); 
	}
}
 
CalcOffset(Float:pos[3], Float:ang[3], Float:front, Float:up, Float:right, Float:ret[3])
{
	new Float:t[3];
	GetAngleVectors(ang, t, NULL_VECTOR, NULL_VECTOR);
	NormalizeVector(t, t);
	ScaleVector(t, front);
	AddVectors(pos, t, ret);
	
	GetAngleVectors(ang, NULL_VECTOR,t, NULL_VECTOR);
	NormalizeVector(t, t);
	ScaleVector(t, right);
	AddVectors(ret, t, ret);	
	
	GetAngleVectors(ang, NULL_VECTOR,NULL_VECTOR, t);
	NormalizeVector(t, t);
	ScaleVector(t, up);
	AddVectors(ret, t, ret);		
}

public PreThinkClient(client)
{
	if(WitchEnt[client]==0)return;
	new button=GetClientButtons(client); 
	
	if(button & IN_USE)
	{
		if(GetEngineTime()-PressTime[client]>1.0)
		{
			if(!(GetEntityFlags(client) & FL_ONGROUND))return;	 
			DeleteDecoration(client);
			CreateWitchGuard(client);
			PrintHintText(client, "you put witch down" ); 
		}
	}
	else
	{
		PressTime[client]=GetEngineTime(); 
	}
	
}
public Action:TimerAnimWitch(Handle:timer, any:client)
{
	if( IsWitch(WitchEnt[client]) )
	{
		if(client>0 && IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client)==2)
		{
			new anim=Anim[ GetRandomInt(0,AnimCount-1) ]; 
			
			new Float:ang[3]; 
			SetVector(ang, 0.0, 0.0, 90.0);
			new Float:pos[3];
			pos[0]=OffSets[anim][0];
			pos[1]=OffSets[anim][1];
			
			TeleportEntity(WitchEnt[client], pos, ang, NULL_VECTOR);		
			
			SetEntProp(WitchEnt[client], Prop_Send, "m_nSequence", anim);
			SetEntPropFloat(WitchEnt[client], Prop_Send, "m_flPlaybackRate", 1.0);		 
			
			return Plugin_Continue;
		}
		else
		{
			DeleteDecoration(client);
		}
	}
	WitchEnt[client]=0;
	return Plugin_Stop;
}
public Action:Hook_SetTransmit(entity, client)
{ 
	if(entity==WitchEnt[client])
	{
		if(WitchViewOn[client])return Plugin_Continue;
		else return Plugin_Handled;
	}
	return Plugin_Continue;
}
SetVector(Float:target[3], Float:x, Float:y, Float:z)
{
	target[0]=x;
	target[1]=y;
	target[2]=z;
}