/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdkhooks>
#include <sdktools>
#include <sdktools_functions>
 
#define Model_Tank "models/infected/hulk.mdl"
#define Model_Tank_dlc3 "models/infected/hulk_dlc3.mdl"
new String:Tank_Model[100];
#define SOUNDMISSILELOCK "UI/Beep07.wav" 

#define FilterSelf 0
#define FilterSelfAndPlayer 1
#define FilterSelfAndSurvivor 2
#define FilterSelfAndInfected 3
#define FilterSelfAndPlayerAndCI 4

#define SurvivorTeam 2
#define InfectedTeam 3
#define MissileTeam 1 

#define State_None 0
#define State_Start 1
#define State_Fly 2
 
#define ZOMBIECLASS_SMOKER	1
#define ZOMBIECLASS_BOOMER	2
#define ZOMBIECLASS_HUNTER	3
#define ZOMBIECLASS_SPITTER	4
#define ZOMBIECLASS_JOCKEY	5
#define ZOMBIECLASS_CHARGER	6

new ZOMBIECLASS_TANK=	5;
 
new JetPack[MAXPLAYERS+1][2];
new ClientState[MAXPLAYERS+1];
new Float:ClientVelocity[MAXPLAYERS+1][3];
new Float:LastTime[MAXPLAYERS+1]; 
new Float:LastPos[MAXPLAYERS+1][3]; 
new Float:FireTime[MAXPLAYERS+1]; 
new LastButton[MAXPLAYERS+1];
new Float:StartTime[MAXPLAYERS+1];
new Float:ScanTime[MAXPLAYERS+1];
new Enemy[MAXPLAYERS+1];
new Clone[MAXPLAYERS+1];
new GameMode;
new g_sprite;
new g_iVelocity;
new bool:L4D2Version;
public Plugin:myinfo = 
{
	name = "Fly Infected",
	author = "Pan Xiaohai",
	description = " ",
	version = "1.5",
	url = "<- URL ->"
}

new Handle:l4d_flyinfected_enable ; 
new Handle:l4d_flyinfected_chance_throw;
new Handle:l4d_flyinfected_chance_tankclaw;
new Handle:l4d_flyinfected_chance_tankjump;
new Handle:l4d_flyinfected_speed; 
new Handle:l4d_flyinfected_maxtime; 
 
public OnPluginStart()
{
	GameCheck();
  	l4d_flyinfected_enable = CreateConVar("l4d_flyinfected_enable", "1", "  0:disable, 1:enable in coop mode, 2: enable in all mode ", FCVAR_PLUGIN);
 
	l4d_flyinfected_chance_throw = 	CreateConVar("l4d_flyinfected_chance_throw", "30.0", "fly when tank throw rock [0.0, 100.0]");	
 	l4d_flyinfected_chance_tankclaw = 	CreateConVar("l4d_flyinfected_chance_tankclaw", "10", "fly when tank claw [0.0, 100.0]");	
 	l4d_flyinfected_chance_tankjump = 	CreateConVar("l4d_flyinfected_chance_tankjump", "20", "fly when tank jump [0.0, 100.0]");	
  
 
	l4d_flyinfected_speed = 	CreateConVar("l4d_flyinfected_speed", "300", "fly speed");	
 	l4d_flyinfected_maxtime = 	CreateConVar("l4d_flyinfected_maxtime", "10", "max fly time");	
	
	g_iVelocity = FindSendPropOffs("CBasePlayer", "m_vecVelocity[0]");
	
	AutoExecConfig(true, "l4d_fly_infected"); 
 
	HookEvent("round_start", RoundStart);
	HookEvent("round_end", RoundStart);
	HookEvent("finale_win", RoundStart);
	HookEvent("mission_lost", RoundStart);
	HookEvent("map_transition", RoundStart);	
 
	HookEvent("ability_use", ability_use);
	HookEvent("weapon_fire", weapon_fire);
	HookEvent("player_jump", player_jump);
	
	HookEvent("player_hurt", player_hurt);
	HookEvent("player_death", player_death);
	
 	SetRandomSeed(GetSysTickCount());
	Reset(); 
}
 
Reset()
{
	for(new i=1; i<=MaxClients; i++)
	{
		ClientState[i]=State_None;
		FireTime[i]=0.0;
		JetPack[i][0]=JetPack[i][1]=0;
		Clone[i]=0;
		SDKUnhook(i, SDKHook_PreThink,  PreThink); 
		SDKUnhook(i, SDKHook_StartTouch , FlyTouch);
	}
}
public Action:RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	Reset(); 
}
bool:CanUse()
{
	new mode=GetConVarInt(l4d_flyinfected_enable);
	if(mode==0)return false;
	if(mode==1 && GameMode==2)return false;
	return true;
}
public Action:weapon_fire(Handle:event, const String:name[], bool:dontBroadcast)
{
 
	if(!CanUse())return;
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if(client>0)
	{
		if(GetClientTeam(client)==3 && IsInfected(client, ZOMBIECLASS_TANK))
		{   
			new Float:time=GetEngineTime();
			if(FireTime[client]+1.0<time)
			{
				FireTime[client]=time;
			}
			else return;
			//PrintToChatAll("---------Fire------------");
			if(ClientState[client]==State_None)
			{
				new Float:r=GetRandomFloat(0.0, 100.0); 
				if(r<GetConVarFloat(l4d_flyinfected_chance_tankclaw))
				{ 
					//PrintToChatAll("Start by Tank Fire");
					ClientState[client]=State_Start;
					CreateTimer(3.0, StartTimer, client, TIMER_FLAG_NO_MAPCHANGE);
				}
			}
			else if(ClientState[client]==State_Fly)
			{
				 
				//StopFly(client);
			}
		}
	}
	return ;
}
public Action:player_hurt(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(!CanUse())return;
 	new  attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	if(attacker>0 && ClientState[attacker]==State_Fly)
	{
		decl String:s[32];	
		GetEventString(event, "weapon", s, 32);
		//PrintToChatAll("weapon %s", s);	
	 	if(StrEqual(s, "tank_claw", true))
		{
			//PrintToChatAll("Stop by Hurt");
			StopFly(attacker);
		}
	}
	return;
}
public Action:player_jump(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	if(!CanUse())return;
	new client = GetClientOfUserId(GetEventInt(hEvent, "userid"));  
	
	if(client>0 && GetClientTeam(client)==3 && IsInfected(client, ZOMBIECLASS_TANK) && ClientState[client]==State_None)
	{ 	
		new Float:r=GetRandomFloat(0.0, 100.0); 
		if(r<GetConVarFloat(l4d_flyinfected_chance_tankjump))
		{ 
			//PrintToChatAll("Start by Jump");
			ClientState[client]=State_Start;
			StartTimer(INVALID_HANDLE, client);
		}
	}
}
public Action:player_death(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	if(!CanUse())return;
	new victim = GetClientOfUserId(GetEventInt(hEvent, "userid"));  

	if(victim>0 && ClientState[victim]==State_Fly)
	{ 	
		StopFly(victim); 
	}
}

public Action:ability_use(Handle:event, const String:name[], bool:dontBroadcast)
{	
	if(!CanUse())return;
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if(ClientState[client]==State_None) 
	{
		decl String:s[32];	
		GetEventString(event, "ability", s, 32);
		if(StrEqual(s, "ability_throw", true))
		{	 
			new Float:r=GetRandomFloat(0.0, 100.0); 
			if(r<GetConVarFloat(l4d_flyinfected_chance_throw))
			{ 
				//PrintToChatAll("Start by Throw");
				ClientState[client]=State_Start;
				CreateTimer(3.0, StartTimer, client, TIMER_FLAG_NO_MAPCHANGE);
			}

		}
	}
	
} 

public Action:StartTimer(Handle:timer, any:client)
{ 
	if(client>0 && ClientState[client]!=State_Fly && IsClientInGame(client) && IsPlayerAlive(client) && IsInfected(client, ZOMBIECLASS_TANK) )
	{ 
		StartFly(client); 	 
	}
	if(ClientState[client]!=State_Fly) ClientState[client]=State_None;
}
StartFly(client)
{   
	if(ClientState[client]==State_Fly)StopFly(client);
	ClientState[client]=State_None;

	new Float:pos[3];
	new Float:hitpos[3];
	new Float:ang[3];
	ang[0]=-89.0;
	GetClientEyePosition(client, pos);
	new Handle:trace=TR_TraceRayFilterEx(pos, ang, MASK_ALL, RayType_Infinite, DontHitSelf,client);
	new bool:narrow=false;
 
	if(TR_DidHit(trace))
	{
		TR_GetEndPosition(hitpos, trace); 
		if(GetVectorDistance(hitpos, pos)<100.0)
		{ 
			narrow=true;
			PrintCenterText(client, "It is too narrow");
		}
	}
 	CloseHandle(trace);
	if(narrow)return; 
	ClientState[client]=State_Fly;
	new Float:vec[3];
	GetEntPropVector(client, Prop_Send, "m_vecOrigin", pos);
	pos[2]+=5.0;
	GetClientEyeAngles(client,vec);
	GetAngleVectors(vec, vec, NULL_VECTOR, NULL_VECTOR);
	NormalizeVector(vec , vec);
	ScaleVector(vec, 55.0);
	vec[2]=30.0; 
	TeleportEntity(client, pos, NULL_VECTOR, vec);
	CopyVector(pos, LastPos[client]);
	CopyVector(vec, ClientVelocity[client]);
	
	LastTime[client]=GetEngineTime()-0.01;
	StartTime[client]=GetEngineTime();
	ScanTime[client]=GetEngineTime()-0.0;
	LastButton[client]=IN_JUMP;
	Enemy[client]=0;
	
	SDKUnhook(client, SDKHook_PreThink,  PreThink);
	SDKHook( client, SDKHook_PreThink,  PreThink);  
	SDKUnhook(client, SDKHook_StartTouch , FlyTouch);
	SDKHook(client, SDKHook_StartTouch , FlyTouch);
 	
	if(true)
	{
		Clone[client]=0;
		new jetpackb1=CreateJetPackB1(client);
		new jetpackb2=CreateJetPackB2(client);  
		JetPack[client][0]=jetpackb1;
		JetPack[client][1]=jetpackb2; 
		AttachFlame(client, jetpackb1 );
		AttachFlame(client, jetpackb2 );	
		if(L4D2Version)
		{
			SetEntProp(client, Prop_Send, "m_iGlowType", 3 ); //3
			SetEntProp(client, Prop_Send, "m_nGlowRange", 0 ); //0
			SetEntProp(client, Prop_Send, "m_glowColorOverride", 256*100); //1	
		}
		
	} 
}
VisiblePlayer(client, bool:visible=true)
{
	if(visible)
	{
		SetEntityRenderMode(client, RENDER_NORMAL);
		SetEntityRenderColor(client, 255, 255, 255, 255);		 
	}
    else
	{
		SetEntityRenderMode(client, RENDER_TRANSCOLOR);
		SetEntityRenderColor(client, 0, 0, 0, 0);
	} 
}
StopFly(client)
{  
	if(ClientState[client]!=State_Fly)return;
	
	ClientState[client]=State_None;
	SDKUnhook(client, SDKHook_PreThink,  PreThink); 
	SDKUnhook(client, SDKHook_StartTouch , FlyTouch);
	new jet0=JetPack[client][0];
	new jet1=JetPack[client][1];
	new clone=Clone[client];
	Clone[client]=JetPack[client][0]=JetPack[client][1]=0;	
	
	if(client>0 && IsClientInGame(client) && IsPlayerAlive(client) && IsInfected(client, ZOMBIECLASS_TANK))
	{
		SetEntityGravity(client, 1.0);
		VisiblePlayer(client, true);
		if(L4D2Version)
		{
			SetEntProp(client, Prop_Send, "m_iGlowType", 0 ); //3
			SetEntProp(client, Prop_Send, "m_nGlowRange", 0 ); //0
			SetEntProp(client, Prop_Send, "m_glowColorOverride", 0); //1	
		}
	}

	if(jet0>0 && IsValidEdict(jet0) && IsValidEntity(jet0) )  // remove dummy body
	{
		AcceptEntityInput(jet0, "ClearParent");
		AcceptEntityInput(jet0, "kill"); 
	}
	if(jet1>0 && IsValidEdict(jet1) && IsValidEntity(jet1) )  // remove dummy body
	{
		AcceptEntityInput(jet1, "ClearParent");
		AcceptEntityInput(jet1, "kill"); 
	}	 
	if(clone>0 && IsValidEdict(clone) && IsValidEntity(clone) )  // remove dummy body
	{
		AcceptEntityInput(clone, "ClearParent");
		AcceptEntityInput(clone, "kill"); 
	}
	
}
IsInfected(client, type)
{
	new class = GetEntProp(client, Prop_Send, "m_zombieClass");
	if(type==class)return true;
	else return false;
}
 
public FlyTouch(ent, other)
{  
 
	StopFly(ent); 
}
public PreThink(client)
{
	if(client>0 && IsClientInGame(client) && IsPlayerAlive(client))
	{ 
		new Float:time=GetEngineTime( );
		new Float:intervual=time-LastTime[client]; 
		new button=GetClientButtons(client);  
		TraceFly(client, button, time, intervual );  
		LastTime[client]=time; 
		LastButton[client]=button;	 
		 
	}
	else
	{
		SDKUnhook(client, SDKHook_PreThink,  PreThink);
	}

}
 
 
TraceFly(ent, button, Float:time,  Float:duration)
{   
 
	if(time-StartTime[ent]>GetConVarFloat(l4d_flyinfected_maxtime))
	{ 
		 
		StopFly(ent);
		return;
	}
	 
	decl Float:posmissile[3]; 
	decl Float:velocitymissile[3];	
	
	GetClientAbsOrigin(ent, posmissile); 
	posmissile[2]+=30.0;
	GetEntDataVector(ent, g_iVelocity, velocitymissile);
	new bool:fake=IsFakeClient(ent);
	if(!fake && (button & IN_JUMP) && !(LastButton[ent] & IN_JUMP))
	{
	 
	 
		GetClientEyeAngles(ent, velocitymissile);
		GetAngleVectors(velocitymissile, velocitymissile, NULL_VECTOR, NULL_VECTOR);
		velocitymissile[2]=0.0;
		NormalizeVector(velocitymissile, velocitymissile);
		ScaleVector(velocitymissile, 310.0);
		velocitymissile[2]=150.0;
		TeleportEntity(ent, NULL_VECTOR,NULL_VECTOR, velocitymissile);
		StopFly(ent);
		return;
	}
	CopyVector(ClientVelocity[ent], velocitymissile);	
	if(GetVectorLength(velocitymissile)<10.0)return ;
	NormalizeVector(velocitymissile, velocitymissile);

	
	//ShowDir(0, posmissile, velocitymissile, 0.06);
 	
	new myteam=3; 
	new enemyteam=2;
	
 	new enemy=Enemy[ent];
	if(ScanTime[ent]+1.0<=time)
	{
		ScanTime[ent]=time;
		if(fake)enemy=GetEnemy(posmissile, velocitymissile, enemyteam);
		else 
		{
			new Float:lookdir[3];
			GetClientEyeAngles(ent, lookdir);
			GetAngleVectors(lookdir, lookdir, NULL_VECTOR, NULL_VECTOR); 
			NormalizeVector(lookdir, lookdir);
			//ScaleVector(lookdir, 310.0);
			enemy=GetEnemy(posmissile, lookdir, enemyteam);
		}
		//PrintToChatAll("scan %f %N", time, enemy);
	}
	if(enemy>0 && IsClientInGame(enemy) && IsPlayerAlive(enemy))
	{
		Enemy[ent]=enemy;
	}
	else
	{
		enemy=0;
		Enemy[ent]=enemy;
	}
	
	decl Float:velocityenemy[3];
	decl Float:vtrace[3];
	
	vtrace[0]=vtrace[1]=vtrace[2]=0.0;	
	new bool:visible=false;
	decl Float:missionangle[3];
 
	new Float:disenemy=1000.0;
	new Float:disobstacle=1000.0;
 
 
	if(enemy>0)	
	{
		decl Float:posenemy[3];
		GetClientEyePosition(enemy, posenemy);
		
		disenemy=GetVectorDistance(posmissile, posenemy);
		 
		visible=IfTwoPosVisible(posmissile, posenemy, ent);
			
		//if(visible)PrintToChatAll("%N visible %f ", client, disenemy);	
		GetEntDataVector(enemy, g_iVelocity, velocityenemy);
 
		ScaleVector(velocityenemy, duration);

		AddVectors(posenemy, velocityenemy, posenemy);
		MakeVectorFromPoints(posmissile, posenemy, vtrace);
		//PrintToChatAll("%N lock %N D:%f", client,enemy, disenemy); 
		
		if(false)
		{
			if(enemy>0 && IsClientInGame(enemy) && IsPlayerAlive(enemy))
			{
				PrintHintText(enemy, "Warning! Your are locked by flying tank, Distance: %d", RoundFloat(disenemy) );
				EmitSoundToClient(enemy, SOUNDMISSILELOCK);
			} 
		} 
	 
	} 
	
	////////////////////////////////////////////////////////////////////////////////////
	GetVectorAngles(velocitymissile, missionangle);
 
	decl Float:vleft[3];
	decl Float:vright[3];
	decl Float:vup[3];
	decl Float:vdown[3];
	decl Float:vfront[3];
	decl Float:vv1[3];
	decl Float:vv2[3];
	decl Float:vv3[3];
	decl Float:vv4[3];
	decl Float:vv5[3];
	decl Float:vv6[3];
	decl Float:vv7[3];
	decl Float:vv8[3];	
	
	vfront[0]=vfront[1]=vfront[2]=0.0;	
	 
	new Float:factor2=0.5; 
	new Float:factor1=0.2; 
	new Float:t;
	new Float:base=1500.0;
	if(visible)
	{
		base=80.0;
 
	}
	{
		//PrintToChatAll("%f %f %f %f %f",front, up, down, left, right);
		new flag=FilterSelfAndSurvivor;
		new bool:print=false;
		new self=ent;
		new Float:front=CalRay(posmissile, missionangle, 0.0, 0.0, vfront, self, print, flag);
		print=false;
		disobstacle=CalRay(posmissile, missionangle, 0.0, 0.0, vfront, self, print, FilterSelf);
		 
		new Float:down=CalRay(posmissile, missionangle, 90.0, 0.0, vdown, self, print,  flag);
		new Float:up=CalRay(posmissile, missionangle, -90.0, 0.0, vup, self, print);
		new Float:left=CalRay(posmissile, missionangle, 0.0, 90.0, vleft, self, print, flag);
		new Float:right=CalRay(posmissile, missionangle, 0.0, -90.0, vright, self, print, flag);
		
		new Float:f1=CalRay(posmissile, missionangle, 30.0, 0.0, vv1, self, print, flag);
		new Float:f2=CalRay(posmissile, missionangle, 30.0, 45.0, vv2, self, print, flag);
		new Float:f3=CalRay(posmissile, missionangle, 0.0, 45.0, vv3, self, print, flag);
		new Float:f4=CalRay(posmissile, missionangle, -30.0, 45.0, vv4, self, print, flag);
		new Float:f5=CalRay(posmissile, missionangle, -30.0, 0.0, vv5, self, print,flag);
		new Float:f6=CalRay(posmissile, missionangle, -30.0, -45.0, vv6, self, print, flag);	
		new Float:f7=CalRay(posmissile, missionangle, 0.0, -45.0, vv7, self, print, flag);
		new Float:f8=CalRay(posmissile, missionangle, 30.0, -45.0, vv8, self, print, flag);					
		  
		NormalizeVector(vfront,vfront);
		NormalizeVector(vup,vup);
		NormalizeVector(vdown,vdown);
		NormalizeVector(vleft,vleft);
		NormalizeVector(vright,vright);
		NormalizeVector(vtrace, vtrace);

		NormalizeVector(vv1,vv1);
		NormalizeVector(vv2,vv2);
		NormalizeVector(vv3,vv3);
		NormalizeVector(vv4,vv4);
		NormalizeVector(vv5,vv5);
		NormalizeVector(vv6,vv6);
		NormalizeVector(vv7,vv7);
		NormalizeVector(vv8,vv8);
		 
		
		if(front>base) front=base;
		if(up>base) up=base;
		if(down>base) down=base;
		if(left>base) left=base;
		if(right>base) right=base;
		  
		if(f1>base) f1=base;	
		if(f2>base) f2=base;	
		if(f3>base) f3=base;	
		if(f4>base) f4=base;	
		if(f5>base) f5=base;	
		if(f6>base) f6=base;	
		if(f7>base) f7=base;	
		if(f8>base) f8=base;	
		
		new Float:b2=10.0;
		if(front<b2) front=b2;
		if(up<b2) up=b2;
		if(down<b2) down=b2;
		if(left<b2) left=b2;
		if(right<b2) right=b2;
		  
		if(f1<b2) f1=b2;	
		if(f2<b2) f2=b2;	
		if(f3<b2) f3=b2;	
		if(f4<b2) f4=b2;	
		if(f5<b2) f5=b2;	
		if(f6<b2) f6=b2;	
		if(f7<b2) f7=b2;	
		if(f8<b2) f8=b2;		
 
		t=-1.0*factor1*(base-front)/base;
		ScaleVector( vfront, t);
		
		t=-1.0*factor1*(base-up)/base;
		ScaleVector( vup, t);
		
		t=-1.0*factor1*(base-down)/base;
		ScaleVector( vdown, t);
		
		t=-1.0*factor1*(base-left)/base;
		ScaleVector( vleft, t);
		
		t=-1.0*factor1*(base-right)/base;
		ScaleVector( vright, t);
		
		t=-1.0*factor1*(base-f1)/f1;
		ScaleVector( vv1, t);
		
		t=-1.0*factor1*(base-f2)/f2;
		ScaleVector( vv2, t);
		
		t=-1.0*factor1*(base-f3)/f3;
		ScaleVector( vv3, t);
		
		t=-1.0*factor1*(base-f4)/f4;
		ScaleVector( vv4, t);
		
		t=-1.0*factor1*(base-f5)/f5;
		ScaleVector( vv5, t);
		
		t=-1.0*factor1*(base-f6)/f6;
		ScaleVector( vv6, t);
		
		t=-1.0*factor1*(base-f7)/f7;
		ScaleVector( vv7, t);
		
		t=-1.0*factor1*(base-f8)/f8;
		ScaleVector( vv8, t);
	 	
		if(disenemy>=500.0)disenemy=500.0;
		t=1.0*factor2*(1000.0-disenemy)/500.0;
		ScaleVector( vtrace, t);							

		AddVectors(vfront, vup, vfront);
		AddVectors(vfront, vdown, vfront);
		AddVectors(vfront, vleft, vfront);
		AddVectors(vfront, vright, vfront);


		AddVectors(vfront, vv1, vfront);
		AddVectors(vfront, vv2, vfront);
		AddVectors(vfront, vv3, vfront);
		AddVectors(vfront, vv4, vfront);
		AddVectors(vfront, vv5, vfront);
		AddVectors(vfront, vv6, vfront);
		AddVectors(vfront, vv7, vfront);
		AddVectors(vfront, vv8, vfront);

		
		AddVectors(vfront, vtrace, vfront);	
		NormalizeVector(vfront, vfront);
	}
	
	new Float:a=GetAngle(vfront, velocitymissile);			 
	new Float:amax=3.14159*duration*2.0;
	 
	if(a> amax )a=amax ;
	
	ScaleVector(vfront ,a);
	
	//PrintToChat(client, "max %f %f  ",amax , a);
	decl Float:newvelocitymissile[3];
	AddVectors(velocitymissile, vfront, newvelocitymissile);
	
	new Float:speed=GetConVarFloat(l4d_flyinfected_speed);
	if(speed<60.0)speed=60.0;
	NormalizeVector(newvelocitymissile, newvelocitymissile);
	ScaleVector(newvelocitymissile,speed);   
	
	SetEntityGravity(ent, 0.01);
	 
	TeleportEntity(ent, NULL_VECTOR,  NULL_VECTOR ,newvelocitymissile); 
	CopyVector(newvelocitymissile, ClientVelocity[ent]);
 	//ShowDir(0, posmissile, newvelocitymissile, 0.06); 
}
PrintVector(Float:target[3], String:s[]="")
{
	PrintToChatAll("%s - %f %f %f", s, target[0], target[1], target[2]); 
}
GetEnemy(Float:pos[3], Float:vec[3], enemyteam)
{
	new Float:min=4.0;
	decl Float:pos2[3];
	new Float:t;
	new s=0;
	
	for(new client = 1; client <= MaxClients; client++)
	{
		new bool:playerok=IsClientInGame(client) && GetClientTeam(client)==enemyteam && IsPlayerAlive(client);
		 
		if(playerok )
		{
 
			GetClientEyePosition(client, pos2);
			MakeVectorFromPoints(pos, pos2, pos2);
			t=GetAngle(vec, pos2);
			//PrintToChatAll("%N %f", client, 360.0*t/3.1415926/2.0);
			if(t<=min)
			{
				min=t;
				s=client;
			}
			 
		}
	}
	return s;
}
CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
	target[1]=source[1];
	target[2]=source[2];
}
SetVector(Float:target[3], Float:x, Float:y, Float:z)
{
	target[0]=x;
	target[1]=y;
	target[2]=z;
}
bool:IfTwoPosVisible(Float:pos1[3], Float:pos2[3], self )
{
	new bool:r=true;
	new Handle:trace ;
	trace=TR_TraceRayFilterEx(pos2, pos1, MASK_SOLID, RayType_EndPoint, DontHitSelfAndSurvivor,self);
	if(TR_DidHit(trace))
	{
		r=false;
	}
 	CloseHandle(trace);
	return r;
}
Float:CalRay(Float:posmissile[3], Float:angle[3], Float:offset1, Float:offset2,   Float:force[3], ent, bool:printlaser=true, flag=FilterSelf) 
{

	decl Float:ang[3];
	CopyVector(angle, ang);
	ang[0]+=offset1;
	ang[1]+=offset2;
	GetAngleVectors(ang, force, NULL_VECTOR,NULL_VECTOR);
	new Float:dis=GetRayDistance(posmissile, ang, ent, flag) ; 
	//PrintToChatAll("%f %f, %f", dis, offset1, offset2);
	return dis;
}
Float:GetAngle(Float:x1[3], Float:x2[3])
{
	return ArcCosine(GetVectorDotProduct(x1, x2)/(GetVectorLength(x1)*GetVectorLength(x2)));
}
public bool:DontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	return true;
}
public bool:DontHitSelfAndPlayer(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity))
		{
			return false;
		}
	}
	return true;
}
public bool:DontHitSelfAndPlayerAndCI(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity))
		{
			return false;
		}
	}
	else
	{
		if(IsValidEntity(entity) && IsValidEdict(entity))
		{
			decl String:edictname[128];
			GetEdictClassname(entity, edictname, 128);
			if(StrContains(edictname, "infected")>=0)
			{
				return false;
			}
		}
	}
	return true;
}
public bool:DontHitSelfAndMissile(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity > MaxClients)
	{
		if(IsValidEntity(entity) && IsValidEdict(entity))
		{
			decl String:edictname[128];
			GetEdictClassname(entity, edictname, 128);
			if(StrContains(edictname, "prop_dynamic")>=0)
			{
				return false;
			}
		}
		
	}
	return true;
}
public bool:DontHitSelfAndSurvivor(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==2)
		{
			return false;
		}
	}
	return true;
}
public bool:DontHitSelfAndInfected(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==3)
		{
			return false;
		}
	}
	return true;
}
Float:GetRayDistance(Float:pos[3], Float: angle[3], self, flag)
{
	decl Float:hitpos[3];
	GetRayHitPos(pos, angle, hitpos, self, flag);
	return GetVectorDistance( pos,  hitpos);
}

GetRayHitPos(Float:pos[3], Float: angle[3], Float:hitpos[3], self, flag)
{
	new Handle:trace ;
	new hit=0;
	if(flag==FilterSelf)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelf, self);
	}
	else if(flag==FilterSelfAndPlayer)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelfAndPlayer, self);
	}
	else if(flag==FilterSelfAndSurvivor)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelfAndSurvivor, self);
	}
	else if(flag==FilterSelfAndInfected)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelfAndInfected, self);
	}
	else if(flag==FilterSelfAndPlayerAndCI)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelfAndPlayerAndCI, self);
	}
	if(TR_DidHit(trace))
	{
			
		TR_GetEndPosition(hitpos, trace);
		hit=TR_GetEntityIndex( trace);
			
	}
	CloseHandle(trace);
	return hit;
}
ShowLaser(colortype,Float:pos1[3], Float:pos2[3], Float:life=10.0,  Float:width1=1.0, Float:width2=11.0)
{
	decl color[4];
	if(colortype==1)
	{
		color[0] = 200; 
		color[1] = 0;
		color[2] = 0;
		color[3] = 230; 
	}
	else if(colortype==2)
	{
		color[0] = 0; 
		color[1] = 200;
		color[2] = 0;
		color[3] = 230; 
	}
	else if(colortype==3)
	{
		color[0] = 0; 
		color[1] = 0;
		color[2] = 200;
		color[3] = 230; 
	}
	else 
	{
		color[0] = 200; 
		color[1] = 200;
		color[2] = 200;
		color[3] = 230; 		
	}

	
	TE_SetupBeamPoints(pos1, pos2, g_sprite, 0, 0, 0, life, width1, width2, 1, 0.0, color, 0);
	TE_SendToAll();
}
//draw line between pos1 and pos2
ShowPos(color, Float:pos1[3], Float:pos2[3],Float:life=10.0, Float:length=200.0, Float:width1=1.0, Float:width2=11.0)
{
	decl Float:t[3];
	if(length!=0.0)
	{
		SubtractVectors(pos2, pos1, t);	 
		NormalizeVector(t,t);
		ScaleVector(t, length);
		AddVectors(pos1, t,t);
	}
	else 
	{
		CopyVector(pos2,t);
	}
	ShowLaser(color,pos1, t, life,   width1, width2);
}
//draw line start from pos, the line's drection is dir.
ShowDir(color,Float:pos[3], Float:dir[3],Float:life=10.0, Float:length=200.0, Float:width1=1.0, Float:width2=11.0)
{
	decl Float:pos2[3];
	CopyVector(dir, pos2);
	NormalizeVector(pos2,pos2);
	ScaleVector(pos2, length);
	AddVectors(pos, pos2,pos2);
	ShowLaser(color,pos, pos2, life,   width1, width2);
}
//draw line start from pos, the line's angle is angle.
ShowAngle(color,Float:pos[3], Float:angle[3],Float:life=10.0, Float:length=200.0, Float:width1=1.0, Float:width2=11.0)
{
	decl Float:pos2[3];
	GetAngleVectors(angle, pos2, NULL_VECTOR, NULL_VECTOR);
 
	NormalizeVector(pos2,pos2);
	ScaleVector(pos2, length);
	AddVectors(pos, pos2,pos2);
	ShowLaser(color,pos, pos2, life, width1, width2);
}
GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		L4D2Version=true;
		ZOMBIECLASS_TANK=8;
	}	
	else
	{
		L4D2Version=false;
		ZOMBIECLASS_TANK=5;
	}
}

public OnMapStart()
{
 	//PrecacheModel(Model_Tank);
	//PrecacheModel(Model_Tank_dlc3);
	PrecacheSound(SOUNDMISSILELOCK, true);	
	if(L4D2Version)
	{
		g_sprite = PrecacheModel("materials/sprites/laserbeam.vmt");	
	 
	}
	else
	{
		g_sprite = PrecacheModel("materials/sprites/laser.vmt");	
		 	
	} 
}
CreateJetPackB1(client)
{
	new Float:pos[3];
	new Float:ang[3];
	GetClientEyePosition(client, pos);
	GetClientAbsAngles(client, ang);
	new jetpack=CreateEntityByName("prop_dynamic_override"); 
	DispatchKeyValue(jetpack, "model", "models/props_equipment/oxygentank01.mdl");  
	DispatchSpawn(jetpack); 
	SetEntProp(jetpack, Prop_Data, "m_takedamage", 0, 1);  
	SetEntityMoveType(jetpack, MOVETYPE_NOCLIP);    
	SetEntProp(jetpack, Prop_Data, "m_CollisionGroup", 2); 
	if(GetClientTeam(client)==2)AttachJetPack(jetpack, client, 0); 	
	else AttachJetPack(jetpack, client, 1); 	
	decl Float:ang3[3];
	SetVector(ang3, 0.0, 0.0, 1.0); 
	GetVectorAngles(ang3, ang3); 
	CopyVector(ang,ang3);
	if( GetClientTeam(client)==2)
	{
		ang3[2]+=270.0; 
		ang3[1]-=10.0; 
		SetVector(pos,  0.0,  -5.0,  4.0);
	}
	else
	{
		ang3[2]+=90.0; 
		SetVector(pos,  0.0,  30.0,  -8.0);
	}
	DispatchKeyValueVector(jetpack, "origin", pos);  
	DispatchKeyValueVector(jetpack, "Angles", ang3); 
	TeleportEntity(jetpack, pos, NULL_VECTOR, ang3); 	
 
	
	if(L4D2Version)
	{
		SetEntProp(jetpack, Prop_Send, "m_iGlowType", 3 ); //3
		SetEntProp(jetpack, Prop_Send, "m_nGlowRange", 0 ); //0
		SetEntProp(jetpack, Prop_Send, "m_glowColorOverride", 1); //1	
	}	
	return 	jetpack;
}
CreateJetPackB2(client )
{
	new Float:pos[3];
	new Float:ang[3];
	GetClientEyePosition(client, pos);
	GetClientAbsAngles(client, ang);
	new jetpack=CreateEntityByName("prop_dynamic_override"); 
	DispatchKeyValue(jetpack, "model", "models/props_equipment/oxygentank01.mdl");  
	DispatchSpawn(jetpack); 
	SetEntProp(jetpack, Prop_Data, "m_takedamage", 0, 1); 	 
	SetEntityMoveType(jetpack, MOVETYPE_NOCLIP);    
	SetEntProp(jetpack, Prop_Data, "m_CollisionGroup", 2); 
	if(GetClientTeam(client)==2)AttachJetPack(jetpack, client, 0); 	
	else AttachJetPack(jetpack, client, 2); 
	
	decl Float:ang3[3];
	SetVector(ang3, 0.0, 0.0, 1.0);
	GetVectorAngles(ang3, ang3); 
	CopyVector(ang,ang3);
	if( GetClientTeam(client)==2)
	{
		ang3[2]+=270.0; 
		ang3[1]-=10.0; 
		SetVector(pos,  0.0,  -5.0,  -4.0);
	}
	else
	{
		ang3[2]+=90.0; 
		SetVector(pos,  0.0,  30.0,  8.0);
	} 
	
	DispatchKeyValueVector(jetpack, "origin", pos);  
	DispatchKeyValueVector(jetpack, "Angles", ang3); 
	TeleportEntity(jetpack, pos, NULL_VECTOR, ang3); 	 
	
	if(L4D2Version)
	{
		SetEntProp(jetpack, Prop_Send, "m_iGlowType", 3 ); //3
		SetEntProp(jetpack, Prop_Send, "m_nGlowRange", 0 ); //0
		SetEntProp(jetpack, Prop_Send, "m_glowColorOverride", 1); //1	
	}
	
	return 	jetpack;
}
AttachFlame( client, ent )
{
	client=client+0;
	decl String:flame_name[128];
	Format(flame_name, sizeof(flame_name), "target%d", ent);
	new flame = CreateEntityByName("env_steam");
	DispatchKeyValue( ent,"targetname", flame_name);
	DispatchKeyValue(flame,"parentname", flame_name);
	DispatchKeyValue(flame,"SpawnFlags", "1");
	DispatchKeyValue(flame,"Type", "0");
 
	DispatchKeyValue(flame,"InitialState", "1");
	DispatchKeyValue(flame,"Spreadspeed", "1");
	DispatchKeyValue(flame,"Speed", "250");
	DispatchKeyValue(flame,"Startsize", "6");
	DispatchKeyValue(flame,"EndSize", "8");
	DispatchKeyValue(flame,"Rate", "555");
	DispatchKeyValue(flame,"RenderColor", "10 52 99"); 
	DispatchKeyValue(flame,"JetLength", "40"); 
	DispatchKeyValue(flame,"RenderAmt", "180");
	
	DispatchSpawn(flame);	 
	SetVariantString(flame_name);
	AcceptEntityInput(flame, "SetParent", flame, flame, 0);
	
	new Float:origin[3];
	SetVector(origin,  -2.0, 0.0,  26.0);
	decl Float:ang[3];
	SetVector(ang, 0.0, 0.0, 1.0); 
	GetVectorAngles(ang, ang); 
	TeleportEntity(flame, origin, ang,NULL_VECTOR);	
	AcceptEntityInput(flame, "TurnOn"); 
  
}
AttachJetPack(ent, owner, position)
{
	 
	if(owner>0 && ent>0)
	{
		if(owner<MaxClients)
		{
			decl String:sTemp[16];
			Format(sTemp, sizeof(sTemp), "target%d", owner);
			DispatchKeyValue(owner, "targetname", sTemp);
			SetVariantString(sTemp);
			AcceptEntityInput(ent, "SetParent", ent, ent, 0);
			if(position==0)SetVariantString("medkit");
			if(position==1)SetVariantString("lfoot");  
			if(position==2)SetVariantString("rfoot"); 
			AcceptEntityInput(ent, "SetParentAttachment");
		}
	}
	 
}