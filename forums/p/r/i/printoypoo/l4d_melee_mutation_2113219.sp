/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 
#include <sdkhooks> 

 
#define MAX_SIZE 30
new String:SoundName[MAX_SIZE][200];
new String:WeaponName[MAX_SIZE][100];

new Float:MeleeChangeEnable[MAX_SIZE][MAX_SIZE];
  
 
#define Position_Melee 1
#define Position_Melee2 2
#define Position_Bayonet 3
#define Position_Bayonet_smg 4
#define Position_Bayonet_sniper 5
#define Position_Bayonet_hunting 6
#define Position_Bayonet_m60 7
#define Position_Bayonet_grenade_launcher 8
#define Position_Bayonet_scout 9
#define Position_Bayonet_desert 10
#define Position_Bayonet_sg552 11
#define Position_Bayonet_mp5 12
#define Position_Back 21

#define ArraySize MAXPLAYERS+1

new MeleeType[ArraySize];
new ThirdPersionView[ArraySize];
new MutationType[ArraySize];
new BayoneType[ArraySize];
new MeleeEnt[ArraySize];
new MeleeEnt2[ArraySize];
new bool:MeleeViewOn[ArraySize];
new BayonetEnt[ArraySize];
new bool:Cuting[ArraySize];
new bool:HoldMeleeMutation[ArraySize];
new Float:CutingDistance[ArraySize];
new Float:CutingStartTime[ArraySize];
new Float:CutingStartPos[ArraySize][3];
new Float:CutingFrontDirection[ArraySize][3];
new Float:CutingRightDirection[ArraySize][3];
new Float:CutingMaxDamage[ArraySize];
new Float:CutingMaxDistance[ArraySize];
new Float:CutingDamage[ArraySize];
new CutingHit[ArraySize];
new bool:CutingEnemy[ArraySize][ArraySize];


new GameMode;
new L4D2Version;
new g_sprite;
new g_PointHurt=0;
 
public Plugin:myinfo = 
{
	name = "Melee Weapon Mutation",
	author = "Pan XiaoHai",
	description = "L4D2 only",
	version = "1.3",
	url = "<- URL ->"
}
new Handle:l4d_melee_mutation_enable;
new Handle:l4d_melee_mutation_damage;
new Handle:l4d_melee_mutation_scale;
public OnPluginStart()
{
	GameCheck(); 	
	if(!L4D2Version)return;
	
 	l4d_melee_mutation_enable = CreateConVar("l4d_melee_mutation_enable", "1",  "0:diable melee mutation, 1:Enlarge and Bayonet, 2:Enlarge, 3:Bayonet", FCVAR_PLUGIN);
 	l4d_melee_mutation_damage = CreateConVar("l4d_melee_mutation_damage", "50.0",  "[0.0, 100.0], 0.0:extra damage for melee mutation", FCVAR_PLUGIN);
	l4d_melee_mutation_scale = CreateConVar("l4d_melee_mutation_scale", "1.0",  "[0.5, 3.0] melee weaopon's size", FCVAR_PLUGIN);
	
	AutoExecConfig(true, "l4d_melee_matation"); 
	
	HookEvent("player_spawn", player_spawn);	
	HookEvent("player_death", player_death); 
	HookEvent("player_bot_replace", player_bot_replace );	  
	HookEvent("bot_player_replace", bot_player_replace );	
	
	HookEvent("round_start", round_start);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition", round_end);	 
	
	HookEvent("item_pickup", item_pickup);			 
	HookEvent("player_use", player_use); 			 
	HookEvent("weapon_fire", weapon_fire);
	RegConsoleCmd("sm_meleeview", sm_meleeview);  
	ResetAllState();
	Init();
	HookAll(true); 
}
GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	GameMode=GameMode+0;
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
 
		L4D2Version=true;
	}	
	else
	{
 
		L4D2Version=false;
	}
 
}
HookAll(bool:hook)
{
	for(new i=1; i<=MaxClients; i++)
	{ 
		if(IsClientInGame(i))
		{
			HookWeaponSwitch(i, hook);
		}
	}
	 
} 
IsValidClient(client, team=0, bool:includeBot=true, bool:alive=true)
{
	if(client>0 && client<=MaxClients)
	{
		if(IsClientInGame(client))
		{
			if(GetClientTeam(client)!=team && team!=0)return false;
			if(IsFakeClient(client) && !includeBot)return false;			
			if(!IsPlayerAlive(client) && alive)return false;
			return true;
		}
	}
	return false;
}
public Action:item_pickup(Handle:event, const String:name[], bool:dontBroadcast) 
{ 
	if(GetConVarInt(l4d_melee_mutation_enable)==0)return;
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if(IsValidClient(client, 2) )
	{ 	  
		decl String:item[64];
		GetEventString(event, "item", item, sizeof(item));
		if(StrEqual(item, "melee"))
		{
			//PrintToChatAll("pickup melee %s", item);
			DeleteMelee(client);
			PickUpMeleeWeapon(client);
		}
		 
	}
}
public Action:player_use(Handle:event, const String:name[], bool:dontBroadcast)
{  
	return;
	new client =GetClientOfUserId(GetEventInt(event, "userid"));
	if(IsValidClient(client))
	{ 
		new targetid = GetEventInt(event, "targetid");
		decl String:item[64];
		GetEdictClassname(targetid, item, sizeof(item));
		if(StrEqual(item, "weapon_melee"))
		{
			//PrintToChatAll("use melee %s", item);
			//PickUpMeleeWeapon(client);
		 
		}
	}
}
 
HookWeaponSwitch(client, bool:hook)
{ 
	if(client>0 && IsClientInGame(client) && GetClientTeam(client)==2)
	{ 	
		SDKUnhook(client, SDKHook_WeaponSwitch, OnWeaponSwitch); 
		if(hook)
		{  
			SDKHook(client, SDKHook_WeaponSwitch, OnWeaponSwitch);	
		}
	} 
}
public Action:sm_meleeview(client,args)
{ 
	if(client>0)
	{ 
		MeleeViewOn[client]=!MeleeViewOn[client];
 	} 
}

bool:IsMelee(ent)
{
	if(ent>0 && IsValidEdict(ent) && IsValidEntity(ent))
	{
		decl String:item[64];
		GetEdictClassname(ent, item, sizeof(item));
		if(StrEqual(item, "prop_dynamic"))
		{
			return true;
		}
	}
	return false;
}

DeleteMelee(client)
{
	new ents[3];
	ents[0]=MeleeEnt[client];
	ents[1]=MeleeEnt2[client];
	ents[2]=BayonetEnt[client];
	MeleeEnt[client]=0;
	MeleeEnt2[client]=0;
	BayonetEnt[client]=0; 
	if(client>0)SDKUnhook(client, SDKHook_PreThink, Melee_PreThink);
	for(new i=0; i<3; i++)
	{
		if(IsMelee(ents[i]))
		{
			SDKUnhook(ents[i], SDKHook_SetTransmit, Melee_SetTransmit);
			AcceptEntityInput(ents[i], "ClearParent");
			AcceptEntityInput(ents[i], "kill");
		}
	}
	 
}
public Action:sm_melee2(client,args)
{ 
	CreateMelee(client);
}
#define Melee_FireAxe 1
#define Melee_cricket_bat 2
#define Melee_Katana 3
#define Melee_Machete 4
#define Melee_Guitar 5
#define Melee_pan 6
#define Melee_bat 7
#define Melee_tonfa 8
#define Melee_crowbar 9
#define Melee_golfclub 10
 

#define Melee_TwoMachete 20 
#define Melee_TwoMachete2 21 


#define Melee_Count 10

GetWeaopnType(entity)
{
	decl String:mclassname[64];
	GetEntPropString(entity, Prop_Data, "m_ModelName", mclassname, sizeof(mclassname));
	//PrintToChatAll(" model ===== %s", mclassname);
	new type=0;
 
	if(StrContains(mclassname, "fireaxe")>=0)type=Melee_FireAxe;
	else if(StrContains(mclassname, "fireaxe")>=0)type=Melee_FireAxe;
	else if(StrContains(mclassname, "katana")>=0)type=Melee_Katana;
	else if(StrContains(mclassname, "machete")>=0)type=Melee_Machete;
	else if(StrContains(mclassname, "electric_guitar")>=0)type=Melee_Guitar;
	else if(StrContains(mclassname, "tonfa")>=0)type=Melee_tonfa;
	else if(StrContains(mclassname, "frying_pan")>=0)type=Melee_pan;
	else if(StrContains(mclassname, "crowbar")>=0)type=Melee_crowbar;
	else if(StrContains(mclassname, "cricket_bat")>=0)type=Melee_cricket_bat;
	else if(StrContains(mclassname, "v_bat")>=0)type=Melee_bat;
	else if(StrContains(mclassname, "golfclub")>=0)type=Melee_golfclub;
	return type;
}
Init()  
{
	SetRandomSeed(GetSysTickCount());

	for(new i=0; i<MAX_SIZE; i++)
	{
 		SoundName[i]="";
		for(new j=0; j<MAX_SIZE; j++)
		{
			MeleeChangeEnable[i][j]=0.0;
		}
	}  

	WeaponName[Melee_FireAxe]="models/weapons/melee/w_fireaxe.mdl"; 
	WeaponName[Melee_Katana]="models/weapons/melee/w_katana.mdl";
	WeaponName[Melee_Machete]="models/weapons/melee/w_machete.mdl";	
	WeaponName[Melee_Guitar]="models/weapons/melee/w_electric_guitar.mdl"; 
	WeaponName[Melee_pan]="models/weapons/melee/w_frying_pan.mdl"; 
	WeaponName[Melee_tonfa]="models/weapons/melee/w_tonfa.mdl";	
  	WeaponName[Melee_crowbar]="models/weapons/melee/w_crowbar.mdl";
	WeaponName[Melee_cricket_bat]="models/weapons/melee/w_cricket_bat.mdl";	 
	WeaponName[Melee_bat]="models/weapons/melee/w_bat.mdl";	
	WeaponName[Melee_golfclub]="models/weapons/melee/w_golfclub.mdl";

	SoundName[Melee_FireAxe]="weapons/machete/machete_impact_flesh1.wav"; 
	SoundName[Melee_Katana]="weapons/katana/melee_katana_01.wav";
	SoundName[Melee_Machete]="weapons/machete/machete_impact_flesh1.wav"; 
	SoundName[Melee_Guitar]="weapons/guitar/melee_guitar_05.wav"; 
	SoundName[Melee_pan]="weapons/pan/melee_frying_pan_01.wav"; 
	SoundName[Melee_tonfa]="weapons/tonfa/melee_tonfa_01.wav"; 
	SoundName[Melee_crowbar]="weapons/machete/machete_impact_flesh1.wav";
	SoundName[Melee_golfclub]="weapons/golf_club/wpn_golf_club_melee_01.wav"; 
 	
	
	//MeleeChangeEnable[Melee_FireAxe][Melee_Machete]=3.5;
	//MeleeChangeEnable[Melee_FireAxe][Melee_FireAxe]=2.0;
	
	MeleeChangeEnable[Melee_Katana][Melee_Katana]=2.8;
	MeleeChangeEnable[Melee_Katana][Melee_FireAxe]=1.8;	
	MeleeChangeEnable[Melee_Katana][Melee_Machete]=3.0;
	MeleeChangeEnable[Melee_Katana][Melee_tonfa]=2.5;
	MeleeChangeEnable[Melee_Katana][Melee_TwoMachete]=2.5;
 	
	MeleeChangeEnable[Melee_golfclub][Melee_Katana]=3.0;
	MeleeChangeEnable[Melee_golfclub][Melee_FireAxe]=1.8;	
	MeleeChangeEnable[Melee_golfclub][Melee_Machete]=3.0;
	MeleeChangeEnable[Melee_golfclub][Melee_tonfa]=2.5;	
	MeleeChangeEnable[Melee_golfclub][Melee_crowbar]=2.2;	
	MeleeChangeEnable[Melee_golfclub][Melee_bat]=2.0;	
	MeleeChangeEnable[Melee_golfclub][Melee_TwoMachete]=2.5;
	
	MeleeChangeEnable[Melee_Machete][Melee_Machete]=3.0;
	MeleeChangeEnable[Melee_Machete][Melee_TwoMachete2]=2.5;	
 
	
	MeleeChangeEnable[Melee_Guitar][Melee_Guitar]=2.5;
	
	MeleeChangeEnable[Melee_pan][Melee_pan]=2.5;	
	
	MeleeChangeEnable[Melee_tonfa][Melee_tonfa]=2.5;		
	MeleeChangeEnable[Melee_tonfa][Melee_TwoMachete2]=2.5;	
	MeleeChangeEnable[Melee_tonfa][Melee_Machete]=3.0;
	MeleeChangeEnable[Melee_tonfa][Melee_FireAxe]=1.8;
	MeleeChangeEnable[Melee_tonfa][Melee_Katana]=2.8;
	
	
	MeleeChangeEnable[Melee_crowbar][Melee_crowbar]=2.2;		
	MeleeChangeEnable[Melee_crowbar][Melee_FireAxe]=2.0;
	MeleeChangeEnable[Melee_crowbar][Melee_Katana]=2.5;
	MeleeChangeEnable[Melee_crowbar][Melee_Machete]=3.0;	
	MeleeChangeEnable[Melee_crowbar][Melee_Katana]=2.8;	
	MeleeChangeEnable[Melee_crowbar][Melee_TwoMachete2]=2.5;	
	//MeleeBayonetEnable;
	 
}

PickUpMeleeWeapon(client)
{
	new weapon=GetEntPropEnt(client, Prop_Data, "m_hActiveWeapon" );
	if(weapon>0)
	{
		decl String:item[64];
		GetEdictClassname(weapon, item, sizeof(item));
		new type=GetWeaopnType(weapon);
		//PrintToChatAll("Pick up %s %d", item, type);
		if(type>0)
		{
			MeleeType[client]=type;
			new mode=GetConVarInt(l4d_melee_mutation_enable);
			MutationType[client]=0;
			if(mode==1 || mode==2)	
			{		
				
				new muation[MAX_SIZE];
				new count=0;
				for(new i=0; i<MAX_SIZE; i++)
				{
					if(MeleeChangeEnable[type][i]>0.0)
					{
						muation[count++]=i;
					}				 
				}
				
				if(count>0)
				{ 
					MutationType[client]=muation[GetRandomInt(0, count-1)];			
				}  				
				CreateTimer(0.1, DelaySwitch, client, TIMER_FLAG_NO_MAPCHANGE);
			}
			BayoneType[client]=0;
			if(mode==1 || mode==3)	
			{
				BayoneType[client]=1;
			}
		}
	}
}
public Action:DelaySwitch(Handle:timer, any:client)
{
	if(IsValidClient(client, 2))
	{
		new weapon=GetEntPropEnt(client, Prop_Data, "m_hActiveWeapon" );
		if(weapon>0)
		{
			OnWeaponSwitch(client, weapon);
			if(MutationType[client]>0)
			{
				ThirdPersionView[client]=true;
				GotoThirdPerson(client);			
			}
			CreateTimer(5.0,DelayFirstPerson , client, TIMER_FLAG_NO_MAPCHANGE);
		}		
	}
} 
public Action:DelayFirstPerson(Handle:timer, any:client)
{
	if(IsValidClient(client, 2))
	{
		GotoFirstPerson(client);	
		ThirdPersionView[client]=false;
	}
}
 
public Action:Melee_SetTransmit(entity, client)
{ 
	new owner=0;
	if(entity==MeleeEnt[client] || entity==MeleeEnt2[client] || entity==BayonetEnt[client])
	{
		owner=client;
	}	
	if(owner>0)
	{
		if(MeleeViewOn[owner] || ThirdPersionView[owner])return Plugin_Continue;
		else return Plugin_Handled;
	}
	return Plugin_Continue;
}
public Action:OnWeaponSwitch(client, weapon)
{ 
	if(GetConVarInt(l4d_melee_mutation_enable)==0)return Plugin_Continue;
	if(client==0)return Plugin_Continue; 
 	decl String:item[64];
	GetEdictClassname(weapon, item, sizeof(item));
	//PrintToChatAll("switch to %s", item);
	if(MutationType[client]>0 || BayoneType[client]>0)
	{
		if(!HaveMeleeWeaopn(client))
		{
			MutationType[client]=0;
			BayoneType[client]=0;
			DeleteMelee(client);
			return Plugin_Continue; 
		} 
		
		if(BayoneType[client]>0 && weapon==GetPlayerWeaponSlot(client, 0))
		{
			//PrintToChatAll("%N hold primary", client);
			CreateBayonet(client, weapon);
		}
		if(MutationType[client]>0 && weapon==GetPlayerWeaponSlot(client, 1))
		{
			//PrintToChatAll("%N hold melee", client);
			CreateMelee(client);
		} 		
	}
	return Plugin_Continue; 
}

HaveMeleeWeaopn(client)
{
	new weapon=GetPlayerWeaponSlot(client ,1);
	if(weapon>0)
	{
		decl String:item[64];
		GetEdictClassname(weapon, item, sizeof(item));
		if(StrEqual(item, "weapon_melee"))
		{
			return true;
		}
	}
	return false;
}
CreateMelee(client)
{	 
	DeleteMelee(client); 
 	new weapon=MutationType[client]; 
	new Float:scale=MeleeChangeEnable[MeleeType[client]][weapon]*GetConVarFloat(l4d_melee_mutation_scale);
 
	if(weapon==Melee_TwoMachete)
	{
		MeleeEnt[client]=CreateMeleeClone(client,  Melee_Machete, Position_Melee,scale);
		MeleeEnt2[client]=CreateMeleeClone(client, Melee_Machete, Position_Melee2,scale );
		SDKHook(MeleeEnt[client], SDKHook_SetTransmit, Melee_SetTransmit);
		SDKHook(MeleeEnt2[client], SDKHook_SetTransmit, Melee_SetTransmit);
	}
	else if(weapon==Melee_TwoMachete2)
	{
		MeleeEnt[client]=CreateMeleeClone(client,  Melee_Machete, Position_Melee,scale);
		MeleeEnt2[client]=CreateMeleeClone(client, Melee_Machete, Position_Melee2,scale *0.7);
		SDKHook(MeleeEnt[client], SDKHook_SetTransmit, Melee_SetTransmit);
		SDKHook(MeleeEnt2[client], SDKHook_SetTransmit, Melee_SetTransmit);
	}
	else
	{
		MeleeEnt[client]=CreateMeleeClone(client,  weapon, Position_Melee,scale);
		MeleeEnt2[client]=0;
		SDKHook(MeleeEnt[client], SDKHook_SetTransmit, Melee_SetTransmit);
	}
	HoldMeleeMutation[client]=true;
	Cuting[client]=false;
	CutingDistance[client]=0.0;
	CutingStartTime[client]=0.0;
	CutingMaxDamage[client]=GetConVarFloat(l4d_melee_mutation_damage);
	CutingDamage[client]=CutingMaxDamage[client];
	CutingMaxDistance[client]=60.0*scale/2.0;
	SDKUnhook( client, SDKHook_PreThink,  Melee_PreThink);  
	if(GetConVarFloat(l4d_melee_mutation_damage)>0.0)SDKHook( client, SDKHook_PreThink,  Melee_PreThink);  
}
 public Action:weapon_fire(Handle:event, const String:name[], bool:dontBroadcast)
{ 
	if(GetConVarInt(l4d_melee_mutation_enable)==0)return Plugin_Continue;
	if(GetConVarFloat(l4d_melee_mutation_damage)<=0.0)return Plugin_Continue;
 	new client = GetClientOfUserId(GetEventInt(event, "userid"));	 
	if(client>0 && GetClientTeam(client)==2)
	{
		if( HoldMeleeMutation[client] )
		{ 
			decl String:item[65];
			GetEventString(event, "weapon", item, 65);
			if( StrContains(item, "melee")>=0 )
			{
				new Float:time=GetEngineTime();
				Cuting[client]=true;
				CutingStartTime[client]=time;
				CutingDistance[client]=0.0;
				GetClientEyePosition(client, CutingStartPos[client]);
				decl Float:angle[3];
				GetClientEyeAngles(client, angle);
				GetAngleVectors(angle, CutingFrontDirection [client], NULL_VECTOR,NULL_VECTOR);
				GetAngleVectors(angle, NULL_VECTOR,CutingRightDirection [client],NULL_VECTOR);
				NormalizeVector(CutingFrontDirection [client], CutingFrontDirection [client]);
				NormalizeVector(CutingRightDirection [client], CutingRightDirection [client]);
				for(new i=0; i<=MaxClients; i++)CutingEnemy[client][i]=false;
			}			
		}		
	}
	return Plugin_Continue;
}
public Melee_PreThink(client)
{	
	if(client>0 && IsClientInGame(client) && IsPlayerAlive(client))
	{ 
		if(CutingDistance[client]>CutingMaxDistance[client])
		{
			Cuting[client]=false;
		}
		if(Cuting[client])DoCut(client);	
		
	}
	else
	{
		SDKUnhook(client, SDKHook_PreThink,  Melee_PreThink);
	}	

} 
 
DoCut(client, Float:CutWidth=50.0, Float:Offset=20.0)
{ 
	//PrintToChatAll("cutting");
	decl Float:startPos[3]; 
	decl Float:left[3];
	decl Float:right[3];
	decl Float:temp[3];
	
	//CutingDamage[client]=CutingMaxDamage[client]*(CutingMaxDistance[client]-CutingDistance[client]*0.5)/CutingMaxDistance[client];
	//if(CutingDamage[client]<=0.0)CutingDamage[client]=0.0; 
	
	
	CopyVector(CutingStartPos[client], startPos);
	CopyVector(CutingRightDirection[client], temp);
	ScaleVector(temp, CutWidth);
	AddVectors(startPos, temp, right);
	SubtractVectors(startPos,temp, left);
	
	CopyVector(CutingFrontDirection[client], temp);
	ScaleVector(temp, CutingDistance[client]);	
	CutingDistance[client]+=Offset;	
	
	AddVectors(right, temp, right);
	AddVectors(left, temp, left);
	
	//ShowLaser(0, left, right, 0.06, 1.0, 1.0);	

	CutingHit[client]=0;
	new Handle:trace=TR_TraceRayFilterEx(left, right, MASK_ALL, RayType_EndPoint, DontHitSelf,client);
	TR_DidHit(trace);
 	CloseHandle(trace); 
	if(CutingHit[client]>0 && strlen(SoundName[MeleeType[client]])>1)
	{		 
		EmitSoundToAll(SoundName[MeleeType[client]], client,  SNDCHAN_WEAPON, SNDLEVEL_NORMAL, SND_NOFLAGS,0.5, SNDPITCH_NORMAL, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);

	}
}

CreatePointHurt()
{
	new pointHurt=CreateEntityByName("point_hurt");
	if(pointHurt)
	{
		DispatchKeyValue(pointHurt,"Damage","10");
		DispatchKeyValue(pointHurt,"DamageType","2");
		DispatchSpawn(pointHurt);
	}
	return pointHurt;
}
new String:N[20];
DoPointHurtForInfected(victim, attacker=0, Float:damage)
{
	if(g_PointHurt > 0)
	{
		if(IsValidEdict(g_PointHurt))
		{
			if(victim>0 && IsValidEdict(victim))
			{		
				Format(N, 20, "target%d", victim);
				DispatchKeyValue(victim,"targetname", N);
				DispatchKeyValue(g_PointHurt,"DamageTarget", N);
				//DispatchKeyValue(g_PointHurt,"classname","");
				DispatchKeyValueFloat(g_PointHurt,"Damage", damage);
				DispatchKeyValue(g_PointHurt,"DamageType","-2130706430"); //-2130706430 
				AcceptEntityInput(g_PointHurt,"Hurt",(attacker>0)?attacker:-1);
			}
		}
		else g_PointHurt=CreatePointHurt();
	}
	else g_PointHurt=CreatePointHurt();
}
public bool:DontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	if(entity == 0) 
	{
		
		return false; 
	}
	if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==2)return false; 
		if(CutingEnemy[data][entity])return false; 
		CutingEnemy[data][entity]=true;
	}	 
	else
	{
		decl String:name[64];
		GetEdictClassname(entity, name, 64);
		if(!StrEqual(name, "infected"))
		{
			return false;
		}
	}
	CutingHit[data]++;
	DoPointHurtForInfected(entity, data, CutingDamage[data] );	 	 
	return false;
}
CreateBayonet(client, holdWeapon)
{	
	DeleteMelee(client); 
	new Float:scale=1.0;
 	new weapon=Melee_Machete; 	
	new position=Position_Bayonet;
	 
	if(holdWeapon>0)
	{
		decl String:item[64];
		GetEdictClassname(holdWeapon, item, sizeof(item));
		if(StrContains(item, "mp5")>=0)
		{  
			position=Position_Bayonet_mp5;
		}
		else if(StrContains(item, "smg")>=0)
		{  
			position=Position_Bayonet_smg;
		}
		else if(StrContains(item, "scout")>=0)
		{
			position=Position_Bayonet_scout;
		}
		else if(StrContains(item, "sniper")>=0)
		{
			position=Position_Bayonet_sniper;
		}
		else if(StrContains(item, "hunting")>=0)
		{
			position=Position_Bayonet_hunting;
		}	
		else if(StrContains(item, "m60")>=0)
		{
			position=Position_Bayonet_m60;
		}
		else if(StrContains(item, "grenade_launcher")>=0)
		{
			position=Position_Bayonet_grenade_launcher;
		}
		else if(StrContains(item, "desert")>=0)
		{
			position=Position_Bayonet_desert;
		}
		else if(StrContains(item, "sg552")>=0)
		{
			position=Position_Bayonet_sg552 ;
		}
		BayonetEnt[client]=CreateBayonetClone(client, weapon, position,scale); 
		SDKHook(BayonetEnt[client], SDKHook_SetTransmit, Melee_SetTransmit);
	}	
}
CreateBayonetClone(client, replaceWeaopn, position, Float:scale )
{
	return CreateMeleeClone(client,  replaceWeaopn, position,scale);
} 
CreateMeleeClone(client, replaceWeaopn, position, Float:scale )
{
	new weapon=replaceWeaopn;  
	
	new melee=CreateEntityByName("prop_dynamic_override");    
	SetEntityModel(melee, WeaponName[weapon]);
	DispatchSpawn(melee); 
	
	new owner=client;
	//owner=256;
	decl String:tname[60];
	Format(tname, sizeof(tname), "target%d", owner);
	DispatchKeyValue(owner, "targetname", tname); 		
	DispatchKeyValue(melee, "parentname", tname);
	
	SetVariantString(tname);
	AcceptEntityInput(melee, "SetParent",melee, melee, 0); 	 
	SetVariantString("weapon_bone"); //weapon_bone
	AcceptEntityInput(melee, "SetParentAttachment"); 
	 
 	
	new Float:pos[3];
	new Float:ang[3]; 
	GetPosAng( pos, ang,position); 
 	
	TeleportEntity(melee, pos, ang, NULL_VECTOR);
 
 	SetEntProp(melee, Prop_Send, "m_CollisionGroup", 2);   
 	SetEntProp(melee, Prop_Send, "m_iGlowType", 3 ); //3
	SetEntProp(melee, Prop_Send, "m_nGlowRange", 0 ); //0
	SetEntProp(melee, Prop_Send, "m_glowColorOverride",  1); //1
	
	SetEntPropFloat(melee , Prop_Send,"m_flModelScale" ,scale);  
	return melee;
} 
GetPosAng(Float:pos[3],  Float:ang[3], position )
{ 
	if(position==Position_Melee)
	{
		SetVector(pos,  0.0, 0.0, 0.0); 
		SetVector(ang, 270.0, 270.0,0.0);
	}
	else if(position==Position_Melee2)
	{
		SetVector(pos,  0.0, 0.0, 0.0); 
		SetVector(ang, 270.0, 90.0,0.0);
	}	
	else if(position==Position_Bayonet)
	{
		SetVector(pos,  0.0,  1.0, 23.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
	else if(position==Position_Bayonet_grenade_launcher)
	{
		SetVector(pos,  0.0,  2.0, 20.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
	else if(position==Position_Bayonet_m60)
	{
		SetVector(pos,  0.0,  2.5, 32.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	} 
	else if(position==Position_Bayonet_sniper)
	{
		SetVector(pos,  0.0,  2.0, 28.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
	else if(position==Position_Bayonet_scout)
	{
		SetVector(pos,  0.0,  1.5, 23.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
 	else if(position==Position_Bayonet_hunting)
	{
		SetVector(pos,  0.0,  2.5, 23.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	} 	
	else if(position==Position_Bayonet_smg)
	{
		SetVector(pos,  0.0,  1.0, 12.0); 
		SetVector(ang, 0.0, 270.0,0.0);	 
	} 
	else if(position==Position_Bayonet_mp5)
	{
		SetVector(pos,  0.0,  2.5, 15.0); 
		SetVector(ang, 0.0, 270.0,0.0);	 
	} 
	else if(position==Position_Bayonet_desert)
	{
		SetVector(pos,  0.0,  1.5, 20.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
	else if(position==Position_Bayonet_sg552)
	{
		SetVector(pos,  0.0,  1.5, 15.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}	
}

public Action:TimerCreateMelee(Handle:timer, any:client)
{
	if(client>0 && IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client)==3 && IsInfected(client, 8))
	{
		CreateMelee(client);
	}
}

SetVector(Float:target[3], Float:x, Float:y, Float:z)
{
	target[0]=x;
	target[1]=y;
	target[2]=z;
}
IsInfected(client, type)
{
	new class = GetEntProp(client, Prop_Send, "m_zombieClass");
	if(type==class)return true;
	else return false;
}

public Action:player_spawn(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
	new client = GetClientOfUserId(GetEventInt(hEvent, "userid"));   
	if(client>0)
	{ 
		HookWeaponSwitch(client, true);
	}
}

public Action:player_death(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
	new victim = GetClientOfUserId(GetEventInt(hEvent, "userid")); 
	if(victim>0 && victim<=MaxClients)
	{
		DeleteMelee(victim);
	}
	return Plugin_Continue;	 
}
public player_bot_replace(Handle:Spawn_Event, const String:Spawn_Name[], bool:Spawn_Broadcast)
{
 	new client = GetClientOfUserId(GetEventInt(Spawn_Event, "player"));
	new bot = GetClientOfUserId(GetEventInt(Spawn_Event, "bot"));   
	 
	if(client>0)
	{
		DeleteMelee(client);	
	}
	if(bot>0)
	{
		 DeleteMelee(bot);
	}
}
public bot_player_replace(Handle:Spawn_Event, const String:Spawn_Name[], bool:Spawn_Broadcast)
{
 	new client = GetClientOfUserId(GetEventInt(Spawn_Event, "player"));
	new bot = GetClientOfUserId(GetEventInt(Spawn_Event, "bot"));   
	 
	if(bot>0)
	{
		DeleteMelee(bot);
	}
	if(client>0)
	{
		 DeleteMelee(client);
	}

}
public Action:round_start(Handle:event, const String:name[], bool:dontBroadcast)
{
	HookAll(true);
	ResetAllState();
}
public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	HookAll(false);
	ResetAllState();
}
ResetAllState()
{
	for(new i=1; i<=MaxClients; i++)
	{
		ResetClientState(i);
	}
}
ResetClientState(i)
{
	MeleeEnt[i]=0;
	MeleeEnt2[i]=0;
	BayonetEnt[i]=0;  
	MutationType[i]=0;
	BayoneType[i]=0;	
	ThirdPersionView[i]=false;
	MeleeViewOn[i]=false;
	Cuting[i]=false;
	CutingStartTime[i]=0.0;
	HoldMeleeMutation[i]=false;
	g_PointHurt=0;
}
public OnMapStart()
{ 
	if(L4D2Version)
	{
		for(new i=1; i<MAX_SIZE; i++)
		{
			if(strlen(WeaponName[i])>1)PrecacheModel(WeaponName[i]);
		}
		for(new i=1; i<MAX_SIZE; i++)
		{
			if(strlen(SoundName[i])>1)PrecacheSound(SoundName[i]);
		}
 	}
	ResetAllState();
	if(L4D2Version)
	{
		g_sprite = PrecacheModel("materials/sprites/laserbeam.vmt");	
	 
	}
	else
	{
		g_sprite = PrecacheModel("materials/sprites/laser.vmt");	
		 	
	} 
}
GotoThirdPerson(client)
{
	SetEntPropEnt(client, Prop_Send, "m_hObserverTarget", 0);
	SetEntProp(client, Prop_Send, "m_iObserverMode", 1);
	SetEntProp(client, Prop_Send, "m_bDrawViewmodel", 0);
}

GotoFirstPerson(client)
{
	SetEntPropEnt(client, Prop_Send, "m_hObserverTarget", -1);
	SetEntProp(client, Prop_Send, "m_iObserverMode", 0);
	SetEntProp(client, Prop_Send, "m_bDrawViewmodel", 1);
} 
CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
	target[1]=source[1];
	target[2]=source[2];
}
ShowLaser(colortype,Float:pos1[3], Float:pos2[3], Float:life=10.0,  Float:width1=1.0, Float:width2=11.0)
{
	decl color[4];
	if(colortype==1)
	{
		color[0] = 200; 
		color[1] = 0;
		color[2] = 0;
		color[3] = 230; 
	}
	else if(colortype==2)
	{
		color[0] = 0; 
		color[1] = 200;
		color[2] = 0;
		color[3] = 230; 
	}
	else if(colortype==3)
	{
		color[0] = 0; 
		color[1] = 0;
		color[2] = 200;
		color[3] = 230; 
	}
	else 
	{
		color[0] = 200; 
		color[1] = 200;
		color[2] = 200;
		color[3] = 230; 		
	}

	
	TE_SetupBeamPoints(pos1, pos2, g_sprite, 0, 0, 0, life, width1, width2, 1, 0.0, color, 0);
	TE_SendToAll();
}
 