#include <sourcemod>
#include <sdktools>

#define VERSION "1.0.2"
#define DEBUG 0
#define MAX_CLIENTS_PLUS_ONE 20
#define STEAM_ID_LEN 32
#define MAX_MAP_NAME_LEN 32
#define MAX_EXPLOIT_PLANES 64
#define MAX_EXPLOIT_PLANE_EXCEPTIONS 16
#define EXPLOIT_DESCRIPTION_LEN 64
#define X_COORD 0
#define Y_COORD 1
#define Z_COORD 2
#define X_MIN 0
#define X_MAX 1
#define Y_MIN 2
#define Y_MAX 3
#define INVALID_COORD_VAL 0.0
#define EXPLOIT_PLANE_KEY "ExploitPlane"
#define EXPLOIT_DESCRIPTION_KEY "Description"
#define EXPLOIT_EXCEPTIONS_KEY "Exceptions"
#define EXPLOIT_EXCEPTION_COORDS_KEY "Coords"
#define MAX_EXCEPTION_VALUE_LEN 64
#define CHARGE_HIT_EXCEPTION_TIME 5.0
#define DMG_FALL (1 << 5)
#define BAN_FILE "addons/sourcemod/data/mapexploitdetector_bans.txt"
#define MAX_RECENT_BANS 32
#define ADMIN_MENU_UNBAN "1"
#define ADMIN_MENU_DETECTION_ENABLE "2"
#define ADMIN_MENU_DETECTION_DISABLE "3"
#define ADMIN_MENU_DESCRIPTIONS "4"
#define ADMIN_MENU_TIMEOUT 60
#define DETECTED_MOVE_DIST_SQUARED 10000.0
#define POST_MOVE_ANNOUNCE_DELAY 8.0
#define MAX_ADMIN_FLAGS 26

enum TeamType
{
	Spectator = 1,
	Survivor = 2,
	Infected = 3
};

public Plugin:myinfo =
{
	name = "Map Exploit Detector",
	author = "AbyssStaresBack",
	description = "Detects map exploits and punishes players who use them",
	version = VERSION,
	url = "http://forums.alliedmods.net/showthread.php?t=154019"
};

// CVAR handles
new Handle:cvarEnabled = INVALID_HANDLE;
new Handle:cvarBanTime = INVALID_HANDLE;
new Handle:cvarShowBanMessage = INVALID_HANDLE;
new Handle:cvarAnnounce = INVALID_HANDLE;
new Handle:cvarImmunity = INVALID_HANDLE;

// If true, players will be punished for exploiting the map
new bool:isPunishmentEnabled = true;

// True if mp_gamemode is Versus, Team Versus, or Realism Versus (NOT Scavenge/Team Scavenge)
new bool:isGameModeVersus;

// Temp variable to be used in OnGameFrame
new Float:position[3];

// Current client position
new Float:clientPosition[MAX_CLIENTS_PLUS_ONE][3];
new bool:isClientPositionSet[MAX_CLIENTS_PLUS_ONE];

// Position of client when he/she loads in (so the plugin announcement can happen after they move)
new Float:clientInitialPosition[MAX_CLIENTS_PLUS_ONE][3];
new bool:clientNeedsAnnouncement[MAX_CLIENTS_PLUS_ONE];

new Handle:clientPunishmentTimers[MAX_CLIENTS_PLUS_ONE];

new Handle:positionDisplayTimer = INVALID_HANDLE;

// KeyValue for the data file with map exploits and exceptions
new Handle:kvMapExploits = INVALID_HANDLE;

new bool:mapHasExploitPlanes = false;

// Z-coordinates of exploit planes for current map
new Float:exploitPlanes[MAX_EXPLOIT_PLANES];
new numExploitPlanes = 0;

// Exploit descriptions for the current map; displayed by sm_mapexploits
new String:exploitDescriptions[MAX_EXPLOIT_PLANES][EXPLOIT_DESCRIPTION_LEN];

// X/Y min/max coordinates of exceptions for each exploit plane (allows multiple exceptions per exploit plane)
new Float:exploitPlaneExceptions[MAX_EXPLOIT_PLANES][MAX_EXPLOIT_PLANE_EXCEPTIONS][4];
// Number of exceptions for EACH plane (use numExploitPlanes to find the highest first index into exploitPlaneExceptions)
new numExploitPlaneExceptions[MAX_EXPLOIT_PLANES];

// If any of the following are true for a client, they can pass through exploit planes (since they are not in control)
new bool:isClientBeingCharged[MAX_CLIENTS_PLUS_ONE];
new bool:isClientBeingJockied[MAX_CLIENTS_PLUS_ONE];
new bool:isClientBeingSmoked[MAX_CLIENTS_PLUS_ONE];
new bool:wasClientHitByCharger[MAX_CLIENTS_PLUS_ONE]; // A client that was recently struck, but not carried by charger

// If true, a client has passed through an exploit plane, but not yet jumped,
// and therefore will not be counted as an exploiter if he/she dies from fall damage
new bool:isClientFallEligible[MAX_CLIENTS_PLUS_ONE];

// Keeps a running list of the most recently banned users (since the plugin was loaded)
new Handle:recentBans[MAX_RECENT_BANS];
new recentBansStartIndex;
new numRecentBans;

public OnMapStart()
{
#if DEBUG
	positionDisplayTimer = CreateTimer(1.0, DisplayPosition, _, TIMER_REPEAT);
#endif

	// Invalidate client positions and other statuses on map load (to prevent crossover values from previous map)
	for (new i = 0; i < MAX_CLIENTS_PLUS_ONE; i++)
	{
		isClientPositionSet[i] = false;
		isClientBeingCharged[i] = false;
		isClientBeingJockied[i] = false;
		isClientBeingSmoked[i] = false;
		wasClientHitByCharger[i] = false;
		isClientFallEligible[i] = false;
		
		clientNeedsAnnouncement[i] = false;
	}

	decl String:mapName[MAX_MAP_NAME_LEN];
	GetCurrentMap(mapName, MAX_MAP_NAME_LEN);

#if DEBUG
	PrintToServer("[SM] (Map Exploit Detector): Current map: '%s'", mapName);
#endif

	numExploitPlanes = 0;

	KvRewind(kvMapExploits);
	new bool:mapFound = KvJumpToKey(kvMapExploits, mapName);

#if DEBUG
	if (mapFound)
	{
		PrintToServer("[SM] (Map Exploit Detector): Map is listed in gamedata file");
	}
#endif

	mapHasExploitPlanes = mapFound && KvGotoFirstSubKey(kvMapExploits);


	if (mapHasExploitPlanes)
	{
#if DEBUG
		PrintToServer("[SM] (Map Exploit Detector): Map has exploit planes");
#endif

		// Read in all exploit planes for the current map

		new Float:exploitPlaneZCoord;
		new bool:exploitHasExceptions;
		new bool:moreExploitPlanesExist = true;
		while (moreExploitPlanesExist && numExploitPlanes < MAX_EXPLOIT_PLANES)
		{
			exploitPlaneZCoord = KvGetFloat(kvMapExploits, EXPLOIT_PLANE_KEY, INVALID_COORD_VAL);
#if DEBUG
			PrintToServer("[SM] (Map Exploit Detector): Exploit Plane at Z='%f' read in", exploitPlaneZCoord);
#endif
			if (exploitPlaneZCoord != INVALID_COORD_VAL)
			{
#if DEBUG
				PrintToServer("[SM] (Map Exploit Detector): Exploit Plane at Z='%f' is valid", exploitPlaneZCoord);
#endif
				exploitPlanes[numExploitPlanes] = exploitPlaneZCoord;
				numExploitPlaneExceptions[numExploitPlanes] = 0;

				// Retrieve the description of the current exploit
				KvGetString(kvMapExploits, EXPLOIT_DESCRIPTION_KEY, exploitDescriptions[numExploitPlanes], EXPLOIT_DESCRIPTION_LEN);

				exploitHasExceptions = KvJumpToKey(kvMapExploits, EXPLOIT_EXCEPTIONS_KEY) && KvGotoFirstSubKey(kvMapExploits);

				if (exploitHasExceptions)
				{
#if DEBUG
					PrintToServer("[SM] (Map Exploit Detector): Exploit Plane at Z='%f' has exceptions", exploitPlaneZCoord);
#endif

					// Read in all exceptions for the current exploit plane

					decl String:exceptionValStr[MAX_EXCEPTION_VALUE_LEN];
					new bool:moreExceptionsExist = true;
					while (moreExceptionsExist && numExploitPlaneExceptions[numExploitPlanes] < MAX_EXPLOIT_PLANE_EXCEPTIONS)
					{
						KvGetString(kvMapExploits, EXPLOIT_EXCEPTION_COORDS_KEY, exceptionValStr, MAX_EXCEPTION_VALUE_LEN);

						if (strcmp(exceptionValStr, "") != 0)
						{
#if DEBUG
							PrintToServer("[SM] (Map Exploit Detector): Exception loading...");
#endif
							new Float:exceptionValues[4];
							new exceptionValueIndex = 0;
							new String:currentExceptionValue[16];
							new currentExceptionValueIndex = 0;
							for (new i = 0; i < MAX_EXCEPTION_VALUE_LEN; i++)
							{
								if (exceptionValStr[i] == '\0')
								{
									// Reached the end of the exception's coordinate values
									currentExceptionValue[currentExceptionValueIndex] = '\0';
									exceptionValues[exceptionValueIndex] = StringToFloat(currentExceptionValue);
									exceptionValueIndex++;

									break;
								}

								if (exceptionValStr[i] == ' ')
								{
									// Reached the space between two of the exception's coordinate values
									currentExceptionValue[currentExceptionValueIndex] = '\0';
									exceptionValues[exceptionValueIndex] = StringToFloat(currentExceptionValue);
									currentExceptionValueIndex = 0;
									exceptionValueIndex++;
									if (exceptionValueIndex >= 4)
									{
										break;
									}
								}
								else
								{
									currentExceptionValue[currentExceptionValueIndex] = exceptionValStr[i];
									currentExceptionValueIndex++;
								}
							}

							if (exceptionValueIndex == 4)
							{
#if DEBUG
								PrintToServer("[SM] (Map Exploit Detector): Exception loaded successfully");
#endif
								exploitPlaneExceptions[numExploitPlanes][numExploitPlaneExceptions[numExploitPlanes]][X_MIN] = exceptionValues[X_MIN];
								exploitPlaneExceptions[numExploitPlanes][numExploitPlaneExceptions[numExploitPlanes]][X_MAX] = exceptionValues[X_MAX];
								exploitPlaneExceptions[numExploitPlanes][numExploitPlaneExceptions[numExploitPlanes]][Y_MIN] = exceptionValues[Y_MIN];
								exploitPlaneExceptions[numExploitPlanes][numExploitPlaneExceptions[numExploitPlanes]][Y_MAX] = exceptionValues[Y_MAX];

								numExploitPlaneExceptions[numExploitPlanes]++;
							}
						}

						// Check for next exceptions
						KvGoBack(kvMapExploits);
						moreExceptionsExist = KvGotoNextKey(kvMapExploits);
					}
				}

				numExploitPlanes++;
			}

			KvGoBack(kvMapExploits);
			moreExploitPlanesExist = KvGotoNextKey(kvMapExploits);
		}

		mapHasExploitPlanes = (numExploitPlanes > 0);
	}

	if (mapHasExploitPlanes)
	{	
		HookEvent("player_team", Event_PlayerTeam, EventHookMode_Pre);
		HookEvent("charger_carry_start", Event_ChargerCarryStart, EventHookMode_Post);
		HookEvent("charger_carry_end", Event_ChargerCarryEnd, EventHookMode_Post);
		HookEvent("charger_impact", Event_ChargerImpact, EventHookMode_Post);
		HookEvent("tongue_grab", Event_SmokerTongueStart, EventHookMode_Post);
		HookEvent("tongue_release", Event_SmokerTongueEnd, EventHookMode_Post);
		HookEvent("jockey_ride", Event_JockeyRideStart, EventHookMode_Post);
		HookEvent("jockey_ride_end", Event_JockeyRideEnd, EventHookMode_Post);
		HookEvent("player_death", Event_PlayerDeath, EventHookMode_Post);
	}
}

public OnMapEnd()
{
	if (mapHasExploitPlanes)
	{
		UnhookEvent("player_team", Event_PlayerTeam, EventHookMode_Pre);
		UnhookEvent("charger_carry_start", Event_ChargerCarryStart, EventHookMode_Post);
		UnhookEvent("charger_carry_end", Event_ChargerCarryEnd, EventHookMode_Post);
		UnhookEvent("charger_impact", Event_ChargerImpact, EventHookMode_Post);
		UnhookEvent("tongue_grab", Event_SmokerTongueStart, EventHookMode_Post);
		UnhookEvent("tongue_release", Event_SmokerTongueEnd, EventHookMode_Post);
		UnhookEvent("jockey_ride", Event_JockeyRideStart, EventHookMode_Post);
		UnhookEvent("jockey_ride_end", Event_JockeyRideEnd, EventHookMode_Post);
		UnhookEvent("player_death", Event_PlayerDeath, EventHookMode_Post);
	}

	mapHasExploitPlanes = false;

	if (positionDisplayTimer != INVALID_HANDLE)
	{
		KillTimer(positionDisplayTimer);
		positionDisplayTimer = INVALID_HANDLE;
	}
}

public OnGameFrame()
{
	if (mapHasExploitPlanes || DEBUG == 1)
	{
		for (new i = 1; i <= MaxClients; i++)
		{
			// Client must be in-game, not a bot, on the survivor team and alive for position data to be recorded
			if (IsClientInGame(i) && !IsFakeClient(i) && TeamType:GetClientTeam(i) == TeamType:Survivor && IsPlayerAlive(i))
			{
				GetClientEyePosition(i, position);
				
				if (isPunishmentEnabled && isGameModeVersus && clientNeedsAnnouncement[i])
				{
					// Player has recently loaded; see if they have moved far enough to trigger the plugin announcement
					new Float:distanceSquared = ((position[X_COORD] - clientInitialPosition[i][X_COORD]) * (position[X_COORD] - clientInitialPosition[i][X_COORD])) + 
					                            ((position[Y_COORD] - clientInitialPosition[i][Y_COORD]) * (position[Y_COORD] - clientInitialPosition[i][Y_COORD])) + 
					                            ((position[Z_COORD] - clientInitialPosition[i][Z_COORD]) * (position[Z_COORD] - clientInitialPosition[i][Z_COORD]));
					if (distanceSquared > DETECTED_MOVE_DIST_SQUARED)
					{
						clientNeedsAnnouncement[i] = false;
						CreateTimer(POST_MOVE_ANNOUNCE_DELAY, AnnouncePlugin, i);
					}
				}
				
				// Check if the current client needs to be checked for exploits
				if (isPunishmentEnabled && isGameModeVersus && isClientPositionSet[i] && !isClientBeingCharged[i] && !wasClientHitByCharger[i] && !isClientBeingSmoked[i] && !isClientBeingJockied[i] && GetEntityMoveType(i) != MoveType:MOVETYPE_NOCLIP)
				{
					for (new j = 0; j < numExploitPlanes; j++)
					{
						// Exploit planes only take effect when going downwards through them
						if ((clientPosition[i][Z_COORD] >= exploitPlanes[j] && position[Z_COORD] < exploitPlanes[j]))
						{
							// Make sure they didn't pass through an exception area (like stairs)
							new bool:passedThroughException = false;
							for (new k = 0; k < numExploitPlaneExceptions[j]; k++)
							{
								if (clientPosition[i][X_COORD] >= exploitPlaneExceptions[j][k][X_MIN] &&
									clientPosition[i][X_COORD] <= exploitPlaneExceptions[j][k][X_MAX] &&
									clientPosition[i][Y_COORD] >= exploitPlaneExceptions[j][k][Y_MIN] &&
									clientPosition[i][Y_COORD] <= exploitPlaneExceptions[j][k][Y_MAX])
								{
									passedThroughException = true;
									break;
								}
							}

							if (passedThroughException)
							{
								//PrintToChat(i, "[SM] Passed through exception");
							}
							else
							{
								//PrintToChat(i, "[SM] Passed through exploit plane");
								
								new Handle:pack;

								decl String:clientName[MAX_NAME_LENGTH];
								decl String:steamID[STEAM_ID_LEN];

								new bool:clientNameRetrieved = GetClientName(i, clientName, MAX_NAME_LENGTH);
								if (!clientNameRetrieved)
								{
									clientName = "<unnamed>";
								}

								new bool:clientIsImmuneAdmin = (GetUserAdmin(i) != INVALID_ADMIN_ID && GetConVarInt(cvarImmunity) == 1);

								new bool:success = GetClientAuthString(i, steamID, sizeof(steamID));
								if (success && clientPunishmentTimers[i] == INVALID_HANDLE && !clientIsImmuneAdmin)
								{
									isClientFallEligible[i] = true;
									clientPunishmentTimers[i] = CreateDataTimer(6.0, PunishExploiter, pack);
									WritePackCell(pack, GetClientUserId(i));
									
									// Write client's position before exploit
									WritePackFloat(pack, clientPosition[i][X_COORD]);
									WritePackFloat(pack, clientPosition[i][Y_COORD]);
									WritePackFloat(pack, clientPosition[i][Z_COORD]);

									// Write client's current position
									WritePackFloat(pack, position[X_COORD]);
									WritePackFloat(pack, position[Y_COORD]);
									WritePackFloat(pack, position[Z_COORD]);

									// Write exploit plane's Z-coord
									WritePackFloat(pack, exploitPlanes[j]);

									WritePackString(pack, clientName);
									WritePackString(pack, steamID);
								}
							}
							break;
						}
					}
				}

				if (isClientFallEligible[i] && (clientPosition[i][Z_COORD] - position[Z_COORD]) <= 0 &&
					(FloatAbs(clientPosition[i][X_COORD] - position[X_COORD]) > 0 || FloatAbs(clientPosition[i][Y_COORD] - position[Y_COORD]) > 0))
				{
					isClientFallEligible[i] = false;
				}

				// Update client position to current position
				clientPosition[i][X_COORD] = position[X_COORD];
				clientPosition[i][Y_COORD] = position[Y_COORD];
				clientPosition[i][Z_COORD] = position[Z_COORD];

				// If client just loaded in on survivors, set their initial position (for determining when to send them the plugin announcement)
				if (!isClientPositionSet[i] && TeamType:GetClientTeam(i) == TeamType:Survivor)
				{
					clientNeedsAnnouncement[i] = true;
					clientInitialPosition[i][X_COORD] = position[X_COORD];
					clientInitialPosition[i][Y_COORD] = position[Y_COORD];
					clientInitialPosition[i][Z_COORD] = position[Z_COORD];
				}

				isClientPositionSet[i] = true;
			}
		}
	}
}

public OnClientDisconnect_Post(client)
{
	if (client > 0 && client < MAX_CLIENTS_PLUS_ONE)
	{
		isClientPositionSet[client] = false;
		isClientBeingCharged[client] = false;
		isClientBeingJockied[client] = false;
		isClientBeingSmoked[client] = false;
		wasClientHitByCharger[client] = false;
		clientNeedsAnnouncement[client] = false;
	}
}

public OnCvarEnabledChanged(Handle:cvar, const String:oldVal[], const String:newVal[])
{
	if (StringToInt(newVal) == 0)
	{
		isPunishmentEnabled = false;
	}
	else
	{
		isPunishmentEnabled = true;
	}
}

public OnCvarGamemodeChanged(Handle:cvar, const String:oldVal[], const String:newVal[])
{
    if (StrEqual(newVal, "versus") || StrEqual(newVal, "teamversus") || StrEqual(newVal, "mutation12"))
    {
        isGameModeVersus = true;
    }
	else
	{
		isGameModeVersus = false;
	}
}

public OnPluginStart()
{
	cvarEnabled = CreateConVar("mapexploitdetector_enabled", "1", "Determines if punishments will be applied or not", FCVAR_PLUGIN);
	cvarBanTime = CreateConVar("mapexploitdetector_bantime", "3600", "Number of seconds to ban exploiters; 0 means permanently", FCVAR_PLUGIN);
	cvarShowBanMessage = CreateConVar("mapexploitdetector_banmessage", "1", "Determines who sees the message when a player is banned. If 1, all players; if 2, only admins; if 0, nobody.", FCVAR_PLUGIN);
	cvarAnnounce = CreateConVar("mapexploitdetector_announce", "1", "Determines if the plugin will be announced to players as they load in", FCVAR_PLUGIN);
	cvarImmunity = CreateConVar("mapexploitdetector_immunity", "1", "Determines if admins are immune to punishment", FCVAR_PLUGIN);

	AutoExecConfig(true, "mapexploitdetector");

	CreateConVar("mapexploitdetector_ver", VERSION, "Version of map exploit detector plugin", FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY|FCVAR_DONTRECORD);

	new Handle:cvarGamemode = FindConVar("mp_gamemode");
	HookConVarChange(cvarEnabled, OnCvarEnabledChanged);
	HookConVarChange(cvarGamemode, OnCvarGamemodeChanged);

	decl String:currentGamemode[32];
	GetConVarString(cvarGamemode, currentGamemode, sizeof(currentGamemode));
	OnCvarGamemodeChanged(cvarGamemode, currentGamemode, currentGamemode);

	RegAdminCmd("sm_mapexploitmenu", Command_MapExploitMenu, ADMFLAG_GENERIC);

	RegConsoleCmd("sm_mapexploits", Command_ListMapExploits);

	kvMapExploits = CreateKeyValues("MapExploits");
	new bool:success = FileToKeyValues(kvMapExploits, "addons/sourcemod/data/mapexploitdetector.txt");

	if (success)
	{
#if DEBUG
		PrintToServer("[SM] (Map Exploit Detector): Map exploit file opened successfully");
#endif	
	}
	else
	{
		PrintToServer("[SM] (Map Exploit Detector): Unable to open file 'addons/sourcemod/data/mapexploitdetector.txt'");
	}

	for (new i = 1; i < MAX_CLIENTS_PLUS_ONE; i++)
	{
		clientPunishmentTimers[i] = INVALID_HANDLE;
	}

	for (new i = 1; i < MAX_RECENT_BANS; i++)
	{
		recentBans[i] = INVALID_HANDLE;
	}

	recentBansStartIndex = 0;
	numRecentBans = 0;

	HookEvent("round_start", Event_RoundChange);
	//HookEvent("round_end", Event_RoundChange);
}

//
// Command handlers
//

public Action:Command_MapExploitMenu(client, args)
{
	if (client > 0 && IsClientInGame(client) && !IsFakeClient(client))
	{
		new Handle:mapExploitMenu = CreateMenu(MapExploitMenuHandler);
		SetMenuTitle(mapExploitMenu, "Map Exploit Detector");
		if (isPunishmentEnabled)
		{
			AddMenuItem(mapExploitMenu, ADMIN_MENU_DETECTION_DISABLE, "Disable exploit punishment");
		}
		else
		{
			AddMenuItem(mapExploitMenu, ADMIN_MENU_DETECTION_ENABLE, "Enable exploit punishment");
		}
		AddMenuItem(mapExploitMenu, ADMIN_MENU_UNBAN, "Un-ban players");
		AddMenuItem(mapExploitMenu, ADMIN_MENU_DESCRIPTIONS, "List this map's exploits");
		SetMenuExitButton(mapExploitMenu, true);
		DisplayMenu(mapExploitMenu, client, ADMIN_MENU_TIMEOUT);
	}

	return Plugin_Handled;
}

public Action:Command_ListMapExploits(client, args)
{
	if (isGameModeVersus)
	{
		if (mapHasExploitPlanes)
		{
			new bool:descriptionFound = false;
			new bool:mapWithoutDescriptionFound = false;
			for (new i = 0; i < numExploitPlanes; i++)
			{
				if (strcmp(exploitDescriptions[i], "") != 0)
				{
					if (!descriptionFound)
					{
						if (client == 0)
						{
							PrintToServer("[SM] Bannable map exploits:");
						}
						else
						{
							PrintToChat(client, "\x01[SM] \x04Bannable map exploits:");
						}
						descriptionFound = true;
					}
					if (client == 0)
					{
						PrintToServer("  * %s", exploitDescriptions[i]);
					}
					else
					{
						PrintToChat(client, "\x05  * %s", exploitDescriptions[i]);
					}
				}
				else
				{
					mapWithoutDescriptionFound = true;
				}
			}
	
			if (!descriptionFound)
			{
				ReplyToCommand(client, "[SM] This map has exploits listed, but none have descriptions.");
			}
			else if (mapWithoutDescriptionFound)
			{
				if (client == 0)
				{
					PrintToServer("NOTE: The above list is not complete; some exploits have no description.");
				}
				else
				{
					PrintToChat(client, "\x04NOTE:\x01 The above list is not complete; some exploits have no description.");
				}
			}
		}
		else
		{
			ReplyToCommand(client, "[SM] There are no exploits listed for this map.");
		}
	} else {
		ReplyToCommand(client, "[SM] Map exploit bans only apply in Versus, Team Versus and Realism Versus.");
	}

	return Plugin_Handled;
}

//
// Menu handlers and functions
//

public MapExploitMenuHandler(Handle:menu, MenuAction:action, param1, param2)
{
	if (action == MenuAction_Select)
	{
		new String:menuCommand[8];
		new bool:found = GetMenuItem(menu, param2, menuCommand, sizeof(menuCommand));
		
		if (found)
		{
			if (strcmp(menuCommand, ADMIN_MENU_UNBAN) == 0)
			{
				ShowUnBanMenu(Handle:INVALID_HANDLE, any:param1);
			}
			else if (strcmp(menuCommand, ADMIN_MENU_DETECTION_DISABLE) == 0)
			{
				SetConVarInt(cvarEnabled, 0);
				if (param1 > 0)
				{
					PrintToChat(param1, "[SM] Map exploit detector disabled");
				}
			}
			else if (strcmp(menuCommand, ADMIN_MENU_DETECTION_ENABLE) == 0)
			{
				SetConVarInt(cvarEnabled, 1);
				if (param1 > 0)
				{
					PrintToChat(param1, "[SM] Map exploit detector enabled");
				}
			}
			else if (strcmp(menuCommand, ADMIN_MENU_DESCRIPTIONS) == 0)
			{
				Command_ListMapExploits(param1, 0);
			}
		}
	}
	else if (action == MenuAction_End)
	{
		CloseHandle(menu);
	}
}

public Action:ShowUnBanMenu(Handle:timer, any:client)
{
	if (numRecentBans == 0)
	{
		PrintToChat(client, "[SM] No players have been banned by the Map Exploit Detector plugin since it was last loaded.");
	}
	else
	{
		new Handle:unBanMenu = CreateMenu(UnBanMenuHandler);
		SetMenuTitle(unBanMenu, "Un-ban player");

		decl String:steamID[STEAM_ID_LEN];
		decl String:clientName[MAX_NAME_LENGTH];
		new banIndex = ((recentBansStartIndex + numRecentBans) - 1) % MAX_RECENT_BANS;
		for (new i = 0; i < numRecentBans; i++)
		{
			if (recentBans[banIndex] != INVALID_HANDLE)
			{
				steamID[0] = '\0';
				clientName[0] = '\0';
				ResetPack(recentBans[banIndex]);
				ReadPackString(recentBans[banIndex], steamID, STEAM_ID_LEN);
				ReadPackString(recentBans[banIndex], clientName, MAX_NAME_LENGTH);

				AddMenuItem(unBanMenu, steamID, clientName);
			}
	
			banIndex = (banIndex + 1) % MAX_RECENT_BANS;
		}
		SetMenuExitButton(unBanMenu, true);
		
		DisplayMenu(unBanMenu, client, ADMIN_MENU_TIMEOUT);
	}
}

public UnBanMenuHandler(Handle:menu, MenuAction:action, param1, param2)
{
	if (action == MenuAction_Select)
	{
		new String:steamID[STEAM_ID_LEN];
		new bool:found = GetMenuItem(menu, param2, steamID, STEAM_ID_LEN);
		
		if (found)
		{
			new bool:unBanSuccess = RemoveBan(steamID, BANFLAG_AUTHID);
			if (unBanSuccess)
			{
				PrintToChat(param1, "[SM] Player un-banned");
			}
		}
	}
	else if (action == MenuAction_End)
	{
		CloseHandle(menu);
	}
}

//
// Events and timer handlers
//

public Action:Event_RoundChange(Handle:event, const String:name[], bool:dontBroadcast)
{
	for (new i = 1; i < MAX_CLIENTS_PLUS_ONE; i++)
	{
		if (clientPunishmentTimers[i] != INVALID_HANDLE)
		{
			CloseHandle(clientPunishmentTimers[i]);
			clientPunishmentTimers[i] = INVALID_HANDLE;
		}
	}
}

public Action:Event_PlayerTeam(Handle:event, const String:name[], bool:dontBroadcast)
{
	new userId = GetEventInt(event, "victim");
	new client = GetClientOfUserId(userId);
	if (client > 0 && client < MAX_CLIENTS_PLUS_ONE)
	{
		isClientPositionSet[client] = false;
	}

	return Plugin_Continue;
}


public Action:Event_ChargerCarryStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));

	if (client > 0 && IsClientInGame(client))
	{
		isClientBeingCharged[client] = true;
	}
}

public Action:Event_ChargerImpact(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));

	if (client > 0 && IsClientInGame(client))
	{
		wasClientHitByCharger[client] = true;
		CreateTimer(CHARGE_HIT_EXCEPTION_TIME, ChargerImpactExceptionEnd, client);
	}
}

public Action:ChargerImpactExceptionEnd(Handle:timer, any:client)
{
	wasClientHitByCharger[client] = false;
}

public Action:Event_ChargerCarryEnd(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));

	if (client > 0 && IsClientInGame(client))
	{
		isClientBeingCharged[client] = false;
	}
}

public Action:Event_SmokerTongueStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));

	if (client > 0 && IsClientInGame(client))
	{
		isClientBeingSmoked[client] = true;
	}
}

public Action:Event_SmokerTongueEnd(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));

	if (client > 0 && IsClientInGame(client))
	{
		isClientBeingSmoked[client] = false;
	}
}

public Action:Event_JockeyRideStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));

	if (client > 0 && IsClientInGame(client))
	{
		isClientBeingJockied[client] = true;
	}
}

public Action:Event_JockeyRideEnd(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));

	if (client > 0 && IsClientInGame(client))
	{
		isClientBeingJockied[client] = false;
	}
}

public Action:Event_PlayerDeath(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new damageType = GetEventInt(event, "type");
	
	if (client > 0 && (damageType & DMG_FALL) == DMG_FALL && TeamType:GetClientTeam(client) == TeamType:Survivor && isClientFallEligible[client])
	{
		if (clientPunishmentTimers[client] != INVALID_HANDLE)
		{
			CloseHandle(clientPunishmentTimers[client]);
			clientPunishmentTimers[client] = INVALID_HANDLE;
		}
	}
}

public Action:AnnouncePlugin(Handle:timer, any:client)
{
	if (client > 0 && IsClientInGame(client) && !IsFakeClient(client) && GetConVarInt(cvarAnnounce) == 1)
	{
		PrintToChat(client, "\x01[SM] Players who use map exploits will be \x04automatically banned\x01. For a list of this map's bannable exploits, enter \x04!mapexploits\x01 in chat.");
	}
}

public Action:PunishExploiter(Handle:timer, Handle:pack)
{
	decl String:clientName[MAX_NAME_LENGTH];
	decl String:steamID[STEAM_ID_LEN];

	ResetPack(pack);
	new userId = ReadPackCell(pack);
	new client = GetClientOfUserId(userId);

	new Float:positionPreExploit[3];
	new Float:positionPostExploit[3];
	new Float:exploitPlaneHit;

	// Client's position before exploit
	positionPreExploit[X_COORD] = ReadPackFloat(pack);
	positionPreExploit[Y_COORD] = ReadPackFloat(pack);
	positionPreExploit[Z_COORD] = ReadPackFloat(pack);

	// Client's position after exploit
	positionPostExploit[X_COORD] = ReadPackFloat(pack);
	positionPostExploit[Y_COORD] = ReadPackFloat(pack);
	positionPostExploit[Z_COORD] = ReadPackFloat(pack);

	// Exploit plane's Z-coord
	exploitPlaneHit = ReadPackFloat(pack);

	ReadPackString(pack, clientName, sizeof(clientName));
	ReadPackString(pack, steamID, sizeof(steamID));

	new banTime = GetConVarInt(cvarBanTime);
	new showBanMessage = GetConVarInt(cvarShowBanMessage);

	new bool:banSuccess = BanIdentity(steamID, banTime, BANFLAG_AUTHID, "Map Exploit");

	if (banSuccess)
	{
		decl String:message[128];
		Format(message, 128, "\x01[SM] \x04%s\x01 has been automatically banned for using a map exploit.", clientName);
		if (showBanMessage == 1)
		{
			PrintToChatAll(message);
		}
		else if (showBanMessage == 2)
		{
			SendMessageToAdmins(message);
		}

		// Write ban to file
		
		new Handle:banFile = OpenFile(BAN_FILE, "a");
		decl String:timestamp[32];
		FormatTime(timestamp, sizeof(timestamp), NULL_STRING);

		if (banFile != INVALID_HANDLE)
		{
			WriteFileLine(banFile, "%s %s '%s' PRE: %f %f %f POST: %f %f %f PLANE: %f", timestamp, steamID, clientName, positionPreExploit[X_COORD], positionPreExploit[Y_COORD], positionPreExploit[Z_COORD], positionPostExploit[X_COORD], positionPostExploit[Y_COORD], positionPostExploit[Z_COORD], exploitPlaneHit);
			FlushFile(banFile);
			CloseHandle(banFile);
		}

		new Handle:banData = CreateDataPack();
		WritePackString(banData, steamID);
		WritePackString(banData, clientName);

		// Save to recent ban data
		
		new recentBanNextIndex = (recentBansStartIndex + numRecentBans) % MAX_RECENT_BANS;
		if (recentBans[recentBanNextIndex] != INVALID_HANDLE)
		{
			CloseHandle(recentBans[recentBanNextIndex]);
		}

		if (numRecentBans >= MAX_RECENT_BANS)
		{
			recentBansStartIndex = (recentBansStartIndex + 1) % MAX_RECENT_BANS;
		}

		recentBans[recentBanNextIndex] = banData;

		numRecentBans++;
		if (numRecentBans > MAX_RECENT_BANS)
		{
			numRecentBans = MAX_RECENT_BANS;
		}
	}

	if (client > 0)
	{
		if (banSuccess && IsClientConnected(client))
		{
			KickClient(client, "Automatically banned for using a map exploit");
		}

		clientPunishmentTimers[client] = INVALID_HANDLE;
	}
}

#if DEBUG
public Action:DisplayPosition(Handle:timer)
{
	for (new i = 1; i <= MaxClients; i++)
	{
		if (IsClientInGame(i) && !IsFakeClient(i) && TeamType:GetClientTeam(i) == TeamType:Survivor)
		{
			PrintToChat(i, "[SM] Position: %f %f %f", clientPosition[i][X_COORD], clientPosition[i][Y_COORD], clientPosition[i][Z_COORD]);
		}
	}

	return Plugin_Continue;
}
#endif

//
// Utility functions
//

SendMessageToAdmins(String:message[])
{
	for (new i = 1; i <= MaxClients; i++)
	{
		if (IsClientInGame(i) && !IsFakeClient(i) && IsClientAuthorized(i))
		{
			new AdminId:adminId = GetUserAdmin(i);
			if (adminId != INVALID_ADMIN_ID)
			{
				if (GetAdminFlag(adminId, AdminFlag:ADMFLAG_GENERIC))
				{
					PrintToChat(i, message);
				}
			}
		}
	}
}
