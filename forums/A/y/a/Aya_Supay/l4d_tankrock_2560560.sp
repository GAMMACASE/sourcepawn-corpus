/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#include <sourcemod>
#include <sdktools>
#pragma newdecls required

ConVar l4d_rock_fire;
ConVar l4d_rock_explosive_burning;
ConVar l4d_rock_explosive_normal;
ConVar l4d_rock_explosive_damage;
ConVar l4d_rock_explosive_radius;
ConVar l4d_rock_explosive_pushforce;

public Plugin myinfo = 
{
	name = "tank's burning rock",
	author = "Pan Xiaohai edited by [†×Ą]AYA SUPAY[Ļ×Ø]",
	description = "tank's burning rock",
	version = "1.0",
	url = "<- URL ->"
}

int tank=0;
bool tankthrow=false;
bool rockimpact=false;

public void OnPluginStart()
{
	l4d_rock_fire = CreateConVar("l4d_rock_fire", "1", "0:disable , 1:burning tank throws burning rock, 2:always throw burning rock", FCVAR_PLUGIN);
	l4d_rock_explosive_burning = CreateConVar("l4d_rock_explosive_chance_burning", "30.0", "burning rock explode chance [0.0, 100.0]", FCVAR_PLUGIN);
	l4d_rock_explosive_normal = CreateConVar("l4d_rock_explosive_chance_normal", "20.0", "normal rock explode chance [0.0, 100.0]", FCVAR_PLUGIN);
	l4d_rock_explosive_damage = CreateConVar("l4d_rock_explosive_damage", "20.0", "[0.0, 100.0]", FCVAR_PLUGIN);
	l4d_rock_explosive_radius = CreateConVar("l4d_rock_explosive_radius", "150.0", "[0.0, 500.0]", FCVAR_PLUGIN);
	l4d_rock_explosive_pushforce = CreateConVar("l4d_rock_explosive_pushforce", "700.0", "[0.0, 2000.0]", FCVAR_PLUGIN);

	AutoExecConfig(true, "l4d_tankrock");
	
	HookEvent("round_start", round_end);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition", round_end);
	HookEvent("ability_use", ability_use);
	tankthrow=false;
	rockimpact=false;
	tank=0;
}

public void OnMapStart()
{
	PrecacheModel("models/props_junk/propanecanister001a.mdl", true);
	PrecacheModel("models/props_junk/gascan001a.mdl", true);
	 
	PrecacheParticle("gas_explosion_pump");
}

public Action round_end(Event event, const char[] name, bool dontBroadcast)
{
	tankthrow=false;
	rockimpact=false;
	tank=0;
}
public Action ability_use(Event event, const char[] name, bool dontBroadcast)
{
	char s[32];
	GetEventString(event, "ability", s, 32);

	if(StrEqual(s, "ability_throw", true))
	{
		tankthrow=true;
		tank = GetClientOfUserId(GetEventInt(event, "userid"));
	}
}

public void OnEntityCreated(int entity, const char[] classname)
{
	if(!tankthrow)return;
	if(StrEqual(classname, "tank_rock", true))
	{
		tankthrow=false;
		if(IsValidEntity(entity) && IsValidEdict(entity))
		{
			int team=GetEntProp(entity, Prop_Send, "m_iTeamNum");
			if(team>=0)
			{
				//PrintToChatAll("%d", GetEntProp(entity, Prop_Send, "m_iTeamNum"));
				int mode=GetConVarInt(l4d_rock_fire);
				if(mode==2)
				{
					IgniteEntity(entity, 100.0);
				}
				else if(mode==1)
				{
					if(tank>0 && tank<=MaxClients)
					{
						if(IsClientInGame(tank) && IsPlayerAlive(tank))
						{
							if(GetEntityFlags(tank) & FL_ONFIRE)
							{
								IgniteEntity(entity, 100.0);
							}
						}
					}
				}
				rockimpact=true;
			}
		}
	}
}

public void OnEntityDestroyed(int entity)
{
	if(!rockimpact || !IsValidEntity(entity) || !IsValidEdict(entity))return;
	char g_classname[20];
	GetEdictClassname(entity, g_classname, 20);
	if(StrEqual(g_classname, "tank_rock", true) && GetEntProp(entity, Prop_Send, "m_iTeamNum")>=0)
	{
		ConVar chance=l4d_rock_explosive_normal;
		if(GetEntityFlags(entity) & FL_ONFIRE)chance=l4d_rock_explosive_burning;
		if(GetRandomFloat(0.0,100.0)<GetConVarFloat(chance))
		{
			int ent1 = 0;
			int ent2 = 0;
			int ent3 = 0;
			float pos[3];
			GetEntPropVector(entity, Prop_Send, "m_vecOrigin", pos);
			
			ent1=CreateEntityByName("prop_physics"); 
			
			DispatchKeyValue(ent1, "model", "models/props_junk/propanecanister001a.mdl"); 
			DispatchSpawn(ent1); 
			TeleportEntity(ent1, pos, NULL_VECTOR, NULL_VECTOR);
			ActivateEntity(ent1);
			SetEntityRenderMode(ent1, view_as<RenderMode> 3);
			SetEntityRenderColor(ent1, 0, 0, 0, 0);
			AcceptEntityInput(ent1, "Ignite", -1, -1);
			
			float damage=GetConVarFloat(l4d_rock_explosive_damage);
			float radius=GetConVarFloat(l4d_rock_explosive_radius);
			float pushforce=GetConVarFloat(l4d_rock_explosive_pushforce);
			
			Handle h=CreateDataPack();
			WritePackCell(h, -1);
			WritePackCell(h, ent1);
			WritePackCell(h, ent2);
			WritePackCell(h, ent3);

			WritePackFloat(h, pos[0]);
			WritePackFloat(h, pos[1]);
			WritePackFloat(h, pos[2]);

			WritePackFloat(h, damage);
			WritePackFloat(h, radius);
			WritePackFloat(h, pushforce);

			Explode2(null, h);
		}
		rockimpact=false;
	}
}

public Action Explode2(Handle timer, Handle h)
{
	ResetPack(h);
	int userid=ReadPackCell(h);
	int ent1=ReadPackCell(h);
	int ent2=ReadPackCell(h);
	int ent3=ReadPackCell(h);

	float pos[3];
	pos[0]=ReadPackFloat(h);
	pos[1]=ReadPackFloat(h);
	pos[2]=ReadPackFloat(h);
	float damage=ReadPackFloat(h);
	float radius=ReadPackFloat(h);
	float force=ReadPackFloat(h);
	CloseHandle(h);
	
	if(ent1>0 && IsValidEntity(ent1))
	{
		AcceptEntityInput(ent1, "break", userid);
		RemoveEdict(ent1);
		if(ent2>0 && IsValidEntity(ent2))
		{
			AcceptEntityInput(ent2, "break",  userid);
			RemoveEdict(ent2);
		}
		if(ent3>0 && IsValidEntity(ent3))
		{
			AcceptEntityInput(ent3, "break",  userid);
			RemoveEdict(ent3);
		}
	}
	ShowParticle(pos, "gas_explosion_pump", 3.0);
	int pointHurt = CreateEntityByName("point_hurt");
	
	DispatchKeyValueFloat(pointHurt, "Damage", damage);
	DispatchKeyValueFloat(pointHurt, "DamageRadius", radius); 
	DispatchKeyValue(pointHurt, "DamageDelay", "0.0");
	DispatchSpawn(pointHurt);
	TeleportEntity(pointHurt, pos, NULL_VECTOR, NULL_VECTOR);
	AcceptEntityInput(pointHurt, "Hurt", userid);
	CreateTimer(0.1, DeletePointHurt, pointHurt); 
	
	int push = CreateEntityByName("point_push");
	DispatchKeyValueFloat (push, "magnitude", force);
	DispatchKeyValueFloat (push, "radius", radius*1.0);
	SetVariantString("spawnflags 24");
	AcceptEntityInput(push, "AddOutput");
	DispatchSpawn(push);   
	TeleportEntity(push, pos, NULL_VECTOR, NULL_VECTOR);
	AcceptEntityInput(push, "Enable", userid, userid);
	CreateTimer(0.5, DeletePushForce, push);
	return;
}

public void ShowParticle(float pos[3], char[] particlename, float time)
{
	int particle = CreateEntityByName("info_particle_system");
	if (IsValidEntity(particle))
	{
		TeleportEntity(particle, pos, NULL_VECTOR, NULL_VECTOR);
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(time, DeleteParticles, particle);
	}
}

public void PrecacheParticle(char[] particlename)
{
	int particle = CreateEntityByName("info_particle_system");
	if (IsValidEntity(particle))
	{
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(0.01, DeleteParticles, particle);
	}
}

public Action DeleteParticles(Handle timer, any particle)
{
	if (IsValidEntity(particle))
	{
		char classname[64];
		GetEdictClassname(particle, classname, sizeof(classname));
		if (StrEqual(classname, "info_particle_system", false))
		{
			AcceptEntityInput(particle, "stop");
			AcceptEntityInput(particle, "kill");
			RemoveEdict(particle);
		}
	}
}

public Action DeletePointHurt(Handle timer, any ent)
{
	if (IsValidEntity(ent))
	{
		char classname[64];
		GetEdictClassname(ent, classname, sizeof(classname));
		if (StrEqual(classname, "point_hurt", false))
		{
			AcceptEntityInput(ent, "Kill"); 
			RemoveEdict(ent);
		}
	}
}

public Action DeletePushForce(Handle timer, any ent)
{
	if (IsValidEntity(ent))
	{
		char classname[64];
		GetEdictClassname(ent, classname, sizeof(classname));
		if (StrEqual(classname, "point_push", false))
		{
			AcceptEntityInput(ent, "Disable");
			AcceptEntityInput(ent, "Kill"); 
			RemoveEdict(ent);
		}
	}
}