/* Plugin Template generated by Pawn Studio */
#pragma newdecls required

#include <sourcemod>
#include <sdktools>
#include <topmenus>
#include <menus>

#undef REQUIRE_PLUGIN
#include <adminmenu>
#define REQUIRE_PLUGIN

#define PL_VERSION		"0.6"

#define CVAR_VERSION		0
#define CVAR_DISCO			1
#define NUM_CVARS			2

int g_numbers[] = {0, 40, 80, 120, 160, 200, 240, 255};
bool g_disco = false;
bool g_lightson = true;
ConVar g_cvars[NUM_CVARS];
TopMenu g_adminMenu;

public Plugin myinfo =
{
	name = "Light Colors",
	author = "Jindo",
	description = "Adjust lights in a map.",
	version = PL_VERSION,
	url = "http://www.topaz-games.com/"
}

public void OnPluginStart()
{
	LoadTranslations("core.phrases");
	LoadTranslations("lightcolors.phrases");
	
	g_cvars[CVAR_VERSION] = CreateConVar("lights_version", PL_VERSION, "Version of the Light Colours plugin.", FCVAR_NOTIFY);
	g_cvars[CVAR_DISCO] = CreateConVar("lights_disco_enable", "0", "Automatically enable Disco Mode.");
	
	RegAdminCmd("lights_color", Command_AllLightsColor, ADMFLAG_ROOT);
	RegAdminCmd("lights_disco", Command_AllLightsDisco, ADMFLAG_ROOT);
	RegAdminCmd("lights_reset", Command_AllLightsReset, ADMFLAG_ROOT);
	RegAdminCmd("lights_switch", Command_AllLightsSwitch, ADMFLAG_ROOT);
	RegAdminCmd("lights_help", Command_LightsHelp, ADMFLAG_ROOT);
	
	TopMenu topMenu;
	
	if (LibraryExists("adminmenu") && ((topMenu = GetAdminTopMenu()) != INVALID_HANDLE))
	{
		OnAdminMenuReady(topMenu);
	}
	
	g_cvars[CVAR_DISCO].AddChangeHook(OnDiscoChanged);
}

public void OnEntityCreated(int entity, const char[] classname)
{
	if (StrEqual(classname, "point_spotlight"))
	{
		/**
		 * 2022-07-29 now removes spotlights that don't have a targetname / parentname assigned.
		 * We attach one here to prevent it from being removed - this will be overwritten by the
		 * map if it supplies its own targetname.
		 */
		DispatchKeyValue(entity, "targetname", "lightColorsNoDelete");
	}
}

Action Command_AllLightsColor(int client, int args)
{
	g_lightson = true;
	g_disco = false;
	
	char color[64];
	if (args < 1)
	{
		color = "random";
	}
	else
	{
		GetCmdArg(1, color, sizeof(color));
	}
	
	// we can't hoist the color selection here since a random color may be produced
	int ent = -1;
	while ((ent = FindEntRefByClassname(ent, "point_spotlight")) != -1)
	{
		char color2[64];
		GetColorFromInt(GetIntFromColor(color), color2, sizeof(color2));
		AcceptEntityInput(ent, "LightOff");
		DispatchKeyValue(ent, "rendercolor", color2);
		CreateTimer(0.25, Timer_TurnLightOn, ent, TIMER_FLAG_NO_MAPCHANGE);
	}
	char color3[64];
	GetNameFromColor(GetIntFromColor(color), color3, sizeof(color3));
	ReplyToCommand(client, "[SM] %t", "Lights Changed", color3);
	return Plugin_Handled;
}

Action Timer_TurnLightOn(Handle timer, any ent)
{
	if (IsValidEntity(ent))
	{
		AcceptEntityInput(ent, "LightOn");
	}
	return Plugin_Handled;
}

Action Command_AllLightsDisco(int client, int args)
{
	if (g_disco)
	{
		g_disco = false;
		ReplyToCommand(client, "[SM] %t", "Disco Off");
	}
	else
	{
		g_lightson = true;
		StartDiscoEffect();
		ReplyToCommand(client, "[SM] %t", "Disco On");
	}
	return Plugin_Handled;
}

Action Timer_TurnLightOnDisco(Handle timer, any ent)
{
	if (IsValidEntity(ent))
	{
		AcceptEntityInput(ent, "LightOn");
		float time = GetRandomFloat(0.25, 0.75);
		CreateTimer(time, Timer_ChangeLightDisco, ent, TIMER_FLAG_NO_MAPCHANGE);
	}
	return Plugin_Handled;
}

Action Timer_ChangeLightDisco(Handle timer, any ent)
{
	if (!IsValidEntity(ent))
	{
		return Plugin_Handled;
	}
	
	if (!g_disco)
	{
		AcceptEntityInput(ent, "LightOff");
		DispatchKeyValue(ent, "rendercolor", "255 255 255");
		CreateTimer(0.25, Timer_TurnLightOn, ent, TIMER_FLAG_NO_MAPCHANGE);
	}
	else if (!IsLightVisibleToPlayers(ent))
	{
		// skip running light logic for any lights that are not visible to any player
		CreateTimer(0.25 + GetRandomFloat(0.25, 0.75), Timer_ChangeLightDisco, ent, TIMER_FLAG_NO_MAPCHANGE);
	}
	else
	{
		char color[64];
		GetColorFromInt(0, color, sizeof(color));
		AcceptEntityInput(ent, "LightOff");
		DispatchKeyValue(ent, "rendercolor", color);
		CreateTimer(0.25, Timer_TurnLightOnDisco, ent, TIMER_FLAG_NO_MAPCHANGE);
	}
	return Plugin_Handled;
}

Action Command_AllLightsReset(int client, int args)
{
	g_disco = false;
	SetGlobalLightRenderColor("255 255 255");
	ReplyToCommand(client, "[SM] %t", "Lights Reset");
	return Plugin_Handled;
}

Action Command_AllLightsSwitch(int client, int args)
{
	g_disco = false;
	int ent = -1;
	if (g_lightson)
	{
		while ((ent = FindEntRefByClassname(ent, "point_spotlight")) != -1)
		{
			AcceptEntityInput(ent, "LightOff");
		}
		ReplyToCommand(client, "[SM] %t", "Lights Off");
		g_lightson = false;
		return Plugin_Handled;
	}
	else
	{
		while ((ent = FindEntRefByClassname(ent, "point_spotlight")) != -1)
		{
			AcceptEntityInput(ent, "LightOn");
		}
		ReplyToCommand(client, "[SM] %t", "Lights On");
		g_lightson = true;
		return Plugin_Handled;
	}
}

Action Command_LightsHelp(int client, int args)
{
	char version[6];
	g_cvars[CVAR_VERSION].GetString(version, sizeof(version));
	ReplyToCommand(client, "[SM] Light Colors v%s:", version);
	ReplyToCommand(client, " ~ lights_color <c> - %t", "Help lights_color");
	ReplyToCommand(client, " ~ lights_disco - %t", "Help lights_disco");
	ReplyToCommand(client, " ~ lights_reset - %t", "Help lights_reset");
	ReplyToCommand(client, " ~ lights_switch - %t", "Help lights_switch");
	return Plugin_Handled;
}

public void OnAdminMenuReady(Handle topmenu)
{
	if (topmenu == g_adminMenu)
	{
		return;
	}

	g_adminMenu = TopMenu.FromHandle(topmenu);

	TopMenuObject serverCommands = g_adminMenu.FindCategory(ADMINMENU_SERVERCOMMANDS);
	if (serverCommands == INVALID_TOPMENUOBJECT)
	{
		return;
	}

	g_adminMenu.AddItem("lights_color", AdminMenu_LightsColor, serverCommands, "lights_color", ADMFLAG_ROOT);
	g_adminMenu.AddItem("lights_disco", AdminMenu_LightsDisco, serverCommands, "lights_disco", ADMFLAG_ROOT);
	g_adminMenu.AddItem("lights_reset", AdminMenu_LightsReset, serverCommands, "lights_reset", ADMFLAG_ROOT);
	g_adminMenu.AddItem("lights_switch", AdminMenu_LightsSwitch, serverCommands, "lights_switch", ADMFLAG_ROOT);
}

void AdminMenu_LightsColor(TopMenu topmenu, TopMenuAction action, TopMenuObject object_id, int param, char[] buffer, int maxlength)
{
	switch (action)
	{
		case TopMenuAction_DisplayOption:
		{
			Format(buffer, maxlength, "%t", "Change All Lights");
		}
		case TopMenuAction_SelectOption:
		{
			DisplayColorsMenu(param);
		}
	}
}

int DisplayColorsMenu(int client)
{
	Menu menu = new Menu(MenuHandler_LightColors);
	
	char title[100];
	char item[64];
	Format(title, sizeof(title), "%N: %t", client, "Change All Lights");
	menu.SetTitle(title);
	menu.ExitBackButton = true;
	
	Format(item, sizeof(item), "%t", "random");
	menu.AddItem("random", item);
	Format(item, sizeof(item), "%t", "red");
	menu.AddItem("red", item);
	Format(item, sizeof(item), "%t", "blue");
	menu.AddItem("blue", item);
	Format(item, sizeof(item), "%t", "green");
	menu.AddItem("green", item);
	Format(item, sizeof(item), "%t", "yellow");
	menu.AddItem("yellow", item);
	Format(item, sizeof(item), "%t", "purple");
	menu.AddItem("purple", item);
	Format(item, sizeof(item), "%t", "magenta");
	menu.AddItem("magenta", item);
	Format(item, sizeof(item), "%t", "pink");
	menu.AddItem("pink", item);
	Format(item, sizeof(item), "%t", "cyan");
	menu.AddItem("cyan", item);
	Format(item, sizeof(item), "%t", "orange");
	menu.AddItem("orange", item);
	Format(item, sizeof(item), "%t", "brown");
	menu.AddItem("brown", item);
	
	menu.Display(client, MENU_TIME_FOREVER);
}

int MenuHandler_LightColors(Menu menu, MenuAction action, int param1, int param2)
{
	
	if (action == MenuAction_End)
	{
		delete menu;
	}
	else if (action == MenuAction_Cancel)
	{
		if (param2 == MenuCancel_ExitBack && g_adminMenu != INVALID_HANDLE)
		{
			DisplayTopMenu(g_adminMenu, param1, TopMenuPosition_LastCategory);
		}
	}
	else if (action == MenuAction_Select)
	{
		char info[32];
		GetMenuItem(menu, param2, info, sizeof(info));
		
		// we can't hoist the color selection here since a random color may be produced
		g_lightson = true;
		g_disco = false;
		int ent = -1;
		while ((ent = FindEntRefByClassname(ent, "point_spotlight")) != -1)
		{
			char color2[64];
			GetColorFromInt(GetIntFromColor(info), color2, sizeof(color2));
			AcceptEntityInput(ent, "LightOff");
			DispatchKeyValue(ent, "rendercolor", color2);
			CreateTimer(0.25, Timer_TurnLightOn, ent, TIMER_FLAG_NO_MAPCHANGE);
		}
		char color3[64];
		GetNameFromColor(GetIntFromColor(info), color3, sizeof(color3));
		ReplyToCommand(param1, "[SM] %t", "Lights Changed", color3);
	}
}

void AdminMenu_LightsDisco(TopMenu topmenu, TopMenuAction action, TopMenuObject object_id, int param, char[] buffer, int maxlength)
{
	switch (action)
	{
		case TopMenuAction_DisplayOption:
		{
			Format(buffer, maxlength, "%t", "Enable Disco");
		}
		case TopMenuAction_SelectOption:
		{
			if (g_disco)
			{
				ReplyToCommand(param, "[SM] %t", "Disco Already On");
				return;
			}
			StartDiscoEffect();
			ReplyToCommand(param, "[SM] %t", "Disco On");
		}
	}
}

void AdminMenu_LightsReset(TopMenu topmenu, TopMenuAction action, TopMenuObject object_id, int param, char[] buffer, int maxlength)
{
	switch (action)
	{
		case TopMenuAction_DisplayOption:
		{
			Format(buffer, maxlength, "%t", "Reset All Lights");
		}
		case TopMenuAction_SelectOption:
		{
			g_lightson = true;
			g_disco = true; // TODO should this be false?
			SetGlobalLightRenderColor("255 255 255");
			ReplyToCommand(param, "[SM] %t", "Lights Reset");
		}
	}
}

void AdminMenu_LightsSwitch(TopMenu topmenu, TopMenuAction action, TopMenuObject object_id, int param, char[] buffer, int maxlength)
{
	switch (action)
	{
		case TopMenuAction_DisplayOption:
		{
			Format(buffer, maxlength, "%t", "Switch All Lights");
		}
		case TopMenuAction_SelectOption:
		{
			g_disco = false;
			int ent = -1;
			while ((ent = FindEntRefByClassname(ent, "point_spotlight")) != -1)
			{
				AcceptEntityInput(ent, g_lightson ? "LightOff" : "LightOn");
			}
			ReplyToCommand(param, "[SM] %t", g_lightson ? "Lights Off" : "Lights On");
			g_lightson = !g_lightson;
		}
	}
}

void OnDiscoChanged(ConVar cvar, const char[] old_value, const char[] new_value)
{
	if (StrEqual(new_value, "0"))
	{
		g_disco = false;
		return;
	}
	StartDiscoEffect();
}

stock int GetIntFromColor(const char[] color)
{
	if (StrEqual(color, "random"))		return 0;
	if (StrEqual(color, "red"))			return 1;
	if (StrEqual(color, "blue"))		return 2;
	if (StrEqual(color, "green"))		return 3;
	if (StrEqual(color, "yellow"))		return 4;
	if (StrEqual(color, "orange"))		return 5;
	if (StrEqual(color, "pink"))		return 6;
	if (StrEqual(color, "magenta"))		return 7;
	if (StrEqual(color, "purple"))		return 8;
	if (StrEqual(color, "cyan"))		return 9;
	if (StrEqual(color, "brown"))		return 10;
	return 0;
}

stock void GetNameFromColor(int value, char[] color, int color_size)
{
	switch (value)
	{
		case 0:			Format(color, color_size, "random");
		case 1:			Format(color, color_size, "red");
		case 2:			Format(color, color_size, "blue");
		case 3:			Format(color, color_size, "green");
		case 4:			Format(color, color_size, "yellow");
		case 5:			Format(color, color_size, "orange");
		case 6:			Format(color, color_size, "pink");
		case 7:			Format(color, color_size, "magenta");
		case 8:			Format(color, color_size, "purple");
		case 9:			Format(color, color_size, "cyan");
		case 10:		Format(color, color_size, "brown");
	}
}

stock void GetColorFromInt(int value, char[] color, int color_size)
{
	switch (value)
	{
		case 0:			Format(color, color_size, "%i %i %i", g_numbers[GetRandomInt(0, 7)], g_numbers[GetRandomInt(0, 7)], g_numbers[GetRandomInt(0, 7)]);
		case 1:			Format(color, color_size, "255 0 0");
		case 2:			Format(color, color_size, "0 0 255");
		case 3:			Format(color, color_size, "0 255 0");
		case 4:			Format(color, color_size, "255 255 0");
		case 5:			Format(color, color_size, "255 175 0");
		case 6:			Format(color, color_size, "255 150 150");
		case 7:			Format(color, color_size, "255 0 255");
		case 8:			Format(color, color_size, "175 0 255");
		case 9:			Format(color, color_size, "0 255 255");
		case 10:		Format(color, color_size, "150 100 0");
	}
}

public void OnMapStart()
{
	g_disco = false;
	g_lightson = true;
	if (g_cvars[CVAR_DISCO].BoolValue)
	{
		StartDiscoEffect();
	}
}

void SetGlobalLightRenderColor(const char[] color)
{
	int ent = -1;
	while ((ent = FindEntRefByClassname(ent, "point_spotlight")) != -1)
	{
		AcceptEntityInput(ent, "LightOff");
		DispatchKeyValue(ent, "rendercolor", color);
		CreateTimer(0.25, Timer_TurnLightOn, ent, TIMER_FLAG_NO_MAPCHANGE);
	}
}

void StartDiscoEffect()
{
	if (g_disco)
	{
		return;
	}
	
	g_lightson = true;
	g_disco = true;
	int ent = -1;
	while ((ent = FindEntRefByClassname(ent, "point_spotlight")) != -1)
	{
		char color[64];
		GetColorFromInt(0, color, sizeof(color));
		AcceptEntityInput(ent, "LightOff");
		DispatchKeyValue(ent, "rendercolor", color);
		CreateTimer(0.25, Timer_TurnLightOnDisco, ent, TIMER_FLAG_NO_MAPCHANGE);
	}
}

bool IsLightVisibleToPlayers(int spotlight)
{
	float origin[3];
	GetEntPropVector(spotlight, Prop_Data, "m_vecAbsOrigin", origin);
	
	int clients[1];
	return GetClientsInRange(origin, RangeType_Visibility, clients, sizeof(clients)) > 0;
}

int FindEntRefByClassname(int entity, const char[] classname)
{
	int ent = FindEntityByClassname(entity, classname);
	if (IsValidEdict(ent)) {
		return EntIndexToEntRef(ent);
	}
	return ent;
}
