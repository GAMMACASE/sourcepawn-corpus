/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>

new Handle:l4d_rock_fire;
new Handle:l4d_rock_explosive_burning;
new Handle:l4d_rock_explosive_normal;
new Handle:l4d_rock_explosive_damage;
new Handle:l4d_rock_explosive_radius;
new Handle:l4d_rock_explosive_pushforce;

public Plugin:myinfo = 
{
	name = "tank's burning rock",
	author = "Pan Xiaohai",
	description = "tank's burning rock",
	version = "1.0",
	url = "<- URL ->"
}

new tank=0;
new bool:tankthrow=false;
new bool:rockimpact=false;

public OnPluginStart()
{
	l4d_rock_fire = CreateConVar("l4d_rock_fire", "1", "0:disable , 1:burning tank throws burning rock, 2:always throw burning rock", FCVAR_PLUGIN);
	l4d_rock_explosive_burning = CreateConVar("l4d_rock_explosive_chance_burning", "30.0", "burning rock explode chance [0.0, 100.0]", FCVAR_PLUGIN);
	l4d_rock_explosive_normal = CreateConVar("l4d_rock_explosive_chance_normal", "20.0", "normal rock explode chance [0.0, 100.0]", FCVAR_PLUGIN);
	l4d_rock_explosive_damage = CreateConVar("l4d_rock_explosive_damage", "20.0", "[0.0, 100.0]", FCVAR_PLUGIN);
	l4d_rock_explosive_radius = CreateConVar("l4d_rock_explosive_radius", "150.0", "[0.0, 500.0]", FCVAR_PLUGIN);
	l4d_rock_explosive_pushforce = CreateConVar("l4d_rock_explosive_pushforce", "700.0", "[0.0, 2000.0]", FCVAR_PLUGIN);

	AutoExecConfig(true, "l4d_tankrock");
	
	HookEvent("round_start", round_end);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition", round_end);
	HookEvent("ability_use", ability_use);
	tankthrow=false;
	rockimpact=false;
	tank=0;
}

public OnMapStart()
{
	PrecacheModel("models/props_junk/propanecanister001a.mdl", true);
	PrecacheModel("models/props_junk/gascan001a.mdl", true);
	 
	PrecacheParticle("gas_explosion_pump");
}

public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	tankthrow=false;
	rockimpact=false;
	tank=0;
}
public Action:ability_use(Handle:event, const String:name[], bool:dontBroadcast)
{
	decl String:s[32];
	GetEventString(event, "ability", s, 32);

	if(StrEqual(s, "ability_throw", true))
	{
		tankthrow=true;
		tank = GetClientOfUserId(GetEventInt(event, "userid"));
	}
}

public OnEntityCreated(entity, const String:classname[])
{
	if(!tankthrow)return;
	if(StrEqual(classname, "tank_rock", true))
	{
		tankthrow=false;
		if(IsValidEntity(entity) && IsValidEdict(entity))
		{
			new team=GetEntProp(entity, Prop_Send, "m_iTeamNum");
			if(team>=0)
			{
				//PrintToChatAll("%d", GetEntProp(entity, Prop_Send, "m_iTeamNum"));
				new mode=GetConVarInt(l4d_rock_fire);
				if(mode==2)
				{
					IgniteEntity(entity, 100.0);
				}
				else if(mode==1)
				{
					if(tank>0 && tank<=MaxClients)
					{
						if(IsClientInGame(tank) && IsPlayerAlive(tank))
						{
							if(GetEntityFlags(tank) & FL_ONFIRE)
							{
								IgniteEntity(entity, 100.0);
							}
						}
					}
				}
				rockimpact=true;
			}
		}
	}
}

public OnEntityDestroyed(entity)
{
	if(!rockimpact || !IsValidEntity(entity) || !IsValidEdict(entity))return;
	decl String:g_classname[20];
	GetEdictClassname(entity, g_classname, 20);
	if(StrEqual(g_classname, "tank_rock", true) && GetEntProp(entity, Prop_Send, "m_iTeamNum")>=0)
	{
		new Handle:chance=l4d_rock_explosive_normal;
		if(GetEntityFlags(entity) & FL_ONFIRE)chance=l4d_rock_explosive_burning;
		if(GetRandomFloat(0.0,100.0)<GetConVarFloat(chance))
		{
			new ent1 = 0;
			new ent2 = 0;
			new ent3 = 0;
			new Float:pos[3];
			GetEntPropVector(entity, Prop_Send, "m_vecOrigin", pos);
			
			ent1=CreateEntityByName("prop_physics"); 
			
			DispatchKeyValue(ent1, "model", "models/props_junk/propanecanister001a.mdl"); 
			DispatchSpawn(ent1); 
			TeleportEntity(ent1, pos, NULL_VECTOR, NULL_VECTOR);
			ActivateEntity(ent1);
			SetEntityRenderMode(ent1, RenderMode:3);
			SetEntityRenderColor(ent1, 0, 0, 0, 0);
			AcceptEntityInput(ent1, "Ignite", -1, -1);
			
			new Float:damage=GetConVarFloat(l4d_rock_explosive_damage);
			new Float:radius=GetConVarFloat(l4d_rock_explosive_radius);
			new Float:pushforce=GetConVarFloat(l4d_rock_explosive_pushforce);
			
			new Handle:h=CreateDataPack();
			WritePackCell(h, -1);
			WritePackCell(h, ent1);
			WritePackCell(h, ent2);
			WritePackCell(h, ent3);

			WritePackFloat(h, pos[0]);
			WritePackFloat(h, pos[1]);
			WritePackFloat(h, pos[2]);

			WritePackFloat(h, damage);
			WritePackFloat(h, radius);
			WritePackFloat(h, pushforce);

			Explode2(INVALID_HANDLE, h);
		}
		rockimpact=false;
	}
}

public Action:Explode2(Handle:timer, Handle:h)
{
	ResetPack(h);
	new userid=ReadPackCell(h);
	new ent1=ReadPackCell(h);
	new ent2=ReadPackCell(h);
	new ent3=ReadPackCell(h);

	decl Float:pos[3];
	pos[0]=ReadPackFloat(h);
	pos[1]=ReadPackFloat(h);
	pos[2]=ReadPackFloat(h);
	new Float:damage=ReadPackFloat(h);
	new Float:radius=ReadPackFloat(h);
	new Float:force=ReadPackFloat(h);
	CloseHandle(h);
	
	if(ent1>0 && IsValidEntity(ent1))
	{
		AcceptEntityInput(ent1, "break", userid);
		RemoveEdict(ent1);
		if(ent2>0 && IsValidEntity(ent2))
		{
			AcceptEntityInput(ent2, "break",  userid);
			RemoveEdict(ent2);
		}
		if(ent3>0 && IsValidEntity(ent3))
		{
			AcceptEntityInput(ent3, "break",  userid);
			RemoveEdict(ent3);
		}
	}
	ShowParticle(pos, "gas_explosion_pump", 3.0);
	new pointHurt = CreateEntityByName("point_hurt");
	
	DispatchKeyValueFloat(pointHurt, "Damage", damage);
	DispatchKeyValueFloat(pointHurt, "DamageRadius", radius); 
	DispatchKeyValue(pointHurt, "DamageDelay", "0.0");
	DispatchSpawn(pointHurt);
	TeleportEntity(pointHurt, pos, NULL_VECTOR, NULL_VECTOR);
	AcceptEntityInput(pointHurt, "Hurt", userid);
	CreateTimer(0.1, DeletePointHurt, pointHurt); 
	
	new push = CreateEntityByName("point_push");
	DispatchKeyValueFloat (push, "magnitude", force);
	DispatchKeyValueFloat (push, "radius", radius*1.0);
	SetVariantString("spawnflags 24");
	AcceptEntityInput(push, "AddOutput");
	DispatchSpawn(push);   
	TeleportEntity(push, pos, NULL_VECTOR, NULL_VECTOR);
	AcceptEntityInput(push, "Enable", userid, userid);
	CreateTimer(0.5, DeletePushForce, push);
	return;
}

public ShowParticle(Float:pos[3], String:particlename[], Float:time)
{
	new particle = CreateEntityByName("info_particle_system");
	if (IsValidEntity(particle))
	{
		TeleportEntity(particle, pos, NULL_VECTOR, NULL_VECTOR);
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(time, DeleteParticles, particle);
	}
}

public PrecacheParticle(String:particlename[])
{
	new particle = CreateEntityByName("info_particle_system");
	if (IsValidEntity(particle))
	{
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(0.01, DeleteParticles, particle);
	}
}

public Action:DeleteParticles(Handle:timer, any:particle)
{
	if (IsValidEntity(particle))
	{
		decl String:classname[64];
		GetEdictClassname(particle, classname, sizeof(classname));
		if (StrEqual(classname, "info_particle_system", false))
		{
			AcceptEntityInput(particle, "stop");
			AcceptEntityInput(particle, "kill");
			RemoveEdict(particle);
		}
	}
}

public Action:DeletePointHurt(Handle:timer, any:ent)
{
	if (IsValidEntity(ent))
	{
		decl String:classname[64];
		GetEdictClassname(ent, classname, sizeof(classname));
		if (StrEqual(classname, "point_hurt", false))
		{
			AcceptEntityInput(ent, "Kill"); 
			RemoveEdict(ent);
		}
	}
}

public Action:DeletePushForce(Handle:timer, any:ent)
{
	if (IsValidEntity(ent))
	{
		decl String:classname[64];
		GetEdictClassname(ent, classname, sizeof(classname));
		if (StrEqual(classname, "point_push", false))
		{
			AcceptEntityInput(ent, "Disable");
			AcceptEntityInput(ent, "Kill"); 
			RemoveEdict(ent);
		}
	}
}