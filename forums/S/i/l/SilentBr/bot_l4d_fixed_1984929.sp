/* Plugin Template generated by Pawn Studio 

*/
 
#include <sourcemod>
#include <sdktools>

new Handle:l4d_bot_max;
new Handle:l4d_bot_teleport;

new bool:IsNewPlayer[MAXPLAYERS+1]
 
public Plugin:myinfo = 
{
	name = " Bots Control In Coop Mode",
	author = "Pan XiaoHai, fix by raziEiL [disawar1]",
	description = "<- Description ->",
	version = "2.0",
	url = "<- URL ->"
} 

public OnPluginStart()
{  
	l4d_bot_max = CreateConVar("l4d_bot_max", "8", "max bots");
	l4d_bot_teleport = CreateConVar("l4d_bot_teleport", "1", "teleport the new bot to a palyer");
	RegAdminCmd("sm_bot", sm_bot123, ADMFLAG_UNBAN);  
	RegAdminCmd("sm_addbot", add_bot, ADMFLAG_UNBAN);
	AutoExecConfig(true, "bot_l4d"); 

	HookEvent("player_spawn", player_spawn);	
	HookEvent("player_team", player_team  );
	HookEvent("player_death", player_death); 
}

public player_team(Handle:event, const String:name[], bool:dontBroadcast)
{ 
	new client = GetClientOfUserId(GetEventInt(event, "userid")); 
	new team =  GetEventInt(event, "team") ;
	
	new isnew=IsNewPlayer[client];
	IsNewPlayer[client]=false;  
	if(isnew && client>0 && IsClientInGame(client) && !IsFakeClient(client))
	{
		if(client>0 && IsClientInGame(client) && !IsFakeClient(client))PrintToServer("player %N change team to %d", client, team);
		CreateTimer(1.0, ClientInServer, client);	 
	}
}
public Action:ClientInServer(Handle:timer, any:client)
{
	if(client>0 && IsClientInGame(client) && !IsFakeClient(client))
	{ 
		PrintToServer("player %N join survivor", client );
		if (GetClientTeam(client)==1)
		{			
			new bot=GetABot();
			if(bot>0)
			{
				TakeOverBot(client, bot);
				PrintToServer("player %N takeover %N ", client,bot );
			}
		}
		new bool:bstate=GetAliveState(client); 
		if(bstate && !IsPlayerAlive(client))
		{
			Respawn(client);
			PrintToServer("force player %N respawn",client);
		}
		if (GetConVarInt(l4d_bot_teleport)==1)
			CreateTimer(0.1, TeleMe, client);
		
	}
}

public Action:TeleMe(Handle:timer, any:client)
{
	if (IsClientInGame(client))
		TeleportClientTo(client);
}

public Action:player_death(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(hEvent, "userid"));
	if(client>0 && IsClientInGame(client) && GetClientTeam(client)==2 && !IsFakeClient(client)) 
	{
		SetAliveState(client, false); 
	}
}
public Action:player_spawn(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(hEvent, "userid")); 
	if(client>0 && IsClientInGame(client) && GetClientTeam(client)==2 && !IsFakeClient(client)) 
	{
		SetAliveState(client, true); 
	} 
}
public OnClientPutInServer(client)
{
	if(client>0 && !IsFakeClient(client)) 
	{
		//PrintToServer("OnClientPutInServer %N", client );
		IsNewPlayer[client]=true;
		
		new bot=GetSurvivorCount();
		new player=GetRealPlayerCount();
		PrintToServer("client %N join game bot %d human %d", client,bot ,player);
		if(bot<player && bot<GetConVarInt(l4d_bot_max))
		{
			CreateBot(client);
		}
	}
}

TeleportClientTo(client)
{
	for(new i=1; i<MaxClients; i++)
	{
		if (i != client && IsClientInGame(i) && GetClientTeam(i) == 2 && IsPlayerAlive(i))
		{
			new Float:pos[3];
			GetClientAbsOrigin(i, pos);
			TeleportEntity(client, pos, NULL_VECTOR,NULL_VECTOR);
			//PrintToChatAll("tele %N to %N", client, i)
			break;
		} 
	}
}

GetSurvivorCount()
{
	new count=0;
	for(new i=1; i<MaxClients; i++)
	{
		if (IsClientInGame(i) && GetClientTeam(i) == 2)
		{
			count++;
		} 
	}	
	return count;
}

GetABot()
{
	new r=0;
	new bots=0;
	for(new i=1; i<MaxClients; i++)
	{
		if (IsClientInGame(i) && GetClientTeam(i) == 2) 
		{
			if( IsFakeClient(i) ) r=i;
			bots++;
		} 
	}	  
	return r;
}
CreateBot(client=0)
{
	new bot = CreateFakeClient("I am not real.");
	if(bot != 0)
	{
		ChangeClientTeam(bot, 2);
		if(DispatchKeyValue(bot, "classname", "SurvivorBot") == false)
		{
			PrintToServer("\x01Create bot failed");
			return 0;
		}
		
		if(DispatchSpawn(bot) == false)
		{
			PrintToServer("\x01Create bot failed");
			return 0;
		}
		SetEntityRenderColor(bot, 128, 0, 0, 255); 
		CreateTimer(0.1,TimerKick, bot, TIMER_FLAG_NO_MAPCHANGE); 
		//if(client>0)PrintToChatAll("Create a bot for %N", client);
		if(client>0)PrintToServer("Create a bot for %N", client);

	}
	return bot;
}
public Action:TimerKick(Handle:timer, any:bot)
{
	if (IsClientConnected(bot))
		KickClient(bot, "fake player");
	return Plugin_Stop;
}
GetRealPlayerCount(except=0)
{
	new count=0;
	for(new i=1; i<MaxClients; i++)
	{
		if (IsClientInGame(i) && GetClientTeam(i)!= 3 && !IsFakeClient(i) && i!=except)
		{
			count++;
		} 
	}	
	return count;
}
public Action:sm_bot123(client,args)
{
	Respawn(client); 
} 
stock TakeOverBot(client, bot)
{ 
	static Handle:hSpec;
	if(hSpec == INVALID_HANDLE)
	{
		new Handle:hGameConf;
		
		hGameConf = LoadGameConfigFile("l4dsb");
		if(hGameConf==INVALID_HANDLE)PrintToChatAll("load error");
		StartPrepSDKCall(SDKCall_Player);
		PrepSDKCall_SetFromConf(hGameConf, SDKConf_Signature, "SetHumanSpec");
		PrepSDKCall_AddParameter(SDKType_CBasePlayer, SDKPass_Pointer);
		hSpec = EndPrepSDKCall();
	}
	
	static Handle:hSwitch;
	if(hSwitch == INVALID_HANDLE)
	{
		new Handle:hGameConf;
		
		hGameConf = LoadGameConfigFile("l4dsb");
		
		StartPrepSDKCall(SDKCall_Player);
		PrepSDKCall_SetFromConf(hGameConf, SDKConf_Signature, "TakeOverBot");
		PrepSDKCall_AddParameter(SDKType_Bool, SDKPass_Plain);
		hSwitch = EndPrepSDKCall();
	}
	
	SDKCall(hSpec, bot, client);
	SDKCall(hSwitch, client, true); 
	return;
}
stock Respawn(client)
{
	static Handle:hRoundRespawn=INVALID_HANDLE;
	if (hRoundRespawn == INVALID_HANDLE)
	{
		new Handle:hGameConf = LoadGameConfigFile("respawn");
		StartPrepSDKCall(SDKCall_Player);
		PrepSDKCall_SetFromConf(hGameConf, SDKConf_Signature, "RoundRespawn");
		hRoundRespawn = EndPrepSDKCall();  
		if (hRoundRespawn == INVALID_HANDLE) 
		{ 
			PrintToChatAll("L4D_SM_Respawn: RoundRespawn Signature broken");
		}		
  	}
	SDKCall(hRoundRespawn, client); 
}



SetAliveState(client, bool:bstate)
{
	if(bstate)ClientCommand(client, "setinfo %s %s", "alive", "true"); 	
	else ClientCommand(client, "setinfo %s %s", "alive", "false"); 	
}
bool:GetAliveState(client)
{
	new String:info[64];
	GetClientInfo(client, "alive", info, 64);
	PrintToServer("palyer %N info %s", client, info);
	if(StrEqual(info, "false"))	return false;
	return true;
} 

public Action:add_bot(client,args)
{
	MakeBot(client); 
} 

MakeBot(client=0)
{
	new bot = CreateFakeClient("I am not real.");
	if(bot != 0)
	{
		ChangeClientTeam(bot, 2);
		if(DispatchKeyValue(bot, "classname", "SurvivorBot") == false)
		{
			PrintToServer("\x01Create bot failed");
			return 0;
		}
		
		if(DispatchSpawn(bot) == false)
		{
			PrintToServer("\x01Create bot failed");
			return 0;
		}
		SetEntityRenderColor(bot, 128, 0, 0, 255); 
		CreateTimer(0.1,TimerKick, bot, TIMER_FLAG_NO_MAPCHANGE); 
		if(client>0)PrintToChatAll("Create a bot for %N", client);
		if(client>0)PrintToServer("Create a bot for %N", client);
		
		decl Float:VecPosition[3];
		if ( GetClientAimedLocationData( client, VecPosition, NULL_VECTOR, NULL_VECTOR ) == -1 )
		{
			return 0;
		}
		
		TeleportEntity(bot, VecPosition, NULL_VECTOR, NULL_VECTOR);
		
	}
	return bot;
}

//---------------------------------------------------------
// get position, angles and normal of aimed location if the parameters are not NULL_VECTOR
// return the index of entity you aimed
//---------------------------------------------------------
GetClientAimedLocationData( client, Float:position[3], Float:angles[3], Float:normal[3] )
{
	new index = -1;
	
	new player = GetPlayerIndex( client );

	decl Float:_origin[3], Float:_angles[3];
	GetClientEyePosition( player, _origin );
	GetClientEyeAngles( player, _angles );

	new Handle:trace = TR_TraceRayFilterEx( _origin, _angles, MASK_SOLID_BRUSHONLY, RayType_Infinite, TraceEntityFilterPlayers );
	if( !TR_DidHit( trace ) )
	{ 
		index = -1;
	}
	else
	{
		TR_GetEndPosition( position, trace );
		TR_GetPlaneNormal( trace, normal );
		angles[0] = _angles[0];
		angles[1] = _angles[1];
		angles[2] = _angles[2];

		index = TR_GetEntityIndex( trace );
	}
	CloseHandle( trace );
	
	return index;
}



//---------------------------------------------------------
// the filter function for TR_TraceRayFilterEx
//---------------------------------------------------------
public bool:TraceEntityFilterPlayers( entity, contentsMask, any:data )
{
	return entity > MaxClients && entity != data;
}

//---------------------------------------------------------
// return 0 if it is a server
//---------------------------------------------------------
GetPlayerIndex( client )
{
	if ( client == 0 && !IsDedicatedServer() )
	{
		return 1;
	}
	
	return client;
}