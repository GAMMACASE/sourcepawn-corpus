/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 
#include <sdkhooks>
 
#define Pai 3.14159265358979323846 
 
#define action_normal 1
#define action_tracing 2

// Global Variables

bool L4D2Version		=	false;
bool OnTrace[100]	=	false;

int ReplaceWitchId;
int ReplaceWitchRush;
int ReplaceWitchFlag;
int ReplaceWitchSequence;
int ReplaceWitchVictim;
int HookWitchCount; 
int anim_walk;
int anim_ducking;
int HookWitchs[100];
int Enemy[100];

float ReplaceWitchTime;
float ReplaceWitchPos[3];
float ReplaceWitchAngle[3];
float ReplaceWitchRage;
float ReplaceWitchWanderRage;
float ReplaceWitchScale;

float ActionTime[100];
float EnemyTime[100];
float StuckTime[100];
float PauseTime[100];
float LastTime[100];
float TargetDir[100][3];
float LastPos[100][3];
float LastSetPos[100][3];

// ConVar

ConVar l4d_witch_range_vision; 
ConVar l4d_witch_attack_range;
ConVar l4d_witch_chance_attacknext;
ConVar l4d_witch_chance_followsurvivor;
ConVar l4d_witch_changetarget;

// Checking if we should load the plugin or not?
public APLRes AskPluginLoad2()
{
	char GameName[16];
	GetGameFolderName(GameName, sizeof(GameName));
	
	if (StrEqual(GameName, "left4dead2", false))
	{	 
		L4D2Version = true;
		return APLRes_Success;
	}	
	else
	{
		L4D2Version = false;
		return APLRes_Success;
	}
}

// Plugin info and Plugin Start.

public Plugin:myinfo = 
{
	name = "Evil Witch",
	author = "Pan XiaoHai, $atanic $pirit",
	description = "A witch can fellow survivors and can kill more than one.",
	version = "2.0",
	url = "https://forums.alliedmods.net/showpost.php?p=2570529&postcount=40"
}

public OnPluginStart()
{
	// Set the right ducking animation. 
	DuckingAnimation();

	// Initializing ConVar.
	l4d_witch_chance_attacknext 	= CreateConVar("l4d_witch_chance_attacknext", "100.0", "chance of continue attack [0.0, 100.0]" );
	l4d_witch_changetarget 			= CreateConVar("l4d_witch_changetarget", "1", "0:do not change target when witch attack victim to incapacitated, 1:change target");
	l4d_witch_attack_range 			= CreateConVar("l4d_witch_attack_range", "400.0", "after attacking, witch will attack someone in this range, can not set too big, or witch will run away");
	l4d_witch_chance_followsurvivor = CreateConVar("l4d_witch_chance_followsurvivor", "60.0", " chance of fellow survivors [0.0, 100.0]");
	l4d_witch_range_vision 			= CreateConVar("l4d_witch_range_vision", "1000.0", " witch's vision range , witch will fellow you if in range [100.0, 5000.0] " );
 
	// Creating the config file.
	AutoExecConfig(true, "l4d_evil_witch");
	
	// Hooking witch related events.
	HookEvent("witch_spawn", witch_spawn); 
	HookEvent("witch_killed", witch_killed); 
	
	// Hooking player related events.
	HookEvent("player_death", player_death);
	HookEvent("player_incapacitated", player_incapacitated ); 
	
	// Hooking round related events.
	HookEvent("round_start", round_start);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition",  round_end);	
	
	// Registering the console command.
	RegConsoleCmd("sm_walkwitch", Command_WalkWitch);
}

// Precache the right sprites. 

public void OnMapStart()
{
	if(L4D2Version)
	{
		PrecacheModel("materials/sprites/laserbeam.vmt");		
	}
	else
	{
		PrecacheModel("materials/sprites/laser.vmt");		 
	}
}

// Round related events.

public Action round_start(Handle event, const char[] name, bool dontBroadcast)
{ 
	ReplaceWitchId = 0;
	HookWitchCount = 0;
}

public Action round_end(Handle event, const char[] name, bool dontBroadcast)
{
	ReplaceWitchId = 0;
	HookWitchCount = 0;
}

// Player related events.

public Action player_death(Handle hEvent, const char[] strName, bool DontBroadcast)
{ 
 	int victim = GetClientOfUserId(GetEventInt(hEvent, "userid"));  
	int witch =  GetEventInt(hEvent, "attackerentid") ;  
	if(victim>0 && witch>0)
	{		
		if(IsClientInGame(victim) && GetClientTeam(victim) == 2)
		{
			StartSaveWitch(witch, victim);
		}
	}		
	return Plugin_Continue;	 
}

public Action player_incapacitated(Handle hEvent, const char[] strName, bool DontBroadcast)
{ 
 	int victim = GetClientOfUserId(GetEventInt(hEvent, "userid"));  
	int witch =  GetEventInt(hEvent, "attackerentid") ;  
	if(victim>0 && witch>0)
	{		
		if(IsClientInGame(victim) && GetClientTeam(victim) == 2)
		{
			StartSaveWitch(witch, victim);
		}
	}		
	return Plugin_Continue;	 
}

// Witch related events.

public Action witch_killed(Handle h_Event, const char[] s_Name, bool b_DontBroadcast)
{
	int witchid = GetEventInt(h_Event, "witchid");
	if(witchid>0)
	{
		if(ReplaceWitchId == witchid)ReplaceWitchId = 0;
		StopHookWitch(witchid);
	}
	return Plugin_Handled;
}

public Action witch_spawn(Handle h_Event, const char[] s_Name, bool b_DontBroadcast)
{
	//PrintToChatAll("witch spawn");
	int witchid = GetEventInt(h_Event, "witchid");
	CreateTimer(0.1, DelayHookWitch, witchid, TIMER_FLAG_NO_MAPCHANGE );	
	//StartHookWitch(witchid);
	if(witchid>0 )
	{
		LoadWitch(witchid); 		
	}
}

// Initializing plugin command.
public Action Command_WalkWitch(int client, int args)
{
	int witch = GetClientAimTarget(client, false);
	StartHookWitch(witch);
}

// Internal plugin functions.

public void StartSaveWitch( int witch, int victim)
{ 
	if(IsWitch(witch)  && GetRandomFloat(0.0, 100.0)< GetConVarFloat(l4d_witch_chance_attacknext))
	{ 
		/*
		Handle h = CreateDataPack();
		WritePackCell(h, witch);
		WritePackCell(h, victim);
		CreateTimer(0.01, DelaySave, h, TIMER_FLAG_NO_MAPCHANGE );	
		*/
		SaveWitch(witch, victim);
	}	 
}

public Action DelayHookWitch(Handle timer, int witch)
{
	StartHookWitch(witch);
}

public Action StartHookWitch(int witch)
{
	StopHookWitch(witch);
	if(IsWitch(witch))
	{ 
		int index = AddWitch(witch);
		  
		EnemyTime[index] = GetEngineTime(); 
		Enemy[index] = 0; 
		LastTime[index] = GetEngineTime()-0.01;
		StuckTime[index] = 0.0;
		PauseTime[index] = 0.0; 
		ActionTime[index] = 0.0;
		OnTrace[index] = false;
	 
		GetEntPropVector(witch, Prop_Send, "m_vecOrigin", LastPos[index]);
		SetVector(TargetDir[index], GetRandomFloat(-1.0, 1.0), GetRandomFloat(-1.0, 1.0), 0.0);
		SetVector(LastSetPos[index], 0.0, 0.0, 0.0);
		NormalizeVector(TargetDir[index], TargetDir[index]); 
		SDKHook(witch, SDKHook_ThinkPost, ThinkWitch);
	}
}

public Action StopHookWitch(int witch)
{
	if(witch>0)
	{	
		SDKUnhook(witch, SDKHook_ThinkPost, ThinkWitch);		
		DeleteWitch(witch);
	}
}

public Action DeleteWitch(int witch)
{
	int find = -1;
	for(int i = 0; i<HookWitchCount; i++)
	{
		if(witch == HookWitchs[i]) 
		{
			find = i; break;
		}
	}
	
	int CountMinusOne = HookWitchCount-1;
	if(find >= 0)
	{
		HookWitchs[find] = HookWitchs[CountMinusOne]; 
		EnemyTime[find] = EnemyTime[CountMinusOne];
		LastTime[find] = LastTime[CountMinusOne];
		Enemy[find] = Enemy[CountMinusOne];
		StuckTime[find] = StuckTime[CountMinusOne];
		PauseTime[find] = PauseTime[CountMinusOne];
		ActionTime[find] = StuckTime[CountMinusOne];
		CopyVector(LastPos[CountMinusOne], LastPos[find]);
		CopyVector(TargetDir[CountMinusOne], TargetDir[find]);
		CopyVector(LastSetPos[CountMinusOne], LastSetPos[find]);
		
		if(PauseTime[CountMinusOne])
			OnTrace[find] = true;
		else
			OnTrace[find] = false;
			
		HookWitchCount--;
	}
	
}

public void SetRage(int witch, float rage, float wanderRage)
{
	SetEntPropFloat(witch, Prop_Send, "m_rage", rage);
	if(L4D2Version)
	{
		SetEntPropFloat(witch, Prop_Send, "m_wanderrage",wanderRage); 
	//PrintToChatAll("set m_rage %f   %f  ", rage, wanderRage );
	}
}

public Action ThinkWitch(int witch)
{
	if(!IsWitch(witch))
	{
		StopHookWitch(witch);
		return;
	}
	int index = FindWitchIndex(witch);
	if(index<0)
	{
		StopHookWitch(witch);
		return;
	}
	float time = GetEngineTime();
	float duration = time-LastTime[index];
	if(duration>0.1)duration = 0.1;
	LastTime[index] = time;
	
	if(time-ActionTime[index]>5.0)
	{	
		if(GetRandomFloat(0.0, 100.0)<GetConVarFloat(l4d_witch_chance_followsurvivor))
		{
			OnTrace[index] = true;
		}
		else OnTrace[index] = false;
		ActionTime[index] = time;
	} 
	
	if(OnTrace[index] == false)return;
	
 
	int m_nSequence = GetEntProp(witch, Prop_Send, "m_nSequence");
	int m_mobRush = GetEntProp(witch, Prop_Send, "m_mobRush");
	float m_rage;
	float m_wanderrage;
	float rage = GetRage(witch, m_rage, m_wanderrage);
	  
	//PrintToChatAll("rage %f m_rage %f m_wanderrage %f ", rage,m_rage,m_wanderrage );
	int flag = GetEntProp(witch, Prop_Send, "m_fFlags");
	bool onground = !(GetEntPropEnt(witch, Prop_Data, "m_hGroundEntity") == -1);
	
	float witchAngle[3]; 
	float witchPos[3];
	float lastPos[3]; 
	GetEntPropVector(witch, Prop_Send, "m_angRotation", witchAngle);
 	GetEntPropVector(witch, Prop_Send, "m_vecOrigin", witchPos);	
	CopyVector(LastPos[index], lastPos);
	CopyVector(witchPos, LastPos[index]);
	int m_hOwnerEntity = GetEntProp(witch, Prop_Send, "m_hOwnerEntity");   
	if( !onground || m_hOwnerEntity > 0 || m_mobRush == 1 || m_rage == 1.0  )
	{		
		StuckTime[index] = 0.0;
		return;
	}  
	if(rage>0.5)
	{
		StuckTime[index] = 0.0;
		return; 
	} 	
	float up[3];  
 
	float newWitchPos[3];
	float newWitchAngle[3]; 
	 
	float moveDir[3]; 
	
	float temp[3]; 
	float temp2[3]; 
	float moveSpeed = 100.0;  
	
	SetVector(up, 0.0, 0.0, 1.0); 
 
	float targetPos[3];   
	
	if(time-EnemyTime[index]>1.0)
	{	
		Enemy[index] = FindNextEnemy(witch,witchPos );	 		
		EnemyTime[index] = time;  
	
	} 
	PauseTime[index] -= duration; 
	Enemy[index] = FreshEnemy(Enemy[index], targetPos  );
	if(Enemy[index])
	{ 
		if(PauseTime[index] <= 0.0)
		{
			SubtractVectors(targetPos, witchPos, TargetDir[index]);
			TargetDir[index][2] = 0.0;
			NormalizeVector(TargetDir[index], TargetDir[index]);	 
			//PrintToChatAll("eneym %d", Enemy[index]);
		}
		
	}
	else
	{
		if(L4D2Version)return;
		int newSequence;
		int newFlag;
		 
		newSequence = anim_ducking;
		newFlag = flag | FL_DUCKING; 
		 
		SetEntProp(witch, Prop_Send, "m_fFlags",newFlag);
		if(m_nSequence != newSequence)
		{
			SetEntProp(witch, Prop_Send, "m_nSequence" ,newSequence); 
			SetEntPropFloat(witch, Prop_Send, "m_flPlaybackRate" ,1.0); 
		}
		return;
	}

	StuckTime[index] += duration; 
	if(StuckTime[index]>0.5)
	{  
		StuckTime[index] = 0.0;
		CopyVector(witchPos, temp);
		CopyVector(LastSetPos[index], temp2);
		CopyVector(witchPos, LastSetPos[index] );
		temp2[2] = temp[2] = 0.0;  
		float a = GetVectorDistance(temp2, temp); 
		if(a<10.0)
		{ 
			RotateVector(up, TargetDir[index], GetRandomFloat(50.0, 310.0)*Pai/180.0, TargetDir[index]);
			
			TargetDir[index][2] = 0.0;
			NormalizeVector(TargetDir[index],TargetDir[index]); 
			PauseTime[index] = 2.0;
		}
	} 

	int newSequence = anim_walk;
	moveSpeed = 70.0;
	int newFlag = flag & ~FL_DUCKING; 

	CopyVector(TargetDir[index],moveDir);	 	
	
	GetVectorAngles(moveDir,newWitchAngle);
	newWitchAngle[0] = 0.0;
	
	CopyVector(moveDir,temp);
	ScaleVector(temp, moveSpeed*duration);
	AddVectors(witchPos,temp,newWitchPos);
	TeleportEntity(witch, newWitchPos, newWitchAngle,  NULL_VECTOR);
	CopyVector(witchPos, lastPos);	
	SetEntProp(witch, Prop_Send, "m_fFlags",newFlag);
	 
	if(m_nSequence != newSequence)
	{
		SetEntProp(witch, Prop_Send, "m_nSequence" ,newSequence); 
		SetEntPropFloat(witch, Prop_Send, "m_flPlaybackRate" ,1.0); 
	}
}

public void SaveWitch(int ent, int victim)
{
	if(IsWitch(ent))
	{
		float m_rage;
		float m_wanderRage;
		GetRage(ent, m_rage ,m_wanderRage);
		int flag = GetEntProp(ent, Prop_Send, "m_fFlags");
		 
		int m_nSequence = GetEntProp(ent, Prop_Data, "m_nSequence");
		float scale = 0.0;
		if(L4D2Version)scale = GetEntPropFloat(ent , Prop_Send,"m_flModelScale");  
		 
		{		
			ReplaceWitchId = ent;
			ReplaceWitchTime = GetEngineTime();
			GetEntPropVector(ent, Prop_Send, "m_vecOrigin", ReplaceWitchPos); 
			GetEntPropVector(ent, Prop_Send, "m_angRotation", ReplaceWitchAngle);
			ReplaceWitchSequence = m_nSequence;
			ReplaceWitchRage = m_rage;
			ReplaceWitchWanderRage = m_wanderRage;
			ReplaceWitchScale = scale;
			ReplaceWitchFlag = flag;
			if(GetConVarInt(l4d_witch_changetarget) == 1)ReplaceWitchVictim = GetVictim(victim,ReplaceWitchPos );	
			else if(IsPlayerIncapped(victim))
			{
				ReplaceWitchVictim = victim;
			}
			ReplaceWitchRush = 1;
			if(ReplaceWitchVictim>0)
			{
				ReplaceWitchRush = 1;
				//PrintToChatAll("next target is %N", ReplaceWitchVictim);
			}
			ReplaceWitchRush = ReplaceWitchRush+1-1;
			SpawnCommand("z_spawn", "witch"); 
		}
	}
}

public Action DelayShot(Handle timer, Handle h)
{
	ResetPack(h);
 	int witchid = ReadPackCell(h);
	int attacker = ReadPackCell(h);
	CloseHandle(h);
	if(!IsWitch(witchid))return;
	if(IsSurvivor(attacker))
	{
		DoPointHurtForInfected(witchid, attacker, 1.0);
		SetEntProp(witchid, Prop_Send, "m_mobRush",1 );
	}
}

public void SpawnCommand(char[] command, char[] arguments)
{
	int client = 0;
	for(int i = 1; i <= MaxClients; i++)
	{
		if(IsClientInGame(i))
		{
			client = i;
			break;
		}
	}
	if (client>0)
	{ 
		int flags = GetCommandFlags(command);
		SetCommandFlags(command, flags & ~FCVAR_CHEAT);
		FakeClientCommand(client, "%s %s", command, arguments);
		SetCommandFlags(command, flags);
	}
}

// Stock functions.

int FindWitchIndex(int witch)
{
	 
	for(int i = 0; i<HookWitchCount; i++)
	{
		if(witch == HookWitchs[i])return i;
	}
	return -1;
}

int AddWitch(int witch)
{
	HookWitchs[HookWitchCount++] = witch;
	return HookWitchCount-1;
}

float GetRage(int witch, float rage, float wanderRage)
{
	rage = GetEntPropFloat(witch, Prop_Send, "m_rage");
	if(L4D2Version)
	{
		wanderRage = GetEntPropFloat(witch, Prop_Send, "m_wanderrage");
	}
	else
	{
		wanderRage = 0.0;
	}
	
	if(rage>wanderRage)
		return rage;
	else 
		return wanderRage;
}

int FreshEnemy(int enemy, float enemyPos[3] )
{
	float visionRange = GetConVarFloat(l4d_witch_range_vision);
	if(visionRange == 0.0)return 0; 	
	if(enemy>0 && IsClientInGame(enemy) && IsPlayerAlive(enemy) && GetClientTeam(enemy) == 2)
	{ 
		GetClientAbsOrigin(enemy, enemyPos);  
	}
	else enemy = 0;
	return enemy;
}

int FindNextEnemy(witch, float witchPos[3] )
{ 
	witch += 0; 
	float visionRange = GetConVarFloat(l4d_witch_range_vision);
	if(visionRange == 0.0)return 0;	 
 		 
	float minDis = 9999.0;
	int selectedPlayer = 0;
	float playerPos[3];
	for(int i = 1; i <= MaxClients; i++)
	{
		if(IsClientInGame(i) && GetClientTeam(i) == 2 && IsPlayerAlive(i) )
		{
		 
			GetClientAbsOrigin(i, playerPos);
			float dis = GetVectorDistance(playerPos, witchPos);  
			if(dis <= visionRange && dis <= minDis)
			{
				selectedPlayer = i ;
				minDis = dis;	
			}
		}
	} 
 
	return selectedPlayer;	 
}

int LoadWitch(int witchid)
{
	float time = GetEngineTime();
	int oldwitch = ReplaceWitchId;
	ReplaceWitchId = 0;	
	if(IsWitch(oldwitch ) && time-ReplaceWitchTime<0.2)
	{	
		StopHookWitch(oldwitch);
		AcceptEntityInput(oldwitch, "kill");	 	 
		SetEntProp(witchid, Prop_Send, "m_nSequence",ReplaceWitchSequence);		
		//SetEntProp(witchid, Prop_Send, "m_mobRush",ReplaceWitchRush );
		if(L4D2Version)SetEntPropFloat(witchid , Prop_Send,"m_flModelScale", ReplaceWitchScale); 
		SetEntProp(witchid, Prop_Send, "m_fFlags", ReplaceWitchFlag);
		TeleportEntity(witchid, ReplaceWitchPos, ReplaceWitchAngle, NULL_VECTOR);		
		if(IsSurvivor(ReplaceWitchVictim))
		{
			SetRage(witchid, ReplaceWitchRage ,ReplaceWitchWanderRage);
			Handle h = CreateDataPack();
			WritePackCell(h, witchid);
			WritePackCell(h, ReplaceWitchVictim);			 
			CreateTimer(0.1, DelayShot, h, TIMER_FLAG_NO_MAPCHANGE );	
			
		}
		else 
		{
			SetRage(witchid, 0.9 ,0.9);  
			SetEntProp(witchid, Prop_Send, "m_mobRush",0 );
		} 
	}		
}

int GetVictim(int except, float witchPos[3])
{
	float range = GetConVarFloat(l4d_witch_attack_range);
	float minDis = range;
	float ePos[3];
	int selected = 0;
	for(int i = 1; i <= MaxClients; i++)
	{
		if(IsClientInGame(i) && GetClientTeam(i) == 2 && IsPlayerAlive(i) && i != except && !IsPlayerIncapped(i))
		{	
			GetClientAbsOrigin(i, ePos);
			float dis = GetVectorDistance(ePos, witchPos);
			if(dis <= minDis )
			{
				selected = i;
				minDis = dis;
			}
		}
	} 
	return selected;
}

bool IsPlayerIncapped(int client)
{
	if(client>0 && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client))
	{
		if (GetEntProp(client, Prop_Send, "m_isIncapacitated", 1)) return true;
		
	}
	return false;
}

bool IsWitch(int witch)
{
	if(witch>0 && IsValidEdict(witch) && IsValidEntity(witch))
	{
		char classname[32];
		GetEdictClassname(witch, classname, sizeof(classname));
		if(StrEqual(classname, "witch"))
		{
			return true;
		}
	}
	return false;
}

bool IsSurvivor(int client)
{
	if(client>0 && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client))
	{
		return true;	 
	}
	return false;
}

int CreatePointHurt()
{
	int pointHurt = CreateEntityByName("point_hurt");
	if(pointHurt)
	{		
		DispatchKeyValue(pointHurt,"Damage","10");
		if(L4D2Version)	DispatchKeyValue(pointHurt,"DamageType","2"); 
		DispatchSpawn(pointHurt);
	}
	return pointHurt;
}

stock DoPointHurtForInfected(int victim, int attacker = 0, float FireDamage)
{
	char N[10];
	int g_PointHurt = CreatePointHurt();	 			
	Format(N, 20, "target%d", victim);
	DispatchKeyValue(victim,"targetname", N);
	DispatchKeyValue(g_PointHurt,"DamageTarget", N); 
 	DispatchKeyValueFloat(g_PointHurt,"Damage", FireDamage);
	AcceptEntityInput(g_PointHurt,"Hurt",(attacker>0)?attacker:-1);
	AcceptEntityInput(g_PointHurt,"kill" ); 
}

stock CopyVector(float source[3], float target[3])
{
	target[0] = source[0];
	target[1] = source[1];
	target[2] = source[2];
}

stock SetVector(float target[3], float x, float y, float z)
{
	target[0] = x;
	target[1] = y;
	target[2] = z;
}

stock DuckingAnimation()
{
	if(L4D2Version)
	{
		anim_ducking = 4;
	}
	else
	{
		anim_ducking = 2;  		 
	}
}

stock RotateVector(float direction[3], float vec[3], float alfa, float result[3])
{
  /*
   on rotateVector (v, u, alfa)
  -- rotates vector v around u alfa degrees
  -- returns rotated vector 
  -----------------------------------------
  u.normalize()
  alfa = alfa*pi()/180 -- alfa in rads
  uv = u.cross(v)
  vect = v + sin (alfa) * uv + 2*power(sin(alfa/2), 2) * (u.cross(uv))
  return vect
	end
   */
   	float v[3];
	CopyVector(vec,v);
	
	float u[3];
	CopyVector(direction,u);
	NormalizeVector(u,u);
	
	float uv[3];
	GetVectorCrossProduct(u,v,uv);
	
	float sinuv[3];
	CopyVector(uv, sinuv);
	ScaleVector(sinuv, Sine(alfa));
	
	float uuv[3];
	GetVectorCrossProduct(u,uv,uuv);
	ScaleVector(uuv, 2.0*Pow(Sine(alfa*0.5), 2.0));	
	
	AddVectors(v, sinuv, result);
	AddVectors(result, uuv, result);
}