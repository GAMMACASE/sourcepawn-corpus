/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdkhooks>
#include <sdktools>

public Plugin:myinfo = 
{
	name = "[HL2DM/AG2] Epic Explosions",
	author = "StrikerMan780",
	description = "Makes explosions create plumes of fire.",
	version = "1.0",
	url = "http://shadowmavericks.com"
}

new Handle:cv_explosions;

public OnPluginStart()
{
	cv_explosions = CreateConVar("sm_epic_explosions", "1","Enable Epic Explosion Effects",FCVAR_PLUGIN);
}

public OnEntityCreated(entity, const String:classname[])
{
	//PrintToChatAll(classname);
	if(StrEqual(classname, "env_explosion"))
	{
		SDKHook(entity, SDKHook_Spawn, Explosion);
	}
}

public OnEntityDestroyed(entity)
{
	decl String:classname[64];
	
	if(!IsValidEntity(entity) || !IsValidEdict(entity) || entity < MAXPLAYERS)
	{
		return;
	}
	else
	{
		GetEntityClassname(entity, classname, sizeof(classname));
	}
	
	if(StrEqual(classname, "npc_grenade_frag") | StrEqual(classname, "grenade_ar2"))
	{
		Explosion(entity);
	}
}


public Explosion(entity)
{
	new client = GetEntPropEnt(entity, Prop_Data, "m_hOwnerEntity");
	
	if(!IsValidClient(client))
	{
		return;
	}
	else
	{
		if(IsValidEdict(entity) == true) // Check if Valid Edict, just in case...
		{
			if(GetConVarBool(cv_explosions))
			{
				CreateParticle(entity, "Fire_Large_01", 0.2, false, false, true);
				CreateLight(entity, "255 100 10 255", 300.0, 0.2, false, true);
			}
		}
	}
	
	return;
}

stock bool:IsValidClient(client)
{
	if(client > 0 && client <= MaxClients)
	{
		if(IsClientConnected(client) && IsClientInGame(client))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

/**
* Description: Function to check the entity limit.
*              Use before spawning an entity.
*/
#if !defined _entlimit_included
stock bool:IsEntLimitReached(warn=20,critical=16,client=0,const String:message[]="")
{
	return (EntitiesAvailable(warn,critical,client,message) < warn);
}

stock EntitiesAvailable(warn=20,critical=16,client=0,const String:message[]="")
{
	new max = GetMaxEntities();
	new count = GetEntityCount();
	new remaining = max - count;
	if (remaining <= critical)
	{
		PrintToServer("Warning: Entity limit is nearly reached! Please switch or reload the map!");
		LogError("Entity limit is nearly reached: %d/%d (%d):%s", count, max, remaining, message);
		
		if (client > 0)
		{
			PrintToConsole(client, "Entity limit is nearly reached: %d/%d (%d):%s",
			count, max, remaining, message);
		}
	}
	else if (remaining <= warn)
	{
		PrintToServer("Caution: Entity count is getting high!");
		LogMessage("Entity count is getting high: %d/%d (%d):%s", count, max, remaining, message);
		
		if (client > 0)
		{
			PrintToConsole(client, "Entity count is getting high: %d/%d (%d):%s",
			count, max, remaining, message);
		}
	}
	return remaining;
}
#endif
/*****************************************************************/

// ------------------------------------------------------------------------
// CreateParticle()
// ------------------------------------------------------------------------
// >> Original code by J-Factor
// ------------------------------------------------------------------------
stock CreateParticle(iEntity, String:strParticle[], Float:time = 5.0, bool:bAttach = false, bool:bAngle = false, bool:bKill = false, String:strAttachmentPoint[]="", Float:fOffset[3]={0.0, 0.0, 0.0})
{
	if (IsEntLimitReached() || !IsValidEdict(iEntity))
	{
		return -1;
	}
	
	new iParticle = CreateEntityByName("info_particle_system");
	if (IsValidEdict(iParticle))
	{
		// Retrieve entity's position and angles
		decl Float:fPosition[3];
		decl Float:fAngles[3];
		decl Float:fForward[3];
		decl Float:fRight[3];
		decl Float:fUp[3];
		
		if(bAngle == true)
		{
			GetClientAbsOrigin(iEntity, fPosition);
			GetClientAbsAngles(iEntity, fAngles);
		}
		else
		{
			GetEntPropVector(iEntity, Prop_Send, "m_vecOrigin", fPosition);
		}
		
		// Determine vectors and apply offset
		GetAngleVectors(fAngles, fForward, fRight, fUp);    // I assume 'x' is Right, 'y' is Forward and 'z' is Up
		fPosition[0] += fRight[0]*fOffset[0] + fForward[0]*fOffset[1] + fUp[0]*fOffset[2];
		fPosition[1] += fRight[1]*fOffset[0] + fForward[1]*fOffset[1] + fUp[1]*fOffset[2];
		fPosition[2] += fRight[2]*fOffset[0] + fForward[2]*fOffset[1] + fUp[2]*fOffset[2];
		
		// Teleport and attach
		if(bAngle == true)
		{
			TeleportEntity(iParticle, fPosition, fAngles, NULL_VECTOR);
		}
		else
		{
			TeleportEntity(iParticle, fPosition, NULL_VECTOR, NULL_VECTOR);
		}
		
		if (bAttach == true)
		{
			SetVariantString("!activator");
			AcceptEntityInput(iParticle, "SetParent", iEntity, iParticle, 0);            
			
			if (StrEqual(strAttachmentPoint, "") == false)
			{
				SetVariantString(strAttachmentPoint);
				AcceptEntityInput(iParticle, "SetParentAttachmentMaintainOffset", iParticle, iParticle, 0);                
			}
		}
		
		// Spawn and start
		DispatchKeyValue(iParticle, "effect_name", strParticle);
		DispatchSpawn(iParticle);
		
		ActivateEntity(iParticle);
		AcceptEntityInput(iParticle, "Start");
		
	}
	
	if(bKill == true)
	{
		CreateTimer(time, Timer_KillParticle, iParticle);
	}
	
	return iParticle;
}

stock CreateLight(iEntity, String:strColor[], Float:distance, Float:time, bool:bAttach = false, bool:bKill = false, String:strAttachmentPoint[]="")
{
	if (IsEntLimitReached() || !IsValidEdict(iEntity))
	{
		return -1;
	}
	
	new iLight = CreateEntityByName("light_dynamic");
	
	if (IsValidEntity(iEntity))
	{
		// Spawn and start
		DispatchKeyValue(iLight, "inner_cone", "0");
		DispatchKeyValue(iLight, "cone", "80");
		DispatchKeyValue(iLight, "brightness", "1");
		DispatchKeyValueFloat(iLight, "spotlight_radius", 240.0);
		DispatchKeyValueFloat(iLight, "distance", distance);
		DispatchKeyValue(iLight, "_light", strColor);
		DispatchKeyValue(iLight, "pitch", "-90");
		DispatchKeyValue(iLight, "style", "5");
		
		// Teleport and attach
		decl Float:fPosition[3];
		GetEntPropVector(iEntity, Prop_Send, "m_vecOrigin", fPosition);
		TeleportEntity(iLight, fPosition, NULL_VECTOR, NULL_VECTOR);
		
		if (bAttach == true)
		{
			SetVariantString("!activator");
			AcceptEntityInput(iLight, "SetParent", iEntity, iLight, 0);            
			
			if (StrEqual(strAttachmentPoint, "") == false)
			{
				SetVariantString(strAttachmentPoint);
				AcceptEntityInput(iLight, "SetParentAttachmentMaintainOffset", iLight, iLight, 0);                
			}
		}
		
		DispatchSpawn(iLight);
		
		ActivateEntity(iLight);
		AcceptEntityInput(iLight, "TurnOn");
	}
	
	if(bKill == true)
	{
		CreateTimer(time, Timer_KillLight, iLight);
	}
	
	return iLight;
}

public Action:Timer_KillParticle(Handle:timer, any:entity)
{
	if (IsValidEdict(entity))
	{
		decl String:Classname[64];
		GetEdictClassname(entity, Classname, sizeof(Classname));

		//Is a Particle:
		if(StrEqual(Classname, "info_particle_system", false))
		{
			AcceptEntityInput(entity, "Stop");
			AcceptEntityInput(entity, "ClearParent");
			AcceptEntityInput(entity, "Kill");
		}
	}
}

public Action:Timer_KillLight(Handle:timer, any:entity)
{
	if (IsValidEdict(entity))
	{
		decl String:Classname[64];
		GetEdictClassname(entity, Classname, sizeof(Classname));

		//Is a Particle:
		if(StrEqual(Classname, "light_dynamic", false))
		{
			AcceptEntityInput(entity, "kill");
		}
	}
}