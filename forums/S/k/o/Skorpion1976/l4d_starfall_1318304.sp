/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>


#define tick 1.0/40.0
#define Tag2 "T2"
#define Tag3 "T3"

#define TagRain -5

new Handle:l4d_star_duration ;
new Handle:l4d_star_explode_chance ;
 
new Handle:l4d_star_damage ;
new Handle:l4d_star_radius ;
new Handle:l4d_star_pushforce ;
new Handle:l4d_star_tank ;
new Handle:l4d_star_witch ; 
new Handle:l4d_star_witch_harasser ;
new Rain[MAXPLAYERS+1][150];

new 	g_iVelocity ;
new L4D2Version;
new GameMode;
new g_sprite;
new gamestart=false;
public Plugin:myinfo = 
{
	name = "starfall",
	author = "Pan Xiaohai",
	description = "starfall",
	version = "1.0",
	url = "<- URL ->"
}

public OnPluginStart()
{
	l4d_star_duration = CreateConVar("l4d_star_duration", "15", "starfall duration (s)", FCVAR_PLUGIN);
	l4d_star_explode_chance = CreateConVar("l4d_star_explode_chance", "80", "star explode chance [0-100]", FCVAR_PLUGIN);
	 
	l4d_star_damage = 	CreateConVar("l4d_star_damage", "50", "explosion damage of star", FCVAR_PLUGIN);
	l4d_star_radius = CreateConVar("l4d_star_radius", "200", "explosion radius of start", FCVAR_PLUGIN);	
	l4d_star_pushforce =  CreateConVar("l4d_star_pushforce", "600", "explosion pushforce of star", FCVAR_PLUGIN);	
	l4d_star_tank =  CreateConVar("l4d_star_tank", "70", "chance of meteor shower when tank die", FCVAR_PLUGIN); 
	l4d_star_witch =  CreateConVar("l4d_star_witch", "50", " ", FCVAR_PLUGIN); 	
	l4d_star_witch_harasser =  CreateConVar("l4d_star_witch_harasser", "30", " ", FCVAR_PLUGIN); 	
	g_iVelocity = FindSendPropOffs("CBasePlayer", "m_vecVelocity[0]");
	
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		L4D2Version=true;
	}	
	else
	{
		L4D2Version=false;
	}

	AutoExecConfig(true, "l4d_starfall");
	 
	
	HookEvent("tank_killed", tank_killed);
	HookEvent("witch_killed", witch_killed);

	HookEvent("witch_harasser_set", witch_harasser_set);		
	 
	HookEvent("round_start", RoundStart);
	HookEvent("round_end", RoundEnd);
	HookEvent("finale_win", RoundEnd);
	HookEvent("mission_lost", RoundEnd);
	HookEvent("map_transition", RoundEnd);
	gamestart=false;
}
public Action:RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	gamestart=true;
}
public Action:RoundEnd(Handle:event, const String:name[], bool:dontBroadcast)
{
	gamestart=false;
}
public Action:tank_killed(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	//if(GameMode==2)return; default: userid statt new killer(victim)
	new killer = GetClientOfUserId(GetEventInt(hEvent, "attacker"));
	//if(GetRandomFloat(0.0, 100.0)< GetConVarFloat(l4d_star_tank)) def.victim
	StartStarFall(killer);
}
public Action:witch_killed(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	//if(GameMode==2)return;
	new killer = GetClientOfUserId(GetEventInt(hEvent, "userid"));
	if(GetRandomFloat(0.0, 100.0)< GetConVarFloat(l4d_star_witch) && killer>0) StartStarFall(killer);
}
public Action:witch_harasser_set(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	//if(GameMode==2)return;
	new killer = GetClientOfUserId(GetEventInt(hEvent, "userid"));
	if(GetRandomFloat(0.0, 100.0)< GetConVarFloat(l4d_star_witch_harasser) && killer>0)	StartStarFall(killer);
}

StartStarFall(client)
{
	
	decl Float:pos[3];
	
	GetClientEyePosition(client, pos);
	
	new Handle:h=CreateDataPack();
	WritePackCell(h, client);
	
	WritePackFloat(h, pos[0]);
	WritePackFloat(h, pos[1]);
	WritePackFloat(h, pos[2]);
	WritePackFloat(h,GetEngineTime());
	Rain[client][0]=0;
	CreateTimer(0.75, UpdateStarFall, h, TIMER_REPEAT|TIMER_FLAG_NO_MAPCHANGE);
}

public Action:UpdateStarFall(Handle:timer, any:h)
{  
	if(!gamestart)
	{
		return Plugin_Stop;
	}
	ResetPack(h);
	decl Float:pos[3];
	new userid=ReadPackCell(h);
 	
	pos[0]=ReadPackFloat(h);
	pos[1]=ReadPackFloat(h);
	pos[2]=ReadPackFloat(h);

	new Float:time=ReadPackFloat(h);
	new bool:over=false;
	if(GetEngineTime()-time>GetConVarFloat(l4d_star_duration) || Rain[userid][0]>148)
	{
		over=true;
		 
	}
	if(!over)
	{
	 
		decl Float: angle[3], velocity[3], hitpos[3];
		angle[0]=0.0+GetRandomFloat(-20.0, 20.0);
		angle[1]=0.0+GetRandomFloat(-20.0, 20.0);
		angle[2]=60.0;
		
		GetVectorAngles(angle, angle);
		
		GetRayHitPos2(pos, angle, hitpos, userid,true);
		new Float:dis=GetVectorDistance(pos, hitpos);
		//default 2000.0
		//default 1600.0
		if(GetVectorDistance(pos, hitpos)>1400.0)
		{
			dis=1000.0;
		}
		decl Float:t[3];
		MakeVectorFromPoints(pos, hitpos, t);
		NormalizeVector(t,t);
		ScaleVector(t, dis-40.0);
		AddVectors(pos, t, hitpos);
		
		//default 500.0
		if(dis>300.0)
		{
		
			new ent=0;	
			if(!L4D2Version) 
			{
	  
				ent=CreateEntityByName("tank_rock");
				DispatchKeyValue(ent, "model", "models/props_debris/concrete_chunk01a.mdl"); 
			}
			else
			{
				//ent=CreateEntityByName("grenade_launcher_projectile");
				//DispatchKeyValue(ent, "model", "models/w_models/weapons/w_HE_grenade.mdl");  
				ent=CreateEntityByName("tank_rock");
				DispatchKeyValue(ent, "model", "models/props_debris/concrete_chunk01a.mdl"); 
			}
			if(ent>0)
			{
				 
				SetEntProp(ent, Prop_Send, "m_iTeamNum", TagRain);

				DispatchSpawn(ent);  
				decl Float:angle2[3];
				angle2[0]=GetRandomFloat(-180.0, 180.0);
				angle2[1]=GetRandomFloat(-180.0, 180.0);
				angle2[2]=GetRandomFloat(-180.0, 180.0);
				
				velocity[0]=GetRandomFloat(-350.0, 350.0);
				velocity[1]=GetRandomFloat(-350.0, 350.0);
				velocity[2]=GetRandomFloat(-30.0, -10);
				TeleportEntity(ent, hitpos, angle2, velocity);
				ActivateEntity(ent);
	 
				AcceptEntityInput(ent, "Ignite");
				
				//SetEntityGravity(ent, GetRandomFloat(0.3, 0.7));
				 
				Rain[userid][0]++;
				Rain[userid][Rain[userid][0]]=ent;
			}
		}
		 
	}
	
	
	new c=Rain[userid][0];
	//PrintToChatAll("%d", c);
	new bool:left=false;
	decl Float:vec[3];
	for(new i=1; i<=c && i<150; i++)
	{
		new ent=Rain[userid][i];
		if(IsRock(ent))
		{
			left=true;
			GetEntDataVector(ent, g_iVelocity, vec); 
			
			new Float:v=GetVectorLength(vec);
			//new Float:v=100.0;
			//PrintToChatAll("rock %d", ent);
			if(OnGroundUnits(ent)<200.0 || v<50.0 )
			{
				Rain[userid][i]=0;
				ExplodeStar(ent, GetConVarFloat(l4d_star_explode_chance));
				//PrintToChatAll("%f %f %f ok", vec[0], vec[1], vec[2]);
				break;
			}
			else
			{
				//PrintToChatAll("%f %f %f", vec[0], vec[1], vec[2]);
			}
		}
		else
		{
			Rain[userid][i]=0;
		}
	}
	if(!left && over)
	{
		Rain[userid][0]=0;
		for(new i=1; i<=c && i<150; i++)
		{			
			new ent=Rain[userid][i];
			if(IsRock(ent))
			{
				
				RemoveEdict(ent);
			}
			Rain[userid][i]=0;
			 
		}
		CloseHandle(h);
		//PrintToChatAll("all process");
		
		return Plugin_Stop;
	}
	else if(GetEngineTime()-time>GetConVarFloat(l4d_star_duration)*3.0)
	{
		Rain[userid][0]=0;
		for(new i=1; i<=c && i<150; i++)
		{
			new ent=Rain[userid][i];
			if(IsRock(ent))
			{
				
				RemoveEdict(ent);
			}
			Rain[userid][i]=0;
		}
		CloseHandle(h);
		//PrintToChatAll("time out");
	 
		return Plugin_Stop;		
	}
	 
	return Plugin_Continue;	
	
}
bool:IsRock(ent)
{
	if(ent>0 && IsValidEntity(ent) && IsValidEdict(ent))
	{
		decl String:classname[20];
		GetEdictClassname(ent, classname, 20);
 	
		if(StrEqual(classname, "tank_rock", true))
		{
			return true;
		}
	}
	return false;
}
public Float:OnGroundUnits(i_Ent)
{
	if (!(GetEntityFlags(i_Ent) & (FL_ONGROUND)))
	{ 
		decl Handle:h_Trace, Float:f_Origin[3], Float:f_Position[3], Float:f_Down[3] = { 90.0, 0.0, 0.0 }
		
		GetEntPropVector(i_Ent, Prop_Send, "m_vecOrigin", f_Origin)
		h_Trace = TR_TraceRayFilterEx(f_Origin, f_Down, CONTENTS_SOLID|CONTENTS_MOVEABLE, RayType_Infinite, TraceRayDontHitSelfAndLive, i_Ent)

		if (TR_DidHit(h_Trace))
		{
			decl Float:f_Units
			TR_GetEndPosition(f_Position, h_Trace)
			
			f_Units = f_Origin[2] - f_Position[2]

			CloseHandle(h_Trace)
			
			return f_Units
		} 
	
		CloseHandle(h_Trace)
	} 
	
	return 0.0
}
GetRayHitPos2(Float:pos[3], Float: angle[3], Float:hitpos[3], ent=0, bool:useoffset=false)
{
	new Handle:trace ;
	new hit=0;
	
	trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, TraceRayDontHitSelfAndLive, ent);
	if(TR_DidHit(trace))
	{
		TR_GetEndPosition(hitpos, trace);
		hit=TR_GetEntityIndex( trace);
	}
	CloseHandle(trace);
	
	if(useoffset)
	{
		decl Float:v[3];
		MakeVectorFromPoints(hitpos, pos, v);
		NormalizeVector(v, v);
		ScaleVector(v, 15.0);
		AddVectors(hitpos, v, hitpos);
		
	}
	return hit;
}

public OnConfigExecuted()
{
	Set();
}
Set()
{
 
}
public CvarChanged(Handle:convar, const String:oldValue[], const String:newValue[])
{
	Set();
}
public OnMapStart()
{
	PrecacheModel("models/props_junk/propanecanister001a.mdl", true);
	PrecacheModel("models/props_junk/gascan001a.mdl", true);
	 
	PrecacheParticle("gas_explosion_pump");
	PrecacheParticle("gas_explosion_main");
	
	if(L4D2Version)
	{
		g_sprite = PrecacheModel("materials/sprites/laserbeam.vmt");	
		
	}
	else
	{
		g_sprite = PrecacheModel("materials/sprites/laser.vmt");	
 
	}

}
 

CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
		target[1]=source[1];
			target[2]=source[2];
}
GetRayHitPos(Float:pos[3], Float: angle[3], Float:hitpos[3], self, bool:nothitsurvivor=true)
{
	new Handle:trace ;
	new hit=0;
	if(nothitsurvivor)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, TraceRayDontHitSelfAndSurvivor, self);
	}
	else
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, TraceRayDontHitSelf, self);
	}
	if(TR_DidHit(trace))
	{
			
		TR_GetEndPosition(hitpos, trace);
		hit=TR_GetEntityIndex( trace);
			
	}
	CloseHandle(trace);
	return hit;
}
Float:GetRayDistance(Float:pos[3], Float: angle[3], self, bool:nothitsurvivor=true)
{
	decl Float:hitpos[3];
	GetRayHitPos(pos, angle,hitpos, self, nothitsurvivor);
	return GetVectorDistance( pos,  hitpos);
}
IfTwoPosVisible(Float:pos1[3], Float:pos2[3], self)
{
	new bool:r=true;
	new Handle:trace = TR_TraceRayFilterEx(pos2, pos1, MASK_SOLID, RayType_EndPoint, TraceRayDontHitSelfAndLive,self);
	if(TR_DidHit(trace))
	{
		r=false;
	}
 	CloseHandle(trace);
	return r;
}
 
 
ShowLarserByAngle(Float:pos1[3], Float:angle[3], self, flag=0, Float:life=0.06)
{
 
	new Float:pos2[3];
	 
	new Handle:trace = TR_TraceRayFilterEx(pos1, angle, MASK_SOLID, RayType_Infinite, TraceRayDontHitSelf, self);
	if(TR_DidHit(trace))
	{
		TR_GetEndPosition(pos2, trace);
	}
	CloseHandle(trace);
	ShowLarserByPos(pos1, pos2, flag, life);	
 
}
ShowLarserByAngleAndDistance(Float:pos1[3], Float:angle[3], Float:dis, flag=0, Float:life=0.06)
{
 
	new Float:pos2[3];
	GetAngleVectors(angle, pos2, NULL_VECTOR,NULL_VECTOR);
	NormalizeVector(pos2, pos2);
	ScaleVector(pos2, dis);
	AddVectors(pos1, pos2, pos2);
	ShowLarserByPos(pos1, pos2, flag, life);	
 
}
ShowLarserByPos(Float:pos1[3], Float:pos2[3], flag=0, Float:life=0.06)
{
	decl color[4];
	if(flag==0)
	{
		color[0] = 200; 
		color[1] = 200;
		color[2] = 200;
		color[3] = 230;
	}
	else
	{
		color[0] = 200; 
		color[1] = 0;
		color[2] = 0;
		color[3] = 230;
	}
	
	 
	new Float:width1=0.5;
	new Float:width2=0.5;		
	if(L4D2Version)
	{
		width2=0.3;
		width2=0.3;
	}
 	
	TE_SetupBeamPoints(pos1, pos2, g_sprite, 0, 0, 0, life, width1, width2, 1, 0.0, color, 0);
	TE_SendToAll();
}

ExplodeStar(entity, Float:explodechance=100.0)
{
	decl String:classname[20];
	GetEdictClassname(entity, classname, 20);
 	
	if(!StrEqual(classname, "tank_rock", true))
	{
		return;
	}
		
	new ent1 = 0;
	new ent2 = 0;
	new ent3 = 0;
	new Float:pos[3];
	GetEntPropVector(entity, Prop_Send, "m_vecOrigin", pos);	
	pos[2]+=50.0;
	if(GetRandomFloat(0.0, 100.0)<explodechance)
	{
		//AcceptEntityInput(entity, "kill", -1, -1);
		RemoveEdict(entity);	
		ent1=CreateEntityByName("prop_physics"); 
					
		DispatchKeyValue(ent1, "model", "models/props_junk/propanecanister001a.mdl"); 
		DispatchSpawn(ent1); 
		TeleportEntity(ent1, pos, NULL_VECTOR, NULL_VECTOR);
		ActivateEntity(ent1);
		SetEntityRenderMode(ent1, RenderMode:3);
		SetEntityRenderColor(ent1, 0, 0, 0, 0);
		AcceptEntityInput(ent1, "Ignite", -1, -1);
		AcceptEntityInput(ent1, "Break", -1, -1);
		
		 
		new Float:damage=GetConVarFloat(l4d_star_damage);
		new Float:radius=GetConVarFloat(l4d_star_radius);
		new Float:pushforce=GetConVarFloat(l4d_star_pushforce);
		
		new pointHurt = CreateEntityByName("point_hurt");   
 	
		DispatchKeyValueFloat(pointHurt, "Damage", damage);        
		DispatchKeyValueFloat(pointHurt, "DamageRadius", radius);     
		DispatchKeyValue(pointHurt, "DamageDelay", "0.0");   
		DispatchSpawn(pointHurt);
		TeleportEntity(pointHurt, pos, NULL_VECTOR, NULL_VECTOR);  
		AcceptEntityInput(pointHurt, "Hurt", -1);    
		CreateTimer(0.1, DeletePointHurt, pointHurt); 
	
		return;
		
		new push = CreateEntityByName("point_push");         
  		DispatchKeyValueFloat (push, "magnitude", pushforce);                     
		DispatchKeyValueFloat (push, "radius", radius*1.0);                     
  		SetVariantString("spawnflags 24");                     
		AcceptEntityInput(push, "AddOutput");
 		DispatchSpawn(push);   
		TeleportEntity(push, pos, NULL_VECTOR, NULL_VECTOR);  
 		AcceptEntityInput(push, "Enable", -1, -1);
		CreateTimer(0.5, DeletePushForce, push);
		//ShowParticle(pos, "gas_explosion_pump", 3.0);	
	}
}
 
 
 
public DeleteEntity(any:ent, String:name[])
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, name, false))
		 {
			AcceptEntityInput(ent, "Kill"); 
			RemoveEdict(ent);
		 }
	 }
}
 
public Action:DeletePushForce(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_push", false))
				{
 					AcceptEntityInput(ent, "Disable");
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
	 }
}
public Action:DeletePointHurt(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_hurt", false))
				{
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
		 }

}
public ShowParticle(Float:pos[3], String:particlename[], Float:time)
{
 new particle = CreateEntityByName("info_particle_system");
 if (IsValidEdict(particle))
 {
		TeleportEntity(particle, pos, NULL_VECTOR, NULL_VECTOR);
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(time, DeleteParticles, particle);
 } 
}
 
public PrecacheParticle(String:particlename[])
{
 new particle = CreateEntityByName("info_particle_system");
 if (IsValidEdict(particle))
 {
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(0.01, DeleteParticles, particle);
 } 
}

public Action:DeleteParticles(Handle:timer, any:particle)
{
	 if (IsValidEntity(particle))
	 {
		 decl String:classname[64];
		 GetEdictClassname(particle, classname, sizeof(classname));
		 if (StrEqual(classname, "info_particle_system", false))
			{
				AcceptEntityInput(particle, "stop");
				AcceptEntityInput(particle, "kill");
				RemoveEdict(particle);
			}
	 }
}
public bool:TraceRayDontHitSelfAndSurvivor(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==2)
		{
			return false;
		}
	}
	return true;
}
public bool:TraceRayDontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	return true;
}
public bool:TraceRayDontHitSelfAndLive(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity))
		{
			return false;
		}
	}
	return true;
}