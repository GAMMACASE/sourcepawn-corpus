/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <sdktools_functions>
#include <sdkhooks>
#define SOUND2 "weapons/grenade_launcher/grenadefire/grenade_launcher_explode_1.wav"
#define SOUNDMISSILE "physics/destruction/ExplosiveGasLeak.wav" 
#define SOUNDMISSILE2 "physics/destruction/explosivegasleak.wav" 

#define FilterSelf 0
#define FilterSelfAndPlayer 1
#define FilterSelfAndSurvivor 2
#define FilterSelfAndInfected 3
#define FilterSelfAndPlayerAndCI 4
 
new Handle:l4d_missile_radius ;
new Handle:l4d_missile_damage ;
new Handle:l4d_missile_push ;
new Handle:l4d_missile_limit ;
new Handle:l4d_missile_kills ;
new Handle:l4d_missile_tracefactor ;
 
new Handle:w_pushforce_vlimit ;
new Handle:w_pushforce_factor ;
new Handle:w_pushforce_tankfactor ;
new Handle:w_pushforce_survivorfactor ;

new bool:gamestart=false;
   
new Float: UseTime[MAXPLAYERS+1];
new Float: HookTime[MAXPLAYERS+1];
new Bullet[MAXPLAYERS+1];
 new bool:Hooked[MAXPLAYERS+1];
new GrenadeLauncher[MAXPLAYERS+1];
new MissleModel[MAXPLAYERS+1];
new MissileType[MAXPLAYERS+1];
new Enemy[MAXPLAYERS+1];
new Float: limit;
new Float: producetime;
 
new g_iVelocity ;
new L4D2Version;
new g_sprite;
 
public Plugin:myinfo = 
{
	name = "Missile",
	author = "Pan Xiaohai",
	description = "Missile , L4D2 only",
	version = "1.0",
	url = "<- URL ->"
}

public OnPluginStart()
{
	RegConsoleCmd("miss_help", MissileHelp);
	
	l4d_missile_radius = CreateConVar("l4d_missile_radius", "250.0", "grenade explode radius", FCVAR_PLUGIN);
	l4d_missile_damage = CreateConVar("l4d_missile_damage", "800.0", "damage", FCVAR_PLUGIN);
	l4d_missile_push = CreateConVar("l4d_missile_push", "1200", "push forece", FCVAR_PLUGIN);
	
	
	l4d_missile_limit = CreateConVar("l4d_missile_limit", "30", "grenade limit", FCVAR_PLUGIN);
 	l4d_missile_kills = CreateConVar("l4d_missile_kills", "10", "how many kills reward a grenade", FCVAR_PLUGIN);	
 	l4d_missile_tracefactor = CreateConVar("l4d_missile_tracefactor", "1.5", "trace factor [0.5, 3.0]", FCVAR_PLUGIN);	
	 
	w_pushforce_vlimit = CreateConVar("l4d_missile_pushforce_vlimit", "200", "voilicity limit", FCVAR_PLUGIN);
	w_pushforce_factor = CreateConVar("l4d_missile_pushforce_factor", "0.8", "pushforce factor", FCVAR_PLUGIN);
	w_pushforce_tankfactor = CreateConVar("l4d_missile_pushforce_tankfactor", "0.15", "pushforce factor for Tank", FCVAR_PLUGIN);
	w_pushforce_survivorfactor = CreateConVar("l4d_missile_pushforce_survivorfactor", "0.4", "pushforce factor for Survivors", FCVAR_PLUGIN);
	
	
	g_iVelocity = FindSendPropOffs("CBasePlayer", "m_vecVelocity[0]");
	
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		L4D2Version=true;
	}	
	else
	{
		L4D2Version=false;
	}

	AutoExecConfig(true, "l4d2_missile");
 
	if(L4D2Version)
	{ 
		HookEvent("player_death", Event_PlayerDeath);
		HookEvent("infected_death", Event_InfectedDeath);	
	 
		HookEvent("weapon_fire", weapon_fire);
		//HookEvent("grenade_bounce", grenade_bounce);
		
		HookEvent("round_start", round_start);
		HookEvent("round_end", round_end);
		HookEvent("finale_win", round_end);
		HookEvent("mission_lost", round_end);
		HookEvent("map_transition", round_end);
		ResetAllState();
		Set();
		
	}
	gamestart=false;
}
 
 public Action:MissileHelp(client,args)
{
	PrintToChat(client, "[MISS] Owners of a SHOTGUN can use 3 missile types.\nFor every 20 killed infected you get 1 missile.");
	PrintToChat(client, "[MISS] Miss1 = Gren. Launcher. Stand still, Press USE and shoot.\nMiss2 = Automatic Tracking Missile. DUCK and press USE while firing");
	PrintToChat(client, "[MISS] Miss3 = Laserguided. Laser-Guided Missile.\nYou must be walking, press USE and shoot.\n Missile follows your mouse during flight");
}

 public Action:weapon_fire(Handle:event, const String:name[], bool:dontBroadcast)
{
	 
 	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	 
	if(GetClientTeam(client)==2)
	{
		if(GetClientButtons(client) & IN_USE )
		{
			decl String:item[65];
			GetEventString(event, "weapon", item, 65);
			if( StrContains(item, "shot")>=0 )
			{
				new Float:time=GetEngineTime();
				Grenade(client, time);
			}
			
		}
		
		
	}
}
new upgradekillcount[MAXPLAYERS+1];
new totalkillcount[MAXPLAYERS+1];
UpGrade(x, kill)
{
 	upgradekillcount[x]+=kill;
	totalkillcount[x]+=kill;
	new v=upgradekillcount[x]/GetConVarInt(l4d_missile_kills);
	upgradekillcount[x]=upgradekillcount[x]%GetConVarInt(l4d_missile_kills);
	Bullet[x]+=v;
	if (v>0) 
	{
		PrintCenterText(x, "Infected killed: %d", totalkillcount[x]);
		if(Bullet[x]>GetConVarInt(l4d_missile_limit))Bullet[x]=GetConVarInt(l4d_missile_limit);
		PrintHintText(x, "+ Missile %d", Bullet[x]);
	}
}
public Action:Event_InfectedDeath(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	new attacker = GetClientOfUserId(GetEventInt(hEvent, "attacker"));
	if (attacker<=0) 
	{
 		return Plugin_Continue;
	}
	if(IsClientInGame(attacker) )
	{
		if(GetClientTeam(attacker) == 2)
		{
			UpGrade(attacker, 1);
		}
	}
 
	return Plugin_Continue;
}
public Action:Event_PlayerDeath(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(hEvent, "userid"));
 	new attacker = GetClientOfUserId(GetEventInt(hEvent, "attacker"));
	if (victim <= 0 || attacker<=0) 
	{
 		return Plugin_Continue;
	}
	if(IsClientInGame(attacker) )
	{
		if(GetClientTeam(attacker) == 2)
		{
			if(IsClientInGame(victim))
			{
				if( GetClientTeam(victim) == 3 )
				{
					new bool:headshot=GetEventBool(hEvent, "headshot");
					if(headshot)
					{
						UpGrade(attacker, 5);
					}
					else
					{
						UpGrade(attacker, 3);
					}
				}
			}
		}
	}
 
	return Plugin_Continue;
}

Grenade(client, Float:time)
{
 
	if( time-UseTime[client]>1.0)
	{
		if(Bullet[client]-1>=0)// || true)
		{
 	 
			Bullet[client]=Bullet[client]-1;
			UseTime[client]=time;
			HookTime[client]=time;
			Fire(client, 1050.0);
			PrintHintText(client, "missile %d", Bullet[client]);
			 
		}
		else
		{
			PrintHintText(client, "not enough missile");
		}
	}	
}

Fire(userid, Float:force)
{
	decl Float:pos[3];
	decl Float:angles[3];
	decl Float:velocity[3];
	GetClientEyePosition(userid, pos);
	 
	GetClientEyeAngles(userid, angles);
	GetEntDataVector(userid, g_iVelocity, velocity);
	
	angles[0]-=5.0;
	
	velocity[0] = force * Cosine(DegToRad(angles[1])) * Cosine(DegToRad(angles[0]));
	velocity[1] = force * Sine(DegToRad(angles[1])) * Cosine(DegToRad(angles[0]));
	velocity[2] = force * Sine(DegToRad(angles[0])) * -1.0;

	//new Float:force=GetConVarFloat(w_laugch_force);

	GetAngleVectors(angles, velocity, NULL_VECTOR, NULL_VECTOR);
	NormalizeVector(velocity, velocity);
	ScaleVector(velocity, force);
	
	{
		new Float:B=-3.1415926/2.0;
		decl Float:vec[3];
		decl Float:vec2[3];
		GetAngleVectors(angles,vec, NULL_VECTOR, NULL_VECTOR);
		GetAngleVectors(angles,vec2, NULL_VECTOR, NULL_VECTOR);
		new Float:x0=vec[0];
		new Float:y0=vec[1];
		new Float:x1=x0*Cosine(B)-y0*Sine(B);
		new Float:y1=x0*Sine(B)+y0*Cosine(B);
		vec[0]=x1;
		vec[1]=y1;
		vec[2]=0.0;
		NormalizeVector(vec,vec);
		NormalizeVector(vec2,vec2);
		ScaleVector(vec, 12.0);
		ScaleVector(vec2, 30.0);
		AddVectors(pos, vec, pos);
		AddVectors(pos, vec2, pos);
	}
	
	new ent = 0;
	new button=GetClientButtons(userid);
 	if(!L4D2Version )//|| button & IN_SPEED  || button & IN_DUCK)  
	{
		ent=CreateEntityByName("molotov_projectile");  
		DispatchKeyValue(ent, "model", "models/w_models/weapons/w_eq_molotov.mdl");  
	}
	else
	{
		ent=CreateEntityByName("grenade_launcher_projectile");
		DispatchKeyValue(ent, "model", "models/w_models/weapons/w_HE_grenade.mdl");  

	}
	//SetEntPropEnt(ent, Prop_Data, "m_hOwnerEntity", userid)	;	
	DispatchSpawn(ent);  
	
	TeleportEntity(ent, pos, NULL_VECTOR, velocity);
	ActivateEntity(ent);
	new ment=0;
	{
		new String:tname[20];
		Format(tname, 20, "missile%d", ent);
		DispatchKeyValue(ent, "targetname", tname);
		
		ment=CreateEntityByName("prop_dynamic");
		SetEntPropEnt(ment, Prop_Data, "m_hOwnerEntity", userid)	;			
		DispatchKeyValue(ment, "parentname", tname);
		DispatchKeyValue(ment, "model", "models/missiles/f18_agm65maverick.mdl");  
		DispatchSpawn(ment); // Spawn descriped explosion
		TeleportEntity(ment, pos, NULL_VECTOR, NULL_VECTOR);
		SetVariantString(tname);
		AcceptEntityInput(ment, "SetParent",ment, ment, 0);
		
	}
 	AcceptEntityInput(ent, "Ignite");
 
	if(GrenadeLauncher[userid] > 0 && IsValidEntity(GrenadeLauncher[userid]) && IsValidEdict(GrenadeLauncher[userid]))
	{
		RemoveEdict(GrenadeLauncher[userid]);
		RemoveEdict(MissleModel[userid]);
	}
	MissleModel[userid]=ment;
	GrenadeLauncher[userid]=ent;
	Enemy[userid]=-1;
	UnHook(userid);
	MissileType[userid]=0;
	if(button & IN_SPEED)
	{
		MissileType[userid]=1;
		Hook(userid);
		SetEntityGravity(ent, 0.01);

	}
	else if(button & IN_DUCK)
	{
		MissileType[userid]=2;
		Hook(userid);
		SetEntityGravity(ent, 0.01);
	}
	else if(L4D2Version)
	{	
		if(!L4D2Version)SetEntityGravity(ent, 0.6);
		else SetEntityGravity(ent, 0.4);	
		MissileType[userid]=0;
		Hook(userid);
	}
	if(L4D2Version)	EmitSoundToAll(SOUNDMISSILE2, 0, SNDCHAN_WEAPON, SNDLEVEL_TRAFFIC, SND_NOFLAGS, SNDVOL_NORMAL, 100, _, pos, NULL_VECTOR, false, 0.0);	
	else EmitSoundToAll(SOUNDMISSILE, 0, SNDCHAN_WEAPON, SNDLEVEL_TRAFFIC, SND_NOFLAGS, SNDVOL_NORMAL, 100, _, pos, NULL_VECTOR, false, 0.0);	
	return;
}

public Action:grenade_bounce(Handle:h_Event, const String:s_Name[], bool:b_DontBroadcast)
{
	new userid = GetClientOfUserId(GetEventInt(h_Event, "userid"));
	GrenadeHit(userid);
}

Hook(client)
{
	if(!Hooked[client])
	{

		Hooked[client]=true;
		SDKHook(client, SDKHook_PreThinkPost, PreThinkPostHook);
	}
 
}
UnHook(client)
{
	if(Hooked[client])
	{
		
		Hooked[client]=false;
		SDKUnhook(client, SDKHook_PreThinkPost, PreThinkPostHook);
	}
	 
}
 
public PreThinkPostHook(client)
{
	new bool:unhook=false;
    if(gamestart && IsClientInGame(client) && IsPlayerAlive(client))
	{
   		decl String:g_classname[30];
       	if(GrenadeLauncher[client]>0 && IsValidEntity(GrenadeLauncher[client]) && IsValidEdict(GrenadeLauncher[client]))
		{
			GetEdictClassname(GrenadeLauncher[client], g_classname, 30);
			if( StrEqual(g_classname, "grenade_launcher_projectile", true)  || StrEqual(g_classname, "molotov_projectile" ))
			{
				new Float:time=GetEngineTime();
				new Float:duration=time-HookTime[client];
			 
				HookTime[client]=time;	
				if(MissileType[client]==0)Missile(client, GrenadeLauncher[client], duration);
				if(MissileType[client]==2)TraceMissile(client, GrenadeLauncher[client], duration);
				if(MissileType[client]==1)LaserGuideMissile(client, GrenadeLauncher[client], duration);
 
			}
		}
		else
		{
			unhook=true;
		}
	}
	else
	{
		unhook=true;

	}
	if(unhook)
	{
		GrenadeLauncher[client]=0;
		MissleModel[client]=0;
		Hooked[client]=false;
		SDKUnhook(client, SDKHook_PreThinkPost, PreThinkPostHook);	
	}
}
Missile(client, ent, Float:duration)
{
	decl Float:missionangle[3], voffset[3];
 	decl Float:missilepos[3];
	decl Float:velocitymissile[3];
	GetEntPropVector(GrenadeLauncher[client], Prop_Send, "m_vecOrigin", missilepos);
	GetEntDataVector(GrenadeLauncher[client], g_iVelocity, velocitymissile);
	NormalizeVector(velocitymissile,velocitymissile);
 	CopyVector(velocitymissile, voffset);
	ScaleVector(voffset, 180.0);
	AddVectors(missilepos, voffset, missilepos);

	decl Float:temp[3];
	GetVectorAngles(velocitymissile, missionangle);
	new Float:disenemy=CalRay(missilepos, missionangle, 0.0, 0.0, temp, MissleModel[client], false, FilterSelf);
	//PrintToChatAll("%f", disenemy);
	if(disenemy<30.0)
	{
		GrenadeHit(client);
	}
 
}
LaserGuideMissile(client, ent, Float:duration)
{
	decl Float:angle[3], voffset[3];
	decl Float:pos[3];
	decl Float:targetpos[3];
	decl Float:missilepos[3];
	decl Float:velocitymissile[3];
	GetClientEyePosition(client, pos);
	GetClientEyeAngles(client, angle);
	GetEntPropVector(GrenadeLauncher[client], Prop_Send, "m_vecOrigin", missilepos);
	GetEntDataVector(GrenadeLauncher[client], g_iVelocity, velocitymissile);
	NormalizeVector(velocitymissile,velocitymissile);
	
	decl Float:tracedirectoin[3];
	MakeVectorFromPoints(missilepos, targetpos, tracedirectoin);	
	NormalizeVector(tracedirectoin, tracedirectoin);	
	
 	CopyVector(tracedirectoin, voffset);
	ScaleVector(voffset, 180.0);
	AddVectors(missilepos, voffset, missilepos);
	
	
	decl Float:missionangle[3], temp[3];
	GetVectorAngles(tracedirectoin, missionangle);
	new Float:disenemy=CalRay(missilepos, missionangle, 0.0, 0.0, temp, MissleModel[client], false, FilterSelf);
	
	GetRayHitPos(pos, angle, targetpos, client, FilterSelfAndSurvivor);
	
	ShowLarserByPos(missilepos, targetpos);

	
	new Float:a=GetAngle(velocitymissile, tracedirectoin);
	 
	new Float:amax=3.14159 * duration *GetConVarFloat(l4d_missile_tracefactor);
	 
	if(a> amax )a=amax ;
 
	ScaleVector(tracedirectoin ,a);
	//PrintToChat(client, "%f %f %f", tracedirectoin[0], tracedirectoin[1], tracedirectoin[2]);
	AddVectors(tracedirectoin, velocitymissile, tracedirectoin);
	NormalizeVector( tracedirectoin, tracedirectoin);
	ScaleVector(tracedirectoin, 300.0);
	TeleportEntity(ent, NULL_VECTOR,  NULL_VECTOR ,tracedirectoin);
	SetEntityGravity(ent, 0.01);
	AcceptEntityInput(ent, "Ignite");
	if(disenemy<10.0)
	{
		GrenadeHit(client);
	}
 
}
TraceMissile(client, ent, Float:duration)
{
   		
	decl Float:posmissile[3], voffset[3];			
	decl Float:velocitymissile[3];	
	
	GetEntPropVector(ent, Prop_Send, "m_vecOrigin", posmissile);	
	GetEntDataVector(ent, g_iVelocity, velocitymissile);
	NormalizeVector(velocitymissile, velocitymissile);
	
	CopyVector(velocitymissile, voffset);
	ScaleVector(voffset, 180.0);
	AddVectors(posmissile, voffset, posmissile);
	
	
	
 	new enemy=GetEnemy(posmissile, velocitymissile, 3);
	decl Float:velocityenemy[3], vtrace[3];
	
	vtrace[0]=vtrace[1]=vtrace[2]=0.0;	
	new bool:visible=false;
	decl Float:missionangle[3];
 
	new Float:disenemy=1000.0;
	if(enemy>0)	
	{
		decl Float:posenemy[3];
		GetClientEyePosition(enemy, posenemy);
		
		disenemy=GetVectorDistance(posmissile, posenemy);
		
		visible=IfTwoPosVisible(posmissile, posenemy, ent);
	
		GetEntDataVector(enemy, g_iVelocity, velocityenemy);

		ScaleVector(velocityenemy, duration);
		
		//PrintToChatAll("%f %f %f", velocityenemy[0], velocityenemy[1], velocityenemy[2]);	
		AddVectors(posenemy, velocityenemy, posenemy);
		MakeVectorFromPoints(posmissile, posenemy, vtrace);
	
	
	}
	if(enemy!=Enemy[client])
	{
		if(enemy!=0)PrintCenterText(client, "Missile Locked On: %N", enemy);
		else PrintCenterText(client, "No target locked");
		Enemy[client]=enemy;
	}	 
	////////////////////////////////////////////////////////////////////////////////////
	GetVectorAngles(velocitymissile, missionangle);
 
	decl Float:vleft[3], vright[3], vup[3], vdown[3], vfront[3];
	decl Float:vv1[3], vv2[3],vv3[3], vv4[3], vv5[3], vv6[3], vv7[3], vv8[3];	
	
	vfront[0]=vfront[1]=vfront[2]=0.0;	
	 
	new Float:factor2=0.5; 
	new Float:factor1=0.2; 
	new Float:t;
	new Float:base=500.0;
	if(visible)
	{
		base=80.0;
	}
	{
		//PrintToChatAll("%f %f %f %f %f",front, up, down, left, right);
		new flag=FilterSelfAndInfected;
		new bool:print=false;
		new self=MissleModel[client];
		new Float:front=CalRay(posmissile, missionangle, 0.0, 0.0, vfront, self, print, flag);
		print=false;
		disenemy=CalRay(posmissile, missionangle, 0.0, 0.0, vfront, self, print, FilterSelf);
		new Float:down=CalRay(posmissile, missionangle, 90.0, 0.0, vdown, self, print,  flag);
		new Float:up=CalRay(posmissile, missionangle, -90.0, 0.0, vup, self, print);
		new Float:left=CalRay(posmissile, missionangle, 0.0, 90.0, vleft, self, print, flag);
		new Float:right=CalRay(posmissile, missionangle, 0.0, -90.0, vright, self, print, flag);
		
		new Float:f1=CalRay(posmissile, missionangle, 30.0, 0, vv1, self, print, flag);
		new Float:f2=CalRay(posmissile, missionangle, 30.0, 45.0, vv2, self, print, flag);
		new Float:f3=CalRay(posmissile, missionangle, 0.0, 45.0, vv3, self, print, flag);
		new Float:f4=CalRay(posmissile, missionangle, -30.0, 45.0, vv4, self, print, flag);
		new Float:f5=CalRay(posmissile, missionangle, -30.0, 0.0, vv5, self, print,flag);
		new Float:f6=CalRay(posmissile, missionangle, -30.0, -45.0, vv6, self, print, flag);	
		new Float:f7=CalRay(posmissile, missionangle, 0.0, -45.0, vv7, self, print, flag);
		new Float:f8=CalRay(posmissile, missionangle, 30.0, -45.0, vv8, self, print, flag);					
		  
		NormalizeVector(vfront,vfront);
		NormalizeVector(vup,vup);
		NormalizeVector(vdown,vdown);
		NormalizeVector(vleft,vleft);
		NormalizeVector(vright,vright);
		NormalizeVector(vtrace, vtrace);

		NormalizeVector(vv1,vv1);
		NormalizeVector(vv2,vv2);
		NormalizeVector(vv3,vv3);
		NormalizeVector(vv4,vv4);
		NormalizeVector(vv5,vv5);
		NormalizeVector(vv6,vv6);
		NormalizeVector(vv7,vv7);
		NormalizeVector(vv8,vv8);
		 
		
		
		if(front>base) front=base;
		if(up>base) up=base;
		if(down>base) down=base;
		if(left>base) left=base;
		if(right>base) right=base;
		
		if(f1>base) f1=base;	
		if(f2>base) f2=base;	
		if(f3>base) f3=base;	
		if(f4>base) f4=base;	
		if(f5>base) f5=base;	
		if(f6>base) f6=base;	
		if(f7>base) f7=base;	
		if(f8>base) f8=base;	
	 
 
		t=-1.0*factor1*(base-front)/base;
		ScaleVector( vfront, t);
		
		t=-1.0*factor1*(base-up)/base;
		ScaleVector( vup, t);
		
		t=-1.0*factor1*(base-down)/base;
		ScaleVector( vdown, t);
		
		t=-1.0*factor1*(base-left)/base;
		ScaleVector( vleft, t);
		
		t=-1.0*factor1*(base-right)/base;
		ScaleVector( vright, t);
		
		t=-1.0*factor1*(base-f1)/f1;
		ScaleVector( vv1, t);
		
		t=-1.0*factor1*(base-f2)/f2;
		ScaleVector( vv2, t);
		
		t=-1.0*factor1*(base-f3)/f3;
		ScaleVector( vv3, t);
		
		t=-1.0*factor1*(base-f4)/f4;
		ScaleVector( vv4, t);
		
		t=-1.0*factor1*(base-f5)/f5;
		ScaleVector( vv5, t);
		
		t=-1.0*factor1*(base-f6)/f6;
		ScaleVector( vv6, t);
		
		t=-1.0*factor1*(base-f7)/f7;
		ScaleVector( vv7, t);
		
		t=-1.0*factor1*(base-f8)/f8;
		ScaleVector( vv8, t);
		

		
		if(disenemy>=500.0)disenemy=500.0;
		t=1.0*factor2*(1000.0-disenemy)/500.0;
		ScaleVector( vtrace, t);							

		AddVectors(vfront, vup, vfront);
		AddVectors(vfront, vdown, vfront);
		AddVectors(vfront, vleft, vfront);
		AddVectors(vfront, vright, vfront);


		AddVectors(vfront, vv1, vfront);
		AddVectors(vfront, vv2, vfront);
		AddVectors(vfront, vv3, vfront);
		AddVectors(vfront, vv4, vfront);
		AddVectors(vfront, vv5, vfront);
		AddVectors(vfront, vv6, vfront);
		AddVectors(vfront, vv7, vfront);
		AddVectors(vfront, vv8, vfront);

		
		AddVectors(vfront, vtrace, vfront);	
		NormalizeVector(vfront, vfront);
	}
	
	new Float:a=GetAngle(vfront, velocitymissile);			 
	new Float:amax=3.14159*duration*GetConVarFloat(l4d_missile_tracefactor);
	 
	if(a> amax )a=amax ;
	
	ScaleVector(vfront ,a);
	
	//PrintToChat(client, "max %f %f  ",amax , a);
	
	//PrintToChatAll("%f %f %f", tracevec[0], tracevec[1], tracevec[2]);	
	AddVectors(velocitymissile, vfront, velocitymissile);
	
	//NormalizeVector(velocitymissile,velocitymissile);
	//PrintToChat(client, "%f  %f %f", velocitymissile[0], velocitymissile[0], velocitymissile[0]);   					
	//SetEntityGravity(ent, 0.01);
	ScaleVector(velocitymissile,540.0);
	 
	
	TeleportEntity(ent, NULL_VECTOR,  NULL_VECTOR ,velocitymissile);
	SetEntityGravity(ent, 0.01);
	AcceptEntityInput(ent, "Ignite");
	if(disenemy<30.0)
	{
		GrenadeHit(client);
	}
		 
}
GetEnemy(Float:pos[3], Float:vec[3], gteam)
{
	new Float:min=4.0;
	decl Float:pos2[3];
	new Float:t;
	new s=0;
	for(new client = 1; client <= MaxClients; client++)
	{
		if(IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client)==gteam )
		{
			GetClientEyePosition(client, pos2);
			MakeVectorFromPoints(pos, pos2, pos2);
			t=GetAngle(vec, pos2);
			//PrintToChatAll("%N %f", client, 360.0*t/3.1415926/2.0);
			if(t<=min)
			{
				min=t;
				s=client;
			}
		}
	}
	return s;
}
IfTwoPosVisible(Float:pos1[3], Float:pos2[3], self)
{
	new bool:r=true;
	new Handle:trace = TR_TraceRayFilterEx(pos2, pos1, MASK_SOLID, RayType_EndPoint, DontHitSelfAndInfected,self);
	if(TR_DidHit(trace))
	{
		r=false;
	}
 	CloseHandle(trace);
	return r;
}
Float:CalRay(Float:posmissile[3], Float:angle[3], Float:offset1, Float:offset2,   Float:force[3], ent, bool:printlaser=true, flag=FilterSelf) 
{
	

	decl Float:ang[3];
	CopyVector(angle, ang);
	ang[0]+=offset1;
	ang[1]+=offset2;
	GetAngleVectors(ang, force, NULL_VECTOR,NULL_VECTOR);
	new Float:dis=GetRayDistance(posmissile, ang, ent, flag) ;	
	if(printlaser)ShowLarserByAngleAndDistance(posmissile, ang, dis*0.5);
	//PrintToChatAll("%f %f, %f", dis, offset1, offset2);
	return dis;
}
ShowLarserByAngleAndDistance(Float:pos1[3], Float:angle[3], Float:dis, flag=0, Float:life=0.06)
{
 
	new Float:pos2[3];
	GetAngleVectors(angle, pos2, NULL_VECTOR,NULL_VECTOR);
	NormalizeVector(pos2, pos2);
	ScaleVector(pos2, dis);
	AddVectors(pos1, pos2, pos2);
	ShowLarserByPos(pos1, pos2, flag, life);	
 
}
ShowLarserByPos(Float:pos1[3], Float:pos2[3], flag=0, Float:life=0.06)
{
	decl color[4];
	if(flag==0)
	{
		color[0] = 200; 
		color[1] = 200;
		color[2] = 200;
		color[3] = 230;
	}
	else
	{
		color[0] = 200; 
		color[1] = 0;
		color[2] = 0;
		color[3] = 230;
	}
	
	 
	new Float:width1=0.5;
	new Float:width2=0.5;		
	if(L4D2Version)
	{
		width2=0.3;
		width2=0.3;
	}
 	
	TE_SetupBeamPoints(pos1, pos2, g_sprite, 0, 0, 0, life, width1, width2, 1, 0.0, color, 0);
	TE_SendToAll();
}
CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
		target[1]=source[1];
			target[2]=source[2];
}
Float:GetRayDistance(Float:pos[3], Float: angle[3], self, flag)
{
	decl Float:hitpos[3];
	GetRayHitPos(pos, angle, hitpos, self, flag);
	return GetVectorDistance( pos,  hitpos);
}
Float:GetAngle(Float:x1[3], Float:x2[3])
{
	return ArcCosine(GetVectorDotProduct(x1, x2)/(GetVectorLength(x1)*GetVectorLength(x2)));
}
GetRayHitPos(Float:pos[3], Float: angle[3], Float:hitpos[3], self, flag)
{
	new Handle:trace ;
	new hit=0;
	if(flag==FilterSelf)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelf, self);
	}
	else if(flag==FilterSelfAndPlayer)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelfAndPlayer, self);
	}
	else if(flag==FilterSelfAndSurvivor)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelfAndSurvivor, self);
	}
	else if(flag==FilterSelfAndInfected)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelfAndInfected, self);
	}
	else if(flag==FilterSelfAndPlayerAndCI)
	{
		trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, DontHitSelfAndPlayerAndCI, self);
	}
	if(TR_DidHit(trace))
	{
			
		TR_GetEndPosition(hitpos, trace);
		hit=TR_GetEntityIndex( trace);
			
	}
	CloseHandle(trace);
	return hit;
}
 GrenadeHit(userid)
{

	//PrintToChatAll("bounce %N", userid);
	if(GrenadeLauncher[userid] > 0 && IsValidEntity(GrenadeLauncher[userid]) && IsValidEdict(GrenadeLauncher[userid]))
	{
		//PrintToChatAll("bounce ok");
		 
		new Float:pos[3], voffset[3];	
		GetEntPropVector(GrenadeLauncher[userid], Prop_Send, "m_vecOrigin", pos);		
 	
		decl Float:velocitymissile[3];	
		GetEntDataVector(GrenadeLauncher[userid], g_iVelocity, velocitymissile);
		NormalizeVector(velocitymissile, velocitymissile);
	
		CopyVector(velocitymissile, voffset);
		ScaleVector(voffset, 180.0);
		AddVectors(pos, voffset, pos);
		
		RemoveEdict(MissleModel[userid]);
		RemoveEdict(GrenadeLauncher[userid]);
		
		GrenadeLauncher[userid]=0;
		MissleModel[userid]=0;
		new ent1=0;		
		{
			ent1=CreateEntityByName("prop_physics"); 
			SetEntPropEnt(ent1, Prop_Data, "m_hOwnerEntity", userid)	;			
			DispatchKeyValue(ent1, "model", "models/props_junk/propanecanister001a.mdl"); 
			DispatchSpawn(ent1); 
			TeleportEntity(ent1, pos, NULL_VECTOR, NULL_VECTOR);
			ActivateEntity(ent1);
			//AcceptEntityInput(ent1, "Ignite", -1, -1);
		}
		
		new Handle:h=CreateDataPack();		
		WritePackCell(h, userid);
		WritePackCell(h, ent1);
		WritePackCell(h, 0);
		WritePackCell(h, 0);
  
		WritePackFloat(h, pos[0]);
		WritePackFloat(h, pos[1]);
		WritePackFloat(h, pos[2]);

		new Float:damage=GetConVarFloat(l4d_missile_damage);
		new Float:radius=GetConVarFloat(l4d_missile_radius);
		new Float:pushforce=GetConVarFloat(l4d_missile_push);		
		WritePackFloat(h, damage);
		WritePackFloat(h, radius);
		WritePackFloat(h, pushforce);
		
		ExplodeG(INVALID_HANDLE, h);
		
		PrintCenterText(userid, "missile exploded");
	}
}

public Action:ExplodeG(Handle:timer, Handle:h)
{
	ResetPack(h);
 	new userid=ReadPackCell(h);
	new ent1=ReadPackCell(h);
	new ent2=ReadPackCell(h);
	new ent3=ReadPackCell(h);

	decl Float:pos[3];
	pos[0]=ReadPackFloat(h);
	pos[1]=ReadPackFloat(h);
	pos[2]=ReadPackFloat(h);
	new Float:damage=ReadPackFloat(h);
	new Float:radius=ReadPackFloat(h);
	new Float:force=ReadPackFloat(h);
	CloseHandle(h);
	
 	if(ent1>0 && IsValidEntity(ent1))
	{
		 
 		AcceptEntityInput(ent1, "break", userid);
		RemoveEdict(ent1);
 		if(ent2>0 && IsValidEntity(ent2))
		{
			AcceptEntityInput(ent2, "break",  userid);
			RemoveEdict(ent2);
		}
 		if(ent3>0 && IsValidEntity(ent3))
		{
			AcceptEntityInput(ent3, "break",  userid);
			RemoveEdict(ent3);
		}

	}
	 
	ShowParticle(pos, "gas_explosion_pump", 3.0);	
	 
 	new pointHurt = CreateEntityByName("point_hurt");   
 	
 	DispatchKeyValueFloat(pointHurt, "Damage", damage);        
	DispatchKeyValueFloat(pointHurt, "DamageRadius", radius);     
 	DispatchKeyValue(pointHurt, "DamageDelay", "0.0");   
	DispatchSpawn(pointHurt);
	TeleportEntity(pointHurt, pos, NULL_VECTOR, NULL_VECTOR);  
	AcceptEntityInput(pointHurt, "Hurt", userid);    
	CreateTimer(0.1, DeletePointHurt, pointHurt); 

 
	new push = CreateEntityByName("point_push");         
  	DispatchKeyValueFloat (push, "magnitude", force);                     
	DispatchKeyValueFloat (push, "radius", radius*1.0);                     
  	SetVariantString("spawnflags 24");                     
	AcceptEntityInput(push, "AddOutput");
 	DispatchSpawn(push);   
	TeleportEntity(push, pos, NULL_VECTOR, NULL_VECTOR);  
 	AcceptEntityInput(push, "Enable", userid, userid);
	CreateTimer(0.5, DeletePushForce, push);
 
	PushAway(pos, force, radius);
	
	return;
} 
PushAway( Float:pos[3], Float:force, Float:radius)
{
	pos[2]-=100;
	new Float:glimit=GetConVarFloat(w_pushforce_vlimit);
	new Float:normalfactor=GetConVarFloat(w_pushforce_factor);
	new Float:tankfactor=GetConVarFloat(w_pushforce_tankfactor);
	new Float:survivorfactor=GetConVarFloat(w_pushforce_survivorfactor);
	new Float:factor;
	new Float:r;


	for (new target = 1; target <= MaxClients; target++)
	{
		if (IsClientInGame(target))
		{
			if (IsPlayerAlive(target))
			{
					decl Float:targetVector[3]
					GetClientEyePosition(target, targetVector)
													
					new Float:distance = GetVectorDistance(targetVector, pos);

					if(GetClientTeam(target)==2)
					{
						factor=survivorfactor;
						r=radius*0.8;
 					}
					else if(GetClientTeam(target)==3)
					{
 						new class = GetEntProp(target, Prop_Send, "m_zombieClass");
						if(class==5)
						{
							factor=tankfactor;
							r=radius*1.0;
						}
						else
						{
							factor=normalfactor;
							r=radius*1.3;
						}
					}
							
					if (distance < r )
					{
						decl Float:vector[3];
					
						MakeVectorFromPoints(pos, targetVector, vector);
								
						NormalizeVector(vector, vector);
						ScaleVector(vector, force);
						if(vector[2]<0.0)vector[2]=10.0;

						vector[0]*=factor;
						vector[1]*=factor;
						vector[2]*=factor;

						vector[0]*=factor;
						vector[1]*=factor;
						vector[2]*=factor;
						if(vector[0]>glimit)
						{
							vector[0]=glimit;
						}
						if(vector[1]>glimit)
						{
							vector[1]=glimit;
						}
						if(vector[2]>glimit)
						{
							vector[2]=glimit;
						}

						if(vector[0]<-glimit)
						{
							vector[0]=-glimit;
						}
						if(vector[1]<-glimit)
						{
							vector[1]=-glimit;
						}
						if(vector[2]<-glimit)
						{
							vector[2]=-glimit;
						}
 						TeleportEntity(target, NULL_VECTOR, NULL_VECTOR, vector);				
				 
 					}
			 
			}
		}
	}

}
public PrecacheParticle(String:particlename[])
{
 new particle = CreateEntityByName("info_particle_system");
 if (IsValidEdict(particle))
 {
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(0.01, DeleteParticles, particle);
 } 
}
public Action:DeleteParticles(Handle:timer, any:particle)
{
	 if (IsValidEntity(particle))
	 {
		 decl String:classname[64];
		 GetEdictClassname(particle, classname, sizeof(classname));
		 if (StrEqual(classname, "info_particle_system", false))
			{
				AcceptEntityInput(particle, "stop");
				AcceptEntityInput(particle, "kill");
				RemoveEdict(particle);
			}
	 }
}
public Action:DeletePushForce(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_push", false))
				{
 					AcceptEntityInput(ent, "Disable");
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
	 }
}
public Action:DeletePointHurt(Handle:timer, any:ent)
{
	 if (IsValidEntity(ent))
	 {
		 decl String:classname[64];
		 GetEdictClassname(ent, classname, sizeof(classname));
		 if (StrEqual(classname, "point_hurt", false))
				{
					AcceptEntityInput(ent, "Kill"); 
					RemoveEdict(ent);
				}
		 }

}
public ShowParticle(Float:pos[3], String:particlename[], Float:time)
{
 new particle = CreateEntityByName("info_particle_system");
 if (IsValidEdict(particle))
 {
		TeleportEntity(particle, pos, NULL_VECTOR, NULL_VECTOR);
		DispatchKeyValue(particle, "effect_name", particlename);
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		CreateTimer(time, DeleteParticles, particle);
 } 
}
public Action:round_start(Handle:event, const String:name[], bool:dontBroadcast)
{
	ResetAllState();
	gamestart=true;
	return Plugin_Continue;
}
public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	gamestart=false;
}
ResetAllState()
{
	new Float:t=GetEngineTime();
	for (new x = 0; x < MAXPLAYERS+1; x++)
	{
		UseTime[x]=t;
		Bullet[x]=0;
		Hooked[x]=false;
 	}
}
public OnConfigExecuted()
{
	ResetAllState();
	Set();
}
Set()
{
 
}
public CvarChanged(Handle:convar, const String:oldValue[], const String:newValue[])
{
	Set();
}
public OnMapStart()
{
	PrecacheModel("models/props_junk/propanecanister001a.mdl", true);
	PrecacheModel("models/props_junk/gascan001a.mdl", true);
	 
	PrecacheParticle("gas_explosion_pump");
	PrecacheParticle("gas_explosion_main");

	if(L4D2Version)
	{
		g_sprite = PrecacheModel("materials/sprites/laserbeam.vmt");	
		PrecacheModel("models/missiles/f18_agm65maverick.mdl");
		PrecacheSound(SOUND2, true);
		PrecacheSound(SOUNDMISSILE2, true);	
	}
	else
	{
		g_sprite = PrecacheModel("materials/sprites/laser.vmt");	
		PrecacheSound(SOUNDMISSILE, true);	
	}

}
public bool:DontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	return true;
}
public bool:DontHitSelfAndPlayer(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity))
		{
			return false;
		}
	}
	return true;
}
public bool:DontHitSelfAndPlayerAndCI(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity))
		{
			return false;
		}
	}
	else
	{
		decl String:edictname[128];
		GetEdictClassname(entity, edictname, 128);
		if(StrContains(edictname, "infected")>=0)
		{
			return false;
		}
	}
	return true;
}
public bool:DontHitSelfAndSurvivor(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==2)
		{
			return false;
		}
	}
	return true;
}
public bool:DontHitSelfAndInfected(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	else if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==3)
		{
			return false;
		}
	}
	return true;
}