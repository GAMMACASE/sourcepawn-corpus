// THE BELOW HEADER MAY NOT BE REMOVED OR MODIFIED
//
// This file is part of empvehicletools.
//
// empvehicletools is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// empvehicletools is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with empvehicletools. If not, see <http://www.gnu.org/licenses/>.
//
// THE ABOVE HEADER MAY NOT BE REMOVED OR MODIFIED
 
/* Plugin Template generated by Pawn Studio */

#include <sourcemod>

// Empires API
#include "empires.inc"

#pragma semicolon 1

// Eject cvar handle
new Handle:hEjectTime;

// Extra events handle
new Handle:hExtraEvents; 

// Default eject time
new gDefaultEjectTime;

// **************************************
// Client control arrays
// **************************************
new gClientBeingEjected[MAXPLAYERS + 1] = {0, ...};
new gVehicleEntryCount[MAXPLAYERS + 1] = {0, ...};


// **************************************
// Version and eject min/max
// **************************************
#define EMPVEHICLETOOLS_VERSION "1.1.0.0"
#define MAX_EJECT_TIME 120.0
#define MIN_EJECT_TIME 2.0

public Plugin:myinfo = 
{
	name = "Empires Vehicle Tools",
	author = "Recon",
	description = "Admin vehicle tools for EmpiresMod.",
	version = EMPVEHICLETOOLS_VERSION,
	url = "No website yet..."
}


public OnPluginStart()
{
	// For FindTarget
	LoadTranslations("common.phrases");
	
	// Plugin phrases
	LoadTranslations("empvehicletools.phrases");
	
	// Eject cvar
	hEjectTime = CreateConVar("sm_eject_time", "5", "The default number of seconds that a player has to wait until \
													  they can enter a vehicle after being ejected.", 
													  FCVAR_NONE, true, MIN_EJECT_TIME, true, MAX_EJECT_TIME);
					
	// Version cvar
	CreateConVar("empvehicletools_version", EMPVEHICLETOOLS_VERSION, "Empires Vehicle Tools Version", 
				 FCVAR_REPLICATED | FCVAR_PLUGIN | FCVAR_SPONLY | FCVAR_NOTIFY);
	
	// Hook the cvar change
	if (hEjectTime != INVALID_HANDLE)
	{
		HookConVarChange(hEjectTime, OnEjectTimeChange);
	}
	else
	{
		SetFailState("Unable to create the sm_eject_time cvar.");
	}
	
	// Cvars done, create a config file
	AutoExecConfig();
	
	// Read the cvar
	gDefaultEjectTime = GetConVarInt(hEjectTime);	
	
	// Extra events cvar
	hExtraEvents = FindConVar("emp_sv_fireextraevents");
	
	if (hExtraEvents != INVALID_HANDLE)
	{
		// Enable extra events
		SetConVarInt(hExtraEvents, 1);
		
		// Hook change in case someone tries to turn it off
		HookConVarChange(hExtraEvents, OnExtraEventsChange);
	}	
	
	// Eject command
	RegAdminCmd("sm_eject",
		Command_Eject,
		ADMFLAG_KICK,
		"Ejects a player from the vehicle they are currently in.");
	
	// Prevent exploits
	RegConsoleCmd("sm_secure_change_seat_2", SecureSeatChange, "Secure seat change.");
	RegConsoleCmd("emp_change_seat_2", RestrictedCommand, "Restricted command.");
	HookEvent("vehicle_enter", Event_VehicleEnter, EventHookMode_Post);
}

// **************************************
// Modify/restore binds
// **************************************

public OnClientPostAdminCheck(client)
{
	// Setup the secure seat change bind
	ClientCommand(client, "bind_vehicle F2 sm_secure_change_seat_2");	
}

public OnClientDisconnect(client)
{
	// Setup the regular seat change bind
	ClientCommand(client, "bind_vehicle F2 emp_change_seat_2");
}


// **************************************
// Exploit prevention
// **************************************

public Action:RestrictedCommand(client, args)
{
	// If they shouldn't be running this command,
	// slay them	
	if (gClientBeingEjected[client])
	{
		ForcePlayerSuicide(client);	
	}
}

public Event_VehicleEnter(Handle:event, const String:name[], bool:dontBroadcast)
{	
	// Get the client index
	new client = GetClientOfUserId(GetEventInt(event, "userid"));

	// If they are being ejected, 
	// they shouldn't be getting into a vehicle
	if (gClientBeingEjected[client])
	{
		gVehicleEntryCount[client]--;
		
		// Should the user be doing this?
		if (gVehicleEntryCount[client] < 0)
		{
			ForcePlayerSuicide(client);
			
			// Tell the user they can't do that
			decl String:msg[256];
			Format(msg, sizeof(msg), "[VehicleEject] %T", "TriedOverride", client);			
			PrintCenterText(client, msg);
			PrintToChat(client, msg);
		}
	}
}

public Action:SecureSeatChange(client, args)
{
	// Stop commanders from getting around
	// the eject by switching back into comm view
	if (!gClientBeingEjected[client])
	{		
		ClientCommand(client, "emp_change_seat_2");
	}
	
	return Plugin_Handled;
}


// **************************************
// Cvar change handlers
// **************************************

public OnExtraEventsChange(Handle:cvar, const String:oldVal[], const String:newVal[])
{
	// Get the value
	new value = StringToInt(newVal);
	
	// Save the new value
	if (value !=  1)
	{
		LogMessage("emp_sv_fireextraevents was set to %s. This plugin \
					requires that it be set to 1. Resetting to 1.", newVal);
		
		// Value must be 1, reset the convar to 1
		SetConVarInt(hExtraEvents, 1);
	}
}

public OnEjectTimeChange(Handle:cvar, const String:oldVal[], const String:newVal[])
{
	new value = StringToInt(newVal);
	
	// Save the new value
	if (value > 0)
	{		
		gDefaultEjectTime = value;
	}
}

// **************************************
// Eject command handler
// ************************************** 

public Action:Command_Eject(client, args)
{
	// User has to provide one arg
	if (args < 1)
	{
		ReplyToCommand(client, "Usage: sm_eject <#userid|name> [seconds]");
		return Plugin_Handled;
	}
	
	// Get the target str
	decl String:targetStr[50];
	GetCmdArg(1, targetStr, sizeof(targetStr));
	
	// Find the target
	new target = FindTarget(client, targetStr);
 
	// Valid target and not already being ejected
	if (target != -1 && !gClientBeingEjected[target])
	{	
		// Default eject time
		new clientEjectTime = gDefaultEjectTime;
				
		// Custom eject time
		if (args == 2)
		{
			// Get the time
			decl String:tempStr[10];
			GetCmdArg(2, tempStr, sizeof(tempStr));
			
			// Valid string
			if (tempStr[0] != '\0')
			{
				// Convert to cell
				new temp = StringToInt(tempStr);
				
				// Valid eject time
				if (temp != 0 && temp >= MIN_EJECT_TIME && temp <= MAX_EJECT_TIME)
				{
					// Use the custom eject time
					clientEjectTime = temp;					
				}
				else
				{
					ReplyToCommand(client, "[VehicleEject] %T", "InvalidEjectTime", client);
					return Plugin_Handled;
				}
			}
			else
			{
				ReplyToCommand(client, "[VehicleEject] %T", "InvalidEjectTime", client);
				return Plugin_Handled;
			}			
		}
		
		// We are ejecting this target
		gClientBeingEjected[target] = 1;
		
		// Reset the vehicle entry count for this target
		gVehicleEntryCount[target] = 0;
		
		// Is this the commander?
		new isCommander = IsComm(target);
		
		// Pack up the data we need
		new Handle:pack = CreateDataPack();
		WritePackCell(pack, client);
		WritePackCell(pack, target);
		WritePackCell(pack, isCommander);
		WritePackCell(pack, clientEjectTime);
		ResetPack(pack);
		
		// Handle commanders
		if (isCommander)
		{
			// Get player out of comm view
			gVehicleEntryCount[target]++;
			ClientCommand(target, "emp_comm_exit");
			
			LogAction(client, target, "\"%L\" ejected \"%L\" from a command vehicle.", client, target);	
			
			// Perform the eject
			CreateTimer(1.00, PerformEject, pack, TIMER_FLAG_NO_MAPCHANGE);
		}
		else
		{
			LogAction(client, target, "\"%L\" ejected \"%L\" from a vehicle.", client, target);
			
			// Perform the eject
			PerformEject(INVALID_HANDLE, pack);
		}		
		
		
		// Allow the target to enter vehicles again in sm_eject_time seconds
		CreateTimer(float(clientEjectTime), FinishEject, target, TIMER_FLAG_NO_MAPCHANGE);		
	}
	
	return Plugin_Handled;
}


// **************************************
// Eject timer callbacks
// ************************************** 

public Action:PerformEject(Handle:timer, Handle:pack)
{
	// Unpack the data
	new client = ReadPackCell(pack);
	new target = ReadPackCell(pack);
	new isCommander = ReadPackCell(pack);
	new clientEjectTime = ReadPackCell(pack);
	CloseHandle(pack);
	
	if (IsClientConnected(target))
	{	
		// Eject the target	
		ClientCommand(target, "-use");	
		CreateTimer(0.20, PerformPlusUse, target, TIMER_FLAG_NO_MAPCHANGE);		
		
		decl String:name[65];
		GetClientName(target, name, sizeof(name));
		
		// Show the eject
		if (isCommander)
		{
			ShowActivity2(client, "[VehicleEject]", "%T", "EjectedCommander", LANG_SERVER, name);
		}
		else
		{
			ShowActivity2(client, "[VehicleEject]", "%T", "EjectedPlayer", LANG_SERVER, name);
		}
		
		// Tell the player they can't enter vehicles
		// for clientEjectTime seconds.
		decl String:msg[256];
		Format(msg, sizeof(msg), "[VehicleEject] %T", "NoVehicleEntry", target, clientEjectTime);		
		PrintCenterText(target, msg);
		PrintToChat(target, msg);
	}
}

public Action:PerformPlusUse(Handle:timer, any:target)
{	
	if (IsClientConnected(target))
	{
		ClientCommand(target, "+use");	
	}
}

public Action:FinishEject(Handle:timer, any:target)
{	
	if (IsClientConnected(target))
	{		
		// Allow the player to enter vehicles again	
		ClientCommand(target, "+use");
		ClientCommand(target, "-use");
		
		// Tell the player they can enter vehicles again
		decl String:msg[256];
		Format(msg, sizeof(msg), "[VehicleEject] %T", "VehicleEntryAllowed", target);		
		PrintCenterText(target, msg);
		PrintToChat(target, msg);	
	}
	
	// Done ejecting this client
	gClientBeingEjected[target] = 0;
}
