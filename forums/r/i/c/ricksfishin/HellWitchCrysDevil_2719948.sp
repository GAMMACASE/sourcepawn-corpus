
//Remember SmLib to Compile using Point Hurt that Library very useful



static const String:GAMEDATA_FILENAME[]				= "l4d2addresses";
//static const Float:SLAP_VERTICAL_MULTIPLIER			= 0.5;



#include <sourcemod>
#include <sdktools>
//#include <smlib>
#pragma semicolon 1

#define PLUGIN_VERSION "DevilWitchVersion"

#define g_sChargerMob   	"player/charger/voice/warn/charger_warn_03.wav"
#define g_sChargerMob2  	"player/charger/voice/idle/charger_lurk_21.wav"
#define g_sChargerMob3  	"player/charger/voice/idle/charger_lurk_14.wav"
#define g_sChargerMob4  	"player/charger/voice/idle/charger_lurk_18.wav"

#define g_sBoomerMob    	"player/boomer/voice/alert/male_boomer_alert_15.wav"
#define g_sBoomerMob2   	"player/boomer/voice/alert/male_boomer_alert_14.wav"
#define g_sBoomerMob3   	"player/boomer/voice/warn/male_boomer_warning_16.wav"
#define g_sBoomerMob4   	"player/boomer/voice/idle/male_boomer_lurk_08.wav"

#define g_sTankCall     	"player/tank/voice/idle/tank_voice_04.wav"
#define g_sTankCall2    	"player/tank/voice/idle/tank_voice_09.wav"
#define g_sTankCall3    	"player/tank/voice/idle/tank_voice_02.wav"
#define g_sTankCallp3   	"player/tank/voice/idle/tank_voice_01.wav"
#define g_sTankCall4    	"player/tank/voice/pain/tank_fire_07.wav"

#define g_sHunterMob    	"player/hunter/voice/alert/hunter_alert_02.wav"
#define g_sHunterMob2   	"player/hunter/voice/alert/hunter_alert_04.wav"
#define g_sHunterMob3   	"player/hunter/voice/alert/hunter_alert_03.wav"
#define g_sHunterMob4   	"player/hunter/voice/alert/hunter_alert_05.wav"

#define g_sNothing      	"npc/infected/alert/alert/alert44.wav"
#define g_sNothing2     	"npc/witch/voice/retreat/horrified_4.wav"

#define g_sMobCall      	"npc/infected/action/rage/male/rage_50.wav"
#define g_sMobCall2     	"npc/mega_mob/mega_mob_incoming.wav"
#define g_sMobCall3     	"npc/infected/action/die/ceda_suit_deflate_03.wav"

#define g_sWitchDeath   	"npc/witch/voice/die/female_death_1.wav"
#define g_sWitchDeath2  	"npc/witch/voice/attack/female_distantscream1.wav"
#define g_sWitchDeath3  	"npc/witch/voice/attack/female_distantscream2.wav"
#define g_sWitchDeath4  	"npc/witch/voice/retreat/horrified_3.wav"

#define g_sDevilScream  	"npc/witch/voice/mad/female_ls_d_madscream03.wav"
#define g_sWitchRawr		"npc/witch/voice/attack/female_distantscream1.wav"
#define g_sRumbleSnd		"player/charger/hit/charger_smash_01.wav"

//NEW SOUNDS INFECTED SMOKER'SPITTER AND JOCKEY
#define g_sSmokerMob         "player/smoker/voice/alert/smoker_alert_01.wav"
#define g_sSmokerMob2        "player/smoker/voice/alert/smoker_alert_02.wav"
#define g_sSmokerMob3        "player/smoker/voice/alert/smoker_alert_04.wav"
#define g_sSmokerMob4        "player/smoker/voice/alert/smoker_alert_05.wav"

#define g_sJockeyMob         "player/jockey/voice/idle/jockey_lurk01.wav"
#define g_sJockeyMob2        "player/jockey/voice/idle/jockey_lurk06.wav"
#define g_sJockeyMob3        "player/jockey/voice/idle/jockey_recognize17.wav"
#define g_sJockeyMob4        "player/jockey/voice/idle/jockey_recognize19.wav"

#define g_sSpitterMob        "player/spitter/voice/alert/spitter_alert_02.wav"
#define g_sSpitterMob2       "player/spitter/voice/idle/spitter_lurk_01.wav"
#define g_sSpitterMob3       "player/spitter/voice/idle/spitter_lurk_05.wav"
#define g_sSpitterMob4       "player/spitter/voice/idle/spitter_lurk_17.wav"

#define g_sTail         	"weapon_molotov_thrown_child1"
#define g_sTailFX       	"barrel_fly_embers"
//#define g_sDevilTailFX	"flare_burning"
#define g_sDevilCrown		"env_fire_tiny"
#define g_sBoomGroundWave	"gas_explosion_ground_wave"


#if !defined DMG_GENERIC  //CHECK THAT !

#define DMG_GENERIC			0			// generic damage was done
#define DMG_CRUSH			(1 << 0)	// crushed by falling or moving object.
// NOTE: It's assumed crush damage is occurring as a result of physics collision, so no extra physics force is generated by crush damage.
// DON'T use DMG_CRUSH when damaging entities unless it's the result of a physics collision. You probably want DMG_CLUB instead.
#define DMG_BULLET			(1 << 1)	// shot
#define DMG_SLASH			(1 << 2)	// cut, clawed, stabbed
#define DMG_BURN			(1 << 3)	// heat burned
#define DMG_VEHICLE			(1 << 4)	// hit by a vehicle
#define DMG_FALL			(1 << 5)	// fell too far
#define DMG_BLAST			(1 << 6)	// explosive blast damage
#define DMG_CLUB			(1 << 7)	// crowbar, punch, headbutt
#define DMG_SHOCK			(1 << 8)	// electric shock
#define DMG_SONIC			(1 << 9)	// sound pulse shockwave
#define DMG_ENERGYBEAM		(1 << 10)	// laser or other high energy beam
#define DMG_PREVENT_PHYSICS_FORCE		(1 << 11)	// Prevent a physics force
#define DMG_NEVERGIB		(1 << 12)	// with this bit OR'd in, no damage type will be able to gib victims upon death
#define DMG_ALWAYSGIB		(1 << 13)	// with this bit OR'd in, any damage type can be made to gib victims upon death.
#define DMG_DROWN			(1 << 14)	// Drowning


#define DMG_PARALYZE		(1 << 15)	// slows affected creature down
#define DMG_NERVEGAS		(1 << 16)	// nerve toxins, very bad
#define DMG_POISON			(1 << 17)	// blood poisoning - heals over time like drowning damage
#define DMG_RADIATION		(1 << 18)	// radiation exposure
#define DMG_DROWNRECOVER	(1 << 19)	// drowning recovery
#define DMG_ACID			(1 << 20)	// toxic chemicals or acid burns
#define DMG_SLOWBURN		(1 << 21)	// in an oven

#define DMG_REMOVENORAGDOLL	(1<<22)		// with this bit OR'd in, no ragdoll will be created, and the target will be quietly removed.
// use this to kill an entity that you've already got a server-side ragdoll for

#define DMG_PHYSGUN			(1<<23)		// Hit by manipulator. Usually doesn't do any damage.
#define DMG_PLASMA			(1<<24)		// Shot by Cremator
#define DMG_AIRBOAT			(1<<25)		// Hit by the airboat's gun

#define DMG_DISSOLVE		(1<<26)		// Dissolving!
#define DMG_BLAST_SURFACE	(1<<27)		// A blast on the surface of water that cannot harm things underwater
#define DMG_DIRECT			(1<<28)
#define DMG_BUCKSHOT		(1<<29)		// not quite a bullet. Little, rounder, different.

#endif

new Handle:hCvar_HellWitch = INVALID_HANDLE;
new Handle:hCvar_TankMobCount = INVALID_HANDLE;
new Handle:hCvar_HunterMobCount = INVALID_HANDLE;
new Handle:hCvar_ChargerMobCount = INVALID_HANDLE;
new Handle:hCvar_BoomerMobCount = INVALID_HANDLE;
new Handle:hCvar_MobCall = INVALID_HANDLE;
new Handle:hCvar_DirHint = INVALID_HANDLE;
new Handle:hCvar_TankRush = INVALID_HANDLE;

// new Handlers smoker' jockey and spitters
new Handle:hCvar_SmokerMobCount = INVALID_HANDLE;
new Handle:hCvar_JockeyMobCount = INVALID_HANDLE;
new Handle:hCvar_SpitterMobCount = INVALID_HANDLE;

new g_iTankMobCount;
new g_iHunterMobCount;
new g_iChargerMobCount;
new g_iBoomerMobCount;

//new g for smoker 'jockeys and spitters
new g_iSmokerMobCount;
new g_iJockeyMobCount;
new g_iSpitterMobCount;


new bool:g_bHW = false;
new bool:g_bMobCall = false;
new bool:g_bDirHint = false;
new bool:g_bTankRush = false;
new bool:g_bWitchMobSet = false;
new bool:g_bDevilWitch = false;//should be false
new bool:g_bWitchMobOnly = false;
//new bool:g_bShockWaveAllow = false;
new g_iDevilWitchRef[2048+1];

public Plugin:myinfo =
{
	name = "Hell_Witch_Crys",
	author = "lux",
	description = "You'll think twice about messing with the witch c:",
	version = PLUGIN_VERSION,
	url = ""
}

public OnPluginStart()
{
	CreateConVar("Hell_Witch_Crys", PLUGIN_VERSION, " Version of Hell_Witch_Crys ", FCVAR_NOTIFY|FCVAR_DONTRECORD);
	
	hCvar_HellWitch     =   CreateConVar("HW_Enable", "1", "Should We Enable the HellWitchCrys?", FCVAR_NOTIFY, true, 0.0, true, 1.0);
	hCvar_TankMobCount =    CreateConVar("HW_TankCount", "0", "Amount In TankMob 0 = Disable", FCVAR_NOTIFY, true, 0.0, true, 31.0);
	hCvar_HunterMobCount =  CreateConVar("HW_HunterCount", "3", "Amount In HunterMob 0 = Disable", FCVAR_NOTIFY, true, 0.0, true, 31.0);
	hCvar_ChargerMobCount = CreateConVar("HW_ChargerCount", "3", "Amount In ChangerMob 0 = Disable", FCVAR_NOTIFY, true, 0.0, true, 31.0);
	hCvar_BoomerMobCount =  CreateConVar("HW_BoomerCount", "3", "Amount In BoomerMob 0 = Disable", FCVAR_NOTIFY, true, 0.0, true, 31.0);
	hCvar_MobCall       =   CreateConVar("HW_MobCall", "1", "Should We Enable Mobs?", FCVAR_NOTIFY, true, 0.0, true, 1.0);
	hCvar_DirHint       =   CreateConVar("HW_DirectorHint", "1", "Should We Enable Director Hints?", FCVAR_NOTIFY, true, 0.0, true, 1.0);
	hCvar_TankRush      =   CreateConVar("HW_TankRush", "0", "Should We Enable TankRush Globally?", FCVAR_NOTIFY, true, 0.0, true, 1.0);
	
	//new cvars for smoker'jockey and spitters
	hCvar_SmokerMobCount =    CreateConVar("HW_SmokerCount", "3", "Amount In SmokerMob 0 = Disable", FCVAR_NOTIFY, true, 0.0, true, 31.0);
	hCvar_JockeyMobCount =    CreateConVar("HW_JockeyCount", "3", "Amount In JockeyMob 0 = Disable", FCVAR_NOTIFY, true, 0.0, true, 31.0);
	hCvar_SpitterMobCount =    CreateConVar("HW_SpitterCount", "3", "Amount In SpitterMob 0 = Disable", FCVAR_NOTIFY, true, 0.0, true, 31.0);
	
	AutoExecConfig(true, "Hell_Witch_Crys_Devil");
	
	
	//Use "HookConVarChange" to detect Cvars changes
	//To save some unessasary calculations we hook our own Cvars and save their values into variables
	HookConVarChange(hCvar_HellWitch, eConvarChanged);
	HookConVarChange(hCvar_TankMobCount, eConvarChanged);
	HookConVarChange(hCvar_HunterMobCount, eConvarChanged);
	HookConVarChange(hCvar_ChargerMobCount, eConvarChanged);
	HookConVarChange(hCvar_BoomerMobCount, eConvarChanged);
	//nuevas lineasconvars para smoker 'jockey y spitters
	HookConVarChange(hCvar_SmokerMobCount, eConvarChanged);
	HookConVarChange(hCvar_JockeyMobCount, eConvarChanged);
	HookConVarChange(hCvar_SpitterMobCount, eConvarChanged);
	
	HookConVarChange(hCvar_DirHint, eConvarChanged);
	HookConVarChange(hCvar_TankRush, eConvarChanged);
	CvarsChanged();
	HookEvent("witch_spawn", eWitchSpawned);
	HookEvent("witch_killed", eWitchKilled);
	HookEvent("tank_spawn", ePreTankRush);
	HookEvent("witch_harasser_set", eWitchStartled);
	
}

public OnMapStart()
{
	
	PrecacheSound(g_sWitchDeath, true);
	PrecacheSound(g_sWitchDeath2, true);
	PrecacheSound(g_sWitchDeath3, true);
	PrecacheSound(g_sWitchDeath4, true);
	
	PrecacheSound(g_sChargerMob, true);
	PrecacheSound(g_sChargerMob2, true);
	PrecacheSound(g_sChargerMob3, true);
	PrecacheSound(g_sChargerMob4, true);
	
	PrecacheSound(g_sBoomerMob, true);
	PrecacheSound(g_sBoomerMob2, true);
	PrecacheSound(g_sBoomerMob3, true);
	PrecacheSound(g_sBoomerMob4, true);
	
	PrecacheSound(g_sTankCall, true);
	PrecacheSound(g_sTankCall2, true);
	PrecacheSound(g_sTankCall3, true);
	PrecacheSound(g_sTankCallp3, true);
	PrecacheSound(g_sTankCall4, true);
	
	PrecacheSound(g_sHunterMob, true);
	PrecacheSound(g_sHunterMob2, true);
	PrecacheSound(g_sHunterMob3, true);
	PrecacheSound(g_sHunterMob4, true);
	
	//new precache sounds of smoker' jockey and spitters
	PrecacheSound(g_sSmokerMob, true);
	PrecacheSound(g_sSmokerMob2, true);
	PrecacheSound(g_sSmokerMob3, true);
	PrecacheSound(g_sSmokerMob4, true);
	
	PrecacheSound(g_sJockeyMob, true);
	PrecacheSound(g_sJockeyMob2, true);
	PrecacheSound(g_sJockeyMob3, true);
	PrecacheSound(g_sJockeyMob4, true);
	
	PrecacheSound(g_sSpitterMob, true);
	PrecacheSound(g_sSpitterMob2, true);
	PrecacheSound(g_sSpitterMob3, true);
	PrecacheSound(g_sSpitterMob4, true);
	
	PrecacheSound(g_sNothing, true);
	PrecacheSound(g_sNothing2, true);
	
	PrecacheSound(g_sMobCall ,true);
	PrecacheSound(g_sMobCall2 ,true);
	PrecacheSound(g_sMobCall3 ,true);
	
	PrecacheSound(g_sDevilScream, true);    
	PrecacheSound(g_sWitchRawr, true);
	PrecacheSound(g_sRumbleSnd, true);
	
	PrecacheParticleSystem(g_sTail);
	PrecacheParticleSystem(g_sTailFX);
	PrecacheParticleSystem(g_sDevilCrown);
	//PrecacheParticleSystem(g_sDevilTailFX);
	PrecacheParticleSystem(g_sBoomGroundWave);
	//PrecacheModel("models/infected/witch.mdl", true);     Duda si quitar la ruta de abajo
	//PrecacheModel("models/infected/witch_bride.mdl", true);
	PrecacheMaterial("sprites/glow01.vmt");	     //RUTA CORRECTA MODIFICADA POR ESTAR MAL
	SetConVarBounds(FindConVar("z_max_player_zombies"), ConVarBound_Upper, true, 32.0);
	SetConVarBounds(FindConVar("z_minion_limit"), ConVarBound_Upper, true, 32.0);
	SetConVarBounds(FindConVar("survivor_limit"), ConVarBound_Upper, true, 32.0);
	SetConVarBounds(FindConVar("survival_max_specials"), ConVarBound_Upper, true, 32.0);
	CvarsChanged();
}

public eConvarChanged(Handle:hCvar, const String:sOldVal[], const String:sNewVal[])
{
	CvarsChanged();
}

CvarsChanged()
{
	g_bHW = GetConVarInt(hCvar_HellWitch) > 0;
	g_iTankMobCount = GetConVarInt(hCvar_TankMobCount);
	g_iHunterMobCount = GetConVarInt(hCvar_HunterMobCount);
	g_iChargerMobCount = GetConVarInt(hCvar_ChargerMobCount);
	g_iBoomerMobCount = GetConVarInt(hCvar_BoomerMobCount);
	
	//smoker'jockey y spitters
	g_iSmokerMobCount = GetConVarInt(hCvar_SmokerMobCount);
	g_iJockeyMobCount = GetConVarInt(hCvar_JockeyMobCount);
	g_iSpitterMobCount = GetConVarInt(hCvar_SpitterMobCount);
	
	g_bMobCall = GetConVarInt(hCvar_MobCall) > 0;
	g_bDirHint = GetConVarInt(hCvar_DirHint) > 0;
	g_bTankRush = GetConVarInt(hCvar_TankRush) > 0;
}

public eWitchSpawned(Handle:hEvent, const String:sWitchID[], bool:dontBroadcast)
{
	if(!g_bHW)
		return;
	
	new iWitch = GetEventInt(hEvent, "witchid");
	
	if(g_bWitchMobSet)
	{
		//PrintToChatAll("WitchMob Prep Called");
		CreateTimer(0.02, WitchMobSpawn, iWitch, TIMER_FLAG_NO_MAPCHANGE);
	}
	
	if(g_bWitchMobOnly)
	{
		CreateTimer(0.7, SetOffWitch, iWitch, TIMER_FLAG_NO_MAPCHANGE);
	}
	
	CreateTimer(Float:0.1, Timer:Tail, EntIndexToEntRef(iWitch), TIMER_FLAG_NO_MAPCHANGE);
}

public Action:Tail(Handle:hTimer, any:iEntRef)
{
	if(!IsValidEntRef(iEntRef))
		return Plugin_Stop;
	
	new iWitch = EntRefToEntIndex(iEntRef);
	
	decl Float:fTail[3];
	decl String:sWitch[32];
	sWitch[0] = 0;
	
	new Tail1 = CreateEntityByName("info_particle_system");//Particle to consider barrel_fly_embers
	new Tail2 = CreateEntityByName("info_particle_system");
	new Tail3 = CreateEntityByName("info_particle_system");
	new Tail4 = CreateEntityByName("info_particle_system");
	new Tail5 = CreateEntityByName("info_particle_system");
	new Tail6 = CreateEntityByName("info_particle_system");
	new TailFX = CreateEntityByName("info_particle_system");
	
	GetEntPropString(iWitch, Prop_Data, "m_iName", sWitch, sizeof(sWitch));
	GetEntPropVector(iWitch, Prop_Send, "m_vecOrigin", fTail);
	
	TeleportEntity(Tail1, fTail, NULL_VECTOR, NULL_VECTOR);
	TeleportEntity(Tail2, fTail, NULL_VECTOR, NULL_VECTOR);
	TeleportEntity(Tail3, fTail, NULL_VECTOR, NULL_VECTOR);
	TeleportEntity(Tail4, fTail, NULL_VECTOR, NULL_VECTOR);
	TeleportEntity(Tail5, fTail, NULL_VECTOR, NULL_VECTOR);
	TeleportEntity(Tail6, fTail, NULL_VECTOR, NULL_VECTOR);
	TeleportEntity(TailFX, fTail, NULL_VECTOR, NULL_VECTOR);
	
	DispatchKeyValue(Tail1, "targetname", sWitch);
	DispatchKeyValue(Tail2, "targetname", sWitch);
	DispatchKeyValue(Tail3, "targetname", sWitch);
	DispatchKeyValue(Tail4, "targetname", sWitch);
	DispatchKeyValue(Tail5, "targetname", sWitch);
	DispatchKeyValue(Tail6, "targetname", sWitch);
	DispatchKeyValue(TailFX, "targetname", sWitch);
	
	DispatchKeyValue(Tail1, "effect_name", g_sTail);
	DispatchKeyValue(Tail2, "effect_name", g_sTail);
	DispatchKeyValue(Tail3, "effect_name", g_sTail);
	DispatchKeyValue(Tail4, "effect_name", g_sTail);
	DispatchKeyValue(Tail5, "effect_name", g_sTail);
	DispatchKeyValue(Tail6, "effect_name", g_sTail);
	DispatchKeyValue(TailFX, "effect_name", g_sTailFX);
	
	DispatchSpawn(Tail1);
	DispatchSpawn(Tail2);
	DispatchSpawn(Tail3);
	DispatchSpawn(Tail4);
	DispatchSpawn(Tail5);
	DispatchSpawn(Tail6);
	DispatchSpawn(TailFX);
	
	ActivateEntity(Tail1);
	ActivateEntity(Tail2);
	ActivateEntity(Tail3);
	ActivateEntity(Tail4);
	ActivateEntity(Tail5);
	ActivateEntity(Tail6);
	ActivateEntity(TailFX);
	
	AcceptEntityInput(Tail1, "start");
	AcceptEntityInput(Tail2, "start");
	AcceptEntityInput(Tail3, "start");
	AcceptEntityInput(Tail4, "start");
	AcceptEntityInput(Tail5, "start");
	AcceptEntityInput(Tail6, "start");
	AcceptEntityInput(TailFX, "start");
	
	Entity_SetParent(Tail1, iWitch);
	Entity_SetParent(Tail2, iWitch);
	Entity_SetParent(Tail3, iWitch);
	Entity_SetParent(Tail4, iWitch);
	Entity_SetParent(Tail5, iWitch);
	Entity_SetParent(Tail6, iWitch);
	Entity_SetParent(TailFX, iWitch);
	
	SetVariantString("forward");
	AcceptEntityInput(TailFX, "SetParentAttachment");
	
	TeleportEntity(Tail1, Float:{-5.50, 0.0, 30.5}, Float:{0.0, 120.0, 0.0}, NULL_VECTOR);
	TeleportEntity(Tail2, Float:{-7.00, 0.0, 27.5}, Float:{0.0, 115.0, 0.0}, NULL_VECTOR);
	TeleportEntity(Tail3, Float:{-9.50, 0.0, 25.5}, Float:{0.0, 110.0, 0.0}, NULL_VECTOR);
	TeleportEntity(Tail4, Float:{-11.00, 0.0, 23.5}, Float:{0.0, 105.0, 0.0}, NULL_VECTOR);
	TeleportEntity(Tail5, Float:{-13.50, 0.0, 21.5}, Float:{0.0, 100.0, 0.0}, NULL_VECTOR);
	TeleportEntity(Tail6, Float:{-15.00, 0.0, 21.5}, Float:{0.0, 90.0, 0.0}, NULL_VECTOR);
	
	SetVariantString("OnUser1 !self:Stop::15.5:-1");
	AcceptEntityInput(TailFX, "AddOutput");
	SetVariantString("OnUser1 !self:FireUser2::1:-1");
	AcceptEntityInput(TailFX, "AddOutput");
	AcceptEntityInput(TailFX, "FireUser1");
	
	SetVariantString("OnUser2 !self:Start::0:-1");
	AcceptEntityInput(TailFX, "AddOutput");
	SetVariantString("OnUser2 !self:FireUser1::0:-1");
	AcceptEntityInput(TailFX, "AddOutput");
	
	if(!g_bDevilWitch)//should be false
	{
		if(!IsValidEntRef(g_iDevilWitchRef[iWitch]))
		{
			switch(GetRandomInt(1, 4))        //CHANGE THIS SO THAT THERE IS A 20% CHANCE THAT THE DEVIL WITCH DEFAULT 10 WILL COME OUT
			{
				case 1:
				{
					g_bDevilWitch = true;
					g_iDevilWitchRef[iWitch] = EntIndexToEntRef(iWitch);
					SetEntityRenderFx(iWitch, RENDERFX_PULSE_FAST);
					SetEntityRenderColor(iWitch, 255, 255, 255, 255);
					
					SetVariantString("200 1 1");
					AcceptEntityInput(iWitch, "Color");
					
					decl String:sValues[64];
					sValues[0] = 0;
					new iEntity = CreateEntityByName("env_instructor_hint");
					
					TeleportEntity(iEntity, fTail, NULL_VECTOR, NULL_VECTOR);
					
					FormatEx(sValues, sizeof(sValues), "hint%d", iWitch);
					DispatchKeyValue(iWitch, "targetname", sValues);
					DispatchKeyValue(iEntity, "hint_target", sValues);
					Format(sValues, sizeof(sValues), "10");
					DispatchKeyValue(iEntity, "hint_timeout", sValues);
					DispatchKeyValue(iEntity, "hint_range", "999.0");
					DispatchKeyValue(iEntity, "hint_icon_onscreen", "icon_skull");
					Format(sValues, sizeof(sValues), "Witch Demoniaca!");
					DispatchKeyValue(iEntity, "hint_caption", sValues);
					DispatchKeyValue(iEntity, "hint_color", "255 100 0");
					DispatchKeyValue(iEntity, "Size Pulsing", "3");
					DispatchKeyValue(iEntity, "Instance Type", "1");
					DispatchKeyValue(iEntity, "Icon Height Offset", "90.0");
					DispatchKeyValue(iEntity, "Shaking", "1");
					DispatchKeyValue(iEntity, "Show on First Sight", "1");
					DispatchKeyValue(iEntity, "Alpha Pulsing", "3");
					DispatchSpawn(iEntity);
					AcceptEntityInput(iEntity, "ShowHint");
					
					new DevilCrown = CreateEntityByName("info_particle_system");
					TeleportEntity(DevilCrown, fTail, NULL_VECTOR, NULL_VECTOR);
					DispatchKeyValue(DevilCrown, "targetname", sWitch);
					DispatchKeyValue(DevilCrown, "effect_name", g_sDevilCrown);
					DispatchSpawn(DevilCrown);
					ActivateEntity(DevilCrown);
					
					AcceptEntityInput(DevilCrown, "start");
					
					Entity_SetParent(DevilCrown, iWitch);
					
					SetVariantString("forward");
					AcceptEntityInput(DevilCrown, "SetParentAttachment");
					
					TeleportEntity(DevilCrown, Float:{0.00, 0.0, 0.0}, NULL_VECTOR, NULL_VECTOR);
					
					
					/*SetVariantString("OnUser1 !self:Stop::22.5:-1");
					AcceptEntityInput(DevilCrown, "AddOutput");
					SetVariantString("OnUser1 !self:FireUser2::1:-1");
					AcceptEntityInput(DevilCrown, "AddOutput");
					AcceptEntityInput(DevilCrown, "FireUser1");
					SetVariantString("OnUser2 !self:Start::0:-1");
					AcceptEntityInput(DevilCrown, "AddOutput");
					SetVariantString("OnUser2 !self:FireUser1::0:-1");
					AcceptEntityInput(DevilCrown, "AddOutput");*/
					
					
					new iLight = CreateEntityByName("light_dynamic");
					
					TeleportEntity(iLight, fTail, NULL_VECTOR, NULL_VECTOR);
					
					DispatchKeyValue(iLight, "brightness", "1");
					DispatchKeyValueFloat(iLight, "spotlight_radius", 75.0);
					DispatchKeyValueFloat(iLight, "distance", 255.0);
					DispatchKeyValue(iLight, "style", "5");
					DispatchKeyValue(iLight, "Light color", "200 1 1");
					DispatchSpawn(iLight);
					AcceptEntityInput(iLight, "TurnOn");
					
					SetVariantString("200 1 1");
					AcceptEntityInput(iLight, "Color");
					
					Entity_SetParent(iLight, iWitch);
					
					SetVariantString("forward");
					AcceptEntityInput(iLight, "SetParentAttachment");
					TeleportEntity(iLight, Float:{0.00, 0.0, 7.0}, NULL_VECTOR, NULL_VECTOR);
					
					CreateTimer(180.0, DevilWitchTimeOut, INVALID_HANDLE, TIMER_FLAG_NO_MAPCHANGE);
					
				}
			}
		}
	}
	
	return Plugin_Stop;
}

public Action:eWitchStartled(Handle:hEvent, const String:strName[], bool:bDontBroadcast)
{
	new iWitch = GetEventInt(hEvent, "witchid");
	
	if(!IsValidEntRef(g_iDevilWitchRef[iWitch]))
		return;
	
	new iWitchiClient = GetClientOfUserId(GetEventInt(hEvent, "userid"));
	
	if(IsClientInGame(iWitchiClient) && GetClientTeam(iWitchiClient) == 2 && IsPlayerAlive(iWitchiClient))
	{
		decl String:sValues[64];
		sValues[0] = 0;
		
		new iEntity = CreateEntityByName("env_instructor_hint");
		FormatEx(sValues, sizeof(sValues), "hint%d", iWitchiClient);
		DispatchKeyValue(iWitchiClient, "targetname", sValues);
		DispatchKeyValue(iEntity, "hint_target", sValues);
		
		Format(sValues, sizeof(sValues), "4");
		DispatchKeyValue(iEntity, "hint_timeout", sValues);
		DispatchKeyValue(iEntity, "hint_range", "999.0");
		DispatchKeyValue(iEntity, "hint_icon_onscreen", "tip_witch");
		Format(sValues, sizeof(sValues), "The Demon Witch Goes Against You %N", iWitchiClient);
		DispatchKeyValue(iEntity, "hint_caption", sValues);
		DispatchKeyValue(iEntity, "hint_color", "255 100 150");
		DispatchKeyValue(iEntity, "Size Pulsing", "1");
		DispatchKeyValue(iEntity, "Instance Type", "1");
		DispatchSpawn(iEntity);
		AcceptEntityInput(iEntity, "ShowHint");
		
		Format(sValues, sizeof(sValues), "OnUser1 !self:Kill::4:1");
		SetVariantString(sValues);
		AcceptEntityInput(iEntity, "AddOutput");
		AcceptEntityInput(iEntity, "FireUser1");
	}
	
	decl Float:fPos[3];
	
	GetEntPropVector(iWitch, Prop_Send, "m_vecOrigin", fPos);
	
	for(new x = 1; x <= 8; x++)
	{
		new iShake = CreateEntityByName("env_shake");
		DispatchKeyValue(iShake, "spawnflags", "1");
		DispatchKeyValue(iShake, "amplitude", "16.0");
		DispatchKeyValue(iShake, "frequency", "255.0");
		DispatchKeyValue(iShake, "duration", "7.0");
		//DispatchKeyValue(iShake, "radius", "750");
		TeleportEntity(iShake, fPos, NULL_VECTOR, NULL_VECTOR);
		DispatchSpawn(iShake);
		ActivateEntity(iShake);
		
		AcceptEntityInput(iShake, "Enable");
		AcceptEntityInput(iShake, "StartShake");
		
		SetVariantString("OnUser1 !self:Kill::5.1:1");
		AcceptEntityInput(iShake, "AddOutput");
		AcceptEntityInput(iShake, "FireUser1");
	}
	
	for(new i = 1; i <= 5; i++)
	{
		new iBoom = CreateEntityByName("env_physexplosion");
		DispatchKeyValue(iBoom, "Magnitude", "100");
		DispatchKeyValue(iBoom, "Clamp Radius", "750");
		DispatchKeyValueFloat(iBoom, "Inner radius", 255.0);
		DispatchKeyValue(iBoom, "spawnflags", "2");
		TeleportEntity(iBoom, fPos, NULL_VECTOR, NULL_VECTOR);
		DispatchSpawn(iBoom);
		Entity_SetParent(iBoom, iWitch);
		AcceptEntityInput(iBoom, "Explode");
		SetVariantString("OnUser1 !self:Kill::0.2:1");
		AcceptEntityInput(iBoom, "AddOutput");
		AcceptEntityInput(iBoom, "FireUser1");
	}
	
	new iBoomWave = CreateEntityByName("info_particle_system");
	TeleportEntity(iBoomWave, fPos, NULL_VECTOR, NULL_VECTOR);
	DispatchKeyValue(iBoomWave, "effect_name", g_sBoomGroundWave);
	DispatchSpawn(iBoomWave);
	Entity_SetParent(iBoomWave, iWitch);
	ActivateEntity(iBoomWave);
	AcceptEntityInput(iBoomWave, "start");
	
	SetVariantString("OnUser1 !self:Stop::0.2:-1");
	AcceptEntityInput(iBoomWave, "AddOutput");
	SetVariantString("OnUser1 !self:FireUser2::0.21:-1");
	AcceptEntityInput(iBoomWave, "AddOutput");
	AcceptEntityInput(iBoomWave, "FireUser1");
	
	SetVariantString("OnUser2 !self:Start::0:-1");
	AcceptEntityInput(iBoomWave, "AddOutput");
	SetVariantString("OnUser2 !self:FireUser1::0:-1");
	AcceptEntityInput(iBoomWave, "AddOutput");
	
	SetVariantString("OnUser3 !self:kill::5:2");
	AcceptEntityInput(iBoomWave, "AddOutput");
	AcceptEntityInput(iBoomWave, "FireUser3");
	
	SetConVarInt(FindConVar("z_witch_speed"), 0);
	
	SetEntProp(iWitch, Prop_Data, "m_iMaxHealth", 10000);//Set max and
	SetEntProp(iWitch, Prop_Data, "m_iHealth", 10000);
	
	for(new s = 1; s <= 15; s++)
	{
		new iEnt = CreateEntityByName("env_sprite");
		
		// decl String:sTemp[16];
		DispatchKeyValue(iEnt, "rendercolor", "255 1 1");
		DispatchKeyValue(iEnt, "model", "sprites/glow01.vmt");
		DispatchKeyValue(iEnt, "spawnflags", "3");
		DispatchKeyValue(iEnt, "rendermode", "9");
		DispatchKeyValue(iEnt, "GlowProxySize", "255.0");//256.0
		DispatchKeyValue(iEnt, "renderamt", "120");//120
		DispatchKeyValue(iEnt, "scale", "255.0");//256.0
		DispatchSpawn(iEnt);
		//Entity_SetParent(iEnt, iWitch);
		TeleportEntity(iEnt, fPos, NULL_VECTOR, NULL_VECTOR);
		
		SetVariantString("OnUser1 !self:kill::5.1:1");
		AcceptEntityInput(iEnt, "AddOutput");
		AcceptEntityInput(iEnt, "FireUser1");
	}
	CreateTimer(5.0, DevilScreamDelay, any:iWitch);
	
	for(new s = 1; s <= 3; s++)
		EmitSoundToAllClients(g_sWitchRawr, SOUND_FROM_PLAYER, SNDCHAN_AUTO, SNDLEVEL_NORMAL, SND_NOFLAGS, SNDVOL_NORMAL, 120);
	
	//CreateTimer(0.2, ShockWave, any:iWitch, TIMER_REPEAT|TIMER_FLAG_NO_MAPCHANGE);
	
	//g_bShockWaveAllow = true;
}

public Action:ShockWave(Handle:hTimer, any:iWitch)
{
	//if(!g_bShockWaveAllow)
	//return Plugin_Stop;
	
	if(!IsValidEntity(iWitch) || !IsValidEntRef(g_iDevilWitchRef[iWitch]))
		return Plugin_Stop;
	
	PrintToChatAll("Started");
	for (new iClient=1; iClient<=MaxClients; iClient++)
		if (IsClientInGame(iClient) || IsFakeClient(iClient) && GetClientTeam(iClient) == 2 && IsPlayerAlive(iClient))
	{
		decl Float:fPos[3];
		decl Float:survivorPos[3];
		decl Float:distance;
		new Float:range = 500.0;
		GetEntPropVector(iWitch, Prop_Send, "m_vecOrigin", fPos);
		GetClientEyePosition(iClient, survivorPos);
		distance = GetVectorDistance(survivorPos, fPos);
		
		PrintToChatAll("Range Control");
		
		if (distance < range)
		{
			//decl String:sRadius[256];
			//sRadius[0] = 0;
			//decl String:sPower[256];
			//sPower[0] = 0;
			
			new exPhys = CreateEntityByName("env_physexplosion");
			
			//Set up physics movement explosion
			DispatchKeyValue(exPhys, "radius", "500");
			DispatchKeyValue(exPhys, "magnitude", "200");
			DispatchSpawn(exPhys);
			TeleportEntity(exPhys, fPos, NULL_VECTOR, NULL_VECTOR);
			//BOOM!
			AcceptEntityInput(exPhys, "Explode");
			
			
			decl Float:traceVec[3], Float:resultingVec[3], Float:currentVelVec[3];
			new Float:power = 500.0;
			MakeVectorFromPoints(fPos, survivorPos, traceVec);				// draw a line from car to Survivor
			GetVectorAngles(traceVec, resultingVec);							// get the angles of that line
			
			resultingVec[0] = Cosine(DegToRad(resultingVec[1])) * power;	// use trigonometric magic
			resultingVec[1] = Sine(DegToRad(resultingVec[1])) * power;
			resultingVec[2] = power * 1.5;
			
			GetEntPropVector(iClient, Prop_Data, "m_vecVelocity", currentVelVec);		// add whatever the Survivor had before
			resultingVec[0] += currentVelVec[0];
			resultingVec[1] += currentVelVec[1];
			resultingVec[2] += currentVelVec[2];
			
			
			L4D2_Fling(iClient, resultingVec, iWitch);
			
			AcceptEntityInput(exPhys, "kill");
			
			EmitSoundToAllClients(g_sRumbleSnd, SOUND_FROM_PLAYER, SNDCHAN_AUTO, SNDLEVEL_NORMAL, SND_NOFLAGS, SNDVOL_NORMAL, 20);
			
			PrintToChatAll("Finished %N", iClient);
			
		}
	}
	
	return Plugin_Continue;
}

stock L4D2_Fling(target, Float:vector[3], attacker, Float:incaptime = 1.0)
{
	new Handle:MySDKCall = INVALID_HANDLE;
	new Handle:ConfigFile = LoadGameConfigFile(GAMEDATA_FILENAME);
	
	StartPrepSDKCall(SDKCall_Player);
	new bool:bFlingFuncLoaded = PrepSDKCall_SetFromConf(ConfigFile, SDKConf_Signature, "CTerrorPlayer_Fling");
	if(!bFlingFuncLoaded)
	{
		LogError("Could not load the Fling signature");
	}
	PrepSDKCall_AddParameter(SDKType_Vector, SDKPass_ByRef);
	PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Plain);
	PrepSDKCall_AddParameter(SDKType_CBasePlayer, SDKPass_Pointer);
	PrepSDKCall_AddParameter(SDKType_Float, SDKPass_Plain);
	
	MySDKCall = EndPrepSDKCall();
	if(MySDKCall == INVALID_HANDLE)
	{
		LogError("Could not prep the Fling function");
	}
	
	SDKCall(MySDKCall, target, vector, 0, attacker, incaptime); //76 is the 'got bounced' animation in L4D2
}

public Action:DevilScreamDelay(Handle:hTimer, any:iWitch)
{
	if(!IsValidEntity(iWitch) || !IsValidEntRef(g_iDevilWitchRef[iWitch]))
		return;
	
	decl Float:fPos[3];
	
	GetEntPropVector(iWitch, Prop_Send, "m_vecOrigin", fPos);
	
	for(new s = 1; s <= 2; s++)
	{
		new iEnt = CreateEntityByName("env_sprite");
		
		// decl String:sTemp[16];
		DispatchKeyValue(iEnt, "rendercolor", "255 1 1");
		DispatchKeyValue(iEnt, "model", "sprites/glow01.vmt");
		DispatchKeyValue(iEnt, "spawnflags", "3");
		DispatchKeyValue(iEnt, "rendermode", "9");
		DispatchKeyValue(iEnt, "GlowProxySize", "255.0");//256.0
		DispatchKeyValue(iEnt, "renderamt", "120");//120
		DispatchKeyValue(iEnt, "scale", "255.0");//256.0
		DispatchSpawn(iEnt);
		TeleportEntity(iEnt, fPos, NULL_VECTOR, NULL_VECTOR);
		Entity_SetParent(iEnt, iWitch);
		
		
		//SetVariantString("OnUser1 !self:kill::5:1");
		//AcceptEntityInput(iEnt, "AddOutput");
		//AcceptEntityInput(iEnt, "FireUser1");
	}
	
	//g_bShockWaveAllow = false;
	
	CreateTimer(1.5, DevilScream, any:iWitch, TIMER_REPEAT);
	CreateTimer(15.0, WitchSpeedReset, INVALID_HANDLE, TIMER_FLAG_NO_MAPCHANGE);
	SetConVarInt(FindConVar("z_witch_speed"), 3000);
}

public Action:WitchSpeedReset(Handle:hTimer)
{
	SetConVarInt(FindConVar("z_witch_speed"), 300);
}

public Action:DevilScream(Handle:hTimer, any:iWitch)
{
	if(!IsValidEntity(iWitch) || !IsValidEntRef(g_iDevilWitchRef[iWitch]))
		return Plugin_Stop;
	
	EmitSoundToAll(g_sWitchDeath, iWitch, SNDCHAN_AUTO, 150, SND_NOFLAGS, 1.0, 120);
	EmitSoundToAll(g_sWitchDeath, iWitch, SNDCHAN_AUTO, 150, SND_NOFLAGS, 0.9, 110);
	EmitSoundToAll(g_sWitchDeath, iWitch, SNDCHAN_AUTO, 150, SND_NOFLAGS, 0.8, 100);
	EmitSoundToAll(g_sWitchDeath, iWitch, SNDCHAN_AUTO, 150, SND_NOFLAGS, 0.7, 90);
	EmitSoundToAll(g_sWitchDeath, iWitch, SNDCHAN_AUTO, 150, SND_NOFLAGS, 0.6, 80);
	EmitSoundToAll(g_sWitchDeath, iWitch, SNDCHAN_AUTO, 150, SND_NOFLAGS, 0.5, 70);
	EmitSoundToAll(g_sWitchDeath, iWitch, SNDCHAN_AUTO, 150, SND_NOFLAGS, 0.4, 60);
	
	decl Float:fPos[3];
	GetEntPropVector(iWitch, Prop_Send, "m_vecOrigin", fPos);
	
	new iShake = CreateEntityByName("env_shake");
	DispatchKeyValue(iShake, "spawnflags", "4");
	DispatchKeyValue(iShake, "amplitude", "16.0");
	DispatchKeyValue(iShake, "frequency", "255.0");
	DispatchKeyValue(iShake, "duration", "2.0");
	DispatchKeyValue(iShake, "radius", "500");
	TeleportEntity(iShake, fPos, NULL_VECTOR, NULL_VECTOR);
	DispatchSpawn(iShake);
	ActivateEntity(iShake);
	AcceptEntityInput(iShake, "Enable");
	AcceptEntityInput(iShake, "StartShake");
	
	SetVariantString("OnUser1 !self:Kill::1.2:1");
	AcceptEntityInput(iShake, "AddOutput");
	AcceptEntityInput(iShake, "FireUser1");
	
	
	return Plugin_Continue;
}
public eWitchKilled(Handle:hEvent, const String:strName[], bool:bDontBroadcast)
{
	if(g_bHW)
	{
		if(!GetEventBool(hEvent, "oneshot"))
		{
			new iWitch = GetEventInt(hEvent, "witchid");
			decl Float:fPos[3];
			GetEntPropVector(iWitch, Prop_Send, "m_vecOrigin", fPos);
			
			new iWitchKiller = GetClientOfUserId(GetEventInt(hEvent, "userid"));
			
			if(iWitchKiller > 0 && iWitchKiller <= MaxClients && IsClientInGame(iWitchKiller) && GetClientTeam(iWitchKiller) == 2)
			{
				if(!IsValidEntRef(g_iDevilWitchRef[iWitch]))
				{
					switch(GetRandomInt(1, 4))
					{
						case 1:
						{
							EmitAmbientSound(g_sWitchDeath, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 1.0, 35);
						}
						case 2:
						{
							EmitAmbientSound(g_sWitchDeath2, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 1.0, 66);
						}
						case 3:
						{
							EmitAmbientSound(g_sWitchDeath3, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 1.0, 48);
						}
						case 4:
						{
							EmitAmbientSound(g_sWitchDeath4, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 1.0, 60);
						}
					}
					
				}
				
				if(!IsValidEntRef(g_iDevilWitchRef[iWitch]))
					CreateTimer(3.2, MobCall, iWitchKiller, TIMER_FLAG_NO_MAPCHANGE);
				
				else
				
				{
					CreateTimer(10.0, WitchMob, iWitchKiller, TIMER_FLAG_NO_MAPCHANGE);  //part where he starts calling the other witch put printTochat and remove lines and complemented by witchmob action
					
					decl String:sValues[32];
					sValues[0] = 0;
					
					new iEntity = CreateEntityByName("env_instructor_hint");
					
					FormatEx(sValues, sizeof(sValues), "hint%d", iWitchKiller);
					
					DispatchKeyValue(iEntity, "targetname", sValues);
					DispatchKeyValue(iEntity, "hint_target", sValues);
					
					Format(sValues, sizeof(sValues), "10");
					DispatchKeyValue(iEntity, "hint_timeout", sValues);
					DispatchKeyValue(iEntity, "hint_range", "999.0");
					DispatchKeyValue(iEntity, "hint_icon_onscreen", "icon_skull");
					
					Format(sValues, sizeof(sValues), "Summoned Witchs!");
					
					DispatchKeyValue(iEntity, "hint_caption", sValues);
					DispatchKeyValue(iEntity, "hint_color", "255 1 1");
					DispatchKeyValue(iEntity, "Size Pulsing", "3");
					DispatchKeyValue(iEntity, "Instance Type", "1");
					//DispatchKeyValue(iEntity, "Positioning", "1");
					
					DispatchKeyValue(iEntity, "Shaking", "1");
					DispatchKeyValue(iEntity, "Show on First Sight", "1");
					DispatchKeyValue(iEntity, "Alpha Pulsing", "3");
					DispatchSpawn(iEntity);
					AcceptEntityInput(iEntity, "ShowHint");
					
					Format(sValues, sizeof(sValues), "OnUser1 !self:Kill::10:1");
					SetVariantString(sValues);
					AcceptEntityInput(iEntity, "AddOutput");
					AcceptEntityInput(iEntity, "FireUser1");
					
					SetConVarInt(FindConVar("z_witch_speed"), 300);
					
					EmitAmbientSound(g_sWitchDeath, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 1.0, 130, 0.0);
					EmitAmbientSound(g_sWitchDeath, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 0.8, 120, 0.0);
					EmitAmbientSound(g_sWitchDeath, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 0.7, 110, 0.0);
					EmitAmbientSound(g_sWitchDeath, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 0.6, 90, 0.0);
					EmitAmbientSound(g_sWitchDeath, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 0.5, 80, 0.0);
					EmitAmbientSound(g_sWitchDeath, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 0.4, 70, 0.0);
					EmitAmbientSound(g_sWitchDeath, fPos, SOUND_FROM_WORLD, 150, SND_NOFLAGS, 0.3, 60, 0.0);
				}
			}
		}
	}
}

public Action:MobCall(Handle:hTimer, any:iWitchKiller)
{
	new iClient = 0;
	for(new i = 1; i <= MaxClients; i++)
	{
		//Get some random inGame client for executing cheats
		if(IsClientInGame(i))
		{
			//Got some!
			iClient = i;
			break; //Exit the For-Loop
		}
	}
	
	//Noone found? exit everything
	if(iClient < 1)
		return Plugin_Stop;
	
	decl String:sCapText[64];
	sCapText[0] = 0;
	decl String:sValues[32];
	sValues[0] = 0;
	decl String:sColour[13];
	sColour[0] = 0;
	decl String:sIcon[32];
	sIcon[0] = 0;
	
	
	switch(GetRandomInt(1, 10))   //increased from 7 to 10 by infected aggregates
	{
		case 1:
		{
			if(g_bMobCall)
			{
				Client_ExecuteCheat(iClient, "z_spawn_old", "mob auto");
				switch(GetRandomInt(1, 4))
				{
					case 1:
					{
						EmitSoundToAllClients(g_sMobCall, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 94);
					}
					case 2:
					{
						EmitSoundToAllClients(g_sMobCall2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 75);
					}
					case 3:
					{
						EmitSoundToAllClients(g_sMobCall2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 130);
					}
					case 4:
					{
						EmitSoundToAllClients(g_sMobCall3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 90);
						EmitSoundToAllClients(g_sMobCall3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 90);
					}
				}
			}
			
			strcopy(sIcon, sizeof(sIcon), "icon_skull");
			strcopy(sCapText, sizeof(sCapText), "The Witch Has Summoned a Wave!\0");
			strcopy(sColour, sizeof(sColour), "125 160 110");
		}
		case 2:
		{
			if(g_iTankMobCount > 0)
			{
				for(new x = 1; x <= g_iTankMobCount; x++)
					Client_ExecuteCheat(iClient, "z_spawn_old", "tank auto");
				
				switch(GetRandomInt(1, 4))
				{
					case 1:
					{
						EmitSoundToAllClients(g_sTankCall, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 2:
					{
						EmitSoundToAllClients(g_sTankCall2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 3:
					{
						EmitSoundToAllClients(g_sTankCall3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
						CreateTimer(2.7, TankCallp3, INVALID_HANDLE, TIMER_FLAG_NO_MAPCHANGE);
					}
					case 4:
					{
						EmitSoundToAllClients(g_sTankCall4, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
				}
				
				strcopy(sIcon, sizeof(sIcon), "icon_skull");
				strcopy(sCapText, sizeof(sCapText), "The Witch Has Summoned the Tank!\0");
				strcopy(sColour, sizeof(sColour), "255 1 1");
			}
		}
		case 3:
		{
			if(g_iChargerMobCount > 0)
			{
				for(new x = 1; x <= g_iChargerMobCount; x++)
					Client_ExecuteCheat(iClient, "z_spawn_old", "charger auto");
				
				switch(GetRandomInt(1, 4))
				{
					case 1:
					{
						EmitSoundToAllClients(g_sChargerMob, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 2:
					{
						EmitSoundToAllClients(g_sChargerMob2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 3:
					{
						EmitSoundToAllClients(g_sChargerMob3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 4:
					{
						EmitSoundToAllClients(g_sChargerMob4, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
				}
				
				strcopy(sIcon, sizeof(sIcon), "icon_skull");
				strcopy(sCapText, sizeof(sCapText), "The Witch Has Summoned Chargers!\0");
				strcopy(sColour, sizeof(sColour), "1 1 255");
			}
		}
		case 4:
		{
			if(g_iHunterMobCount > 0)
			{
				for(new x = 1; x <= g_iHunterMobCount; x++)
					Client_ExecuteCheat(iClient,"z_spawn_old", "hunter auto");
				
				switch(GetRandomInt(1, 4))
				{
					case 1:
					{
						EmitSoundToAllClients(g_sHunterMob, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 2:
					{
						EmitSoundToAllClients(g_sHunterMob2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 3:
					{
						EmitSoundToAllClients(g_sHunterMob3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 4:
					{
						EmitSoundToAllClients(g_sHunterMob4, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
				}
				
				strcopy(sIcon, sizeof(sIcon), "icon_skull");
				strcopy(sCapText, sizeof(sCapText), "The Witch Has Summoned Hunters!\0");
				strcopy(sColour, sizeof(sColour), "255 100 255");
			}
		}
		case 5:
		{
			if(g_iBoomerMobCount > 0)
			{
				for(new x = 1; x <= g_iBoomerMobCount; x++)
					Client_ExecuteCheat(iClient, "z_spawn_old", "boomer auto");
				
				switch(GetRandomInt(1, 4))
				{
					case 1:
					{
						EmitSoundToAllClients(g_sBoomerMob, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 2:
					{
						EmitSoundToAllClients(g_sBoomerMob2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 3:
					{
						EmitSoundToAllClients(g_sBoomerMob3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 4:
					{
						EmitSoundToAllClients(g_sBoomerMob4, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
				}
				
				strcopy(sIcon, sizeof(sIcon), "icon_skull");
				strcopy(sCapText, sizeof(sCapText), "The Witch Has Summoned Boomers!\0");
				strcopy(sColour, sizeof(sColour), "1 255 1");
			}
		}
		case 6:
		{
			if(g_iSmokerMobCount > 0)
			{
				for(new x = 1; x <= g_iSmokerMobCount; x++)
					Client_ExecuteCheat(iClient, "z_spawn_old", "smoker auto");
				
				switch(GetRandomInt(1, 4))
				{
					case 1:
					{
						EmitSoundToAllClients(g_sSmokerMob, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 2:
					{
						EmitSoundToAllClients(g_sSmokerMob2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 3:
					{
						EmitSoundToAllClients(g_sSmokerMob3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 4:
					{
						EmitSoundToAllClients(g_sSmokerMob4, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
				}
				
				strcopy(sIcon, sizeof(sIcon), "icon_skull");
				strcopy(sCapText, sizeof(sCapText), "The Witch Has Summoned Smokers!\0");
				strcopy(sColour, sizeof(sColour), "120 140 255");
			}
		}
		case 7:
		{
			if(g_iJockeyMobCount > 0)
			{
				for(new x = 1; x <= g_iJockeyMobCount; x++)
					Client_ExecuteCheat(iClient, "z_spawn_old", "jockey auto");
				
				switch(GetRandomInt(1, 4))
				{
					case 1:
					{
						EmitSoundToAllClients(g_sJockeyMob, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 2:
					{
						EmitSoundToAllClients(g_sJockeyMob2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 3:
					{
						EmitSoundToAllClients(g_sJockeyMob3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 4:
					{
						EmitSoundToAllClients(g_sJockeyMob4, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
				}
				
				strcopy(sIcon, sizeof(sIcon), "icon_skull");
				strcopy(sCapText, sizeof(sCapText), "The Witch Has Summoned Jockeys!\0");
				strcopy(sColour, sizeof(sColour), "130 255 200");
			}
		}
		case 8:
		{
			if(g_iSpitterMobCount > 0)
			{
				for(new x = 1; x <= g_iSpitterMobCount; x++)
					Client_ExecuteCheat(iClient, "z_spawn_old", "spitter auto");
				
				switch(GetRandomInt(1, 4))
				{
					case 1:
					{
						EmitSoundToAllClients(g_sSpitterMob, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 2:
					{
						EmitSoundToAllClients(g_sSpitterMob2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 3:
					{
						EmitSoundToAllClients(g_sSpitterMob3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
					case 4:
					{
						EmitSoundToAllClients(g_sSpitterMob4, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
					}
				}
				
				strcopy(sIcon, sizeof(sIcon), "icon_skull");
				strcopy(sCapText, sizeof(sCapText), "The Witch Has Summoned Spitters!\0");
				strcopy(sColour, sizeof(sColour), "10 150 180");
			}
		}
		case 9:
		{
			EmitSoundToAllClients(g_sNothing2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 85);
			
			strcopy(sIcon, sizeof(sIcon), "icon_info");
			strcopy(sCapText, sizeof(sCapText), "The Witch Hasn't Summoned Infected By Instant Death\0");
			strcopy(sColour, sizeof(sColour), "255 255 255");
			
		}
		case 10:
		{
			EmitSoundToAllClients(g_sNothing, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);
			
			strcopy(sIcon, sizeof(sIcon), "icon_info");
			strcopy(sCapText, sizeof(sCapText), "The Witch Can Summon Special Mobs\0");
			strcopy(sColour, sizeof(sColour), "255 255 255");
		}
	}
	
	if(g_bDirHint && sCapText[0] != 0 && IsClientInGame(iWitchKiller))
	{
		new iEntity = CreateEntityByName("env_instructor_hint");
		FormatEx(sValues, sizeof(sValues), "hint%d", iWitchKiller);
		DispatchKeyValue(iWitchKiller, "targetname", sValues);
		DispatchKeyValue(iEntity, "hint_target", sValues);
		
		Format(sValues, sizeof(sValues), "10");
		DispatchKeyValue(iEntity, "hint_timeout", sValues);
		DispatchKeyValue(iEntity, "hint_range", "999.0");
		DispatchKeyValue(iEntity, "hint_icon_onscreen", sIcon);
		DispatchKeyValue(iEntity, "hint_caption", sCapText);
		DispatchKeyValue(iEntity, "hint_color", sColour);
		DispatchSpawn(iEntity);
		AcceptEntityInput(iEntity, "ShowHint");
		
		Format(sValues, sizeof(sValues), "OnUser1 !self:Kill::4:1");
		SetVariantString(sValues);
		AcceptEntityInput(iEntity, "AddOutput");
		AcceptEntityInput(iEntity, "FireUser1");
	}
	
	return Plugin_Stop;
}
 
public Action:WitchMob(Handle:hTimer, any:iWitchKiller)
{
	
	new iClient = 0;
	for(new i = 1; i <= MaxClients; i++)
	{
		//Get some random inGame client for executing cheats
		if(IsClientInGame(i))
		{
			//Got some!
			iClient = i;
			break; //Exit the For-Loop
		}
	}
	
	//Noone found? exit everything
	if(iClient < 1)
		return Plugin_Stop;
	
	g_bWitchMobSet = true;
	
	EmitSoundToAllClients(g_sWitchDeath2, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 94);
	
	for(new i = 1; i <= 6; i++)                                          //AMOUNT OF WITCH COMING OUT FOR DEVIL WITCH INVOCATION
		Client_ExecuteCheat(iClient, "z_spawn_old", "witch auto");
	
	g_bWitchMobSet = false;
	
	return Plugin_Stop;
}

public Action:WitchMobSpawn(Handle:hTimer, any:iWitch)
{
	if(!IsValidEntity(iWitch))
		return;
	
	//PrintToChatAll("WitchMobSpawned?");
	decl Float:fWitchPos[3];
	
	GetEntPropVector(iWitch, Prop_Send, "m_vecOrigin", fWitchPos);
	AcceptEntityInput(iWitch, "kill");
	
	new iEntity = CreateEntityByName("info_zombie_spawn");
	
	DispatchKeyValue(iEntity, "Population", "witch");
	DispatchKeyValue(iEntity, "AttackOnSpawn", "1");
	
	DispatchSpawn(iEntity);
	
	TeleportEntity(iEntity, fWitchPos, NULL_VECTOR, NULL_VECTOR);
	
	ActivateEntity(iEntity);
	
	g_bWitchMobOnly = true;
	
	AcceptEntityInput(iEntity, "SpawnZombie");
	//SetVariantString("OnUser1 !self:SpawnZombie::0.1:1");
	//AcceptEntityInput(iEntity, "AddOutput");
	//AcceptEntityInput(iEntity, "FireUser1");
	
	SetVariantString("OnUser2 !self:StartleZombie::0.1:1");
	AcceptEntityInput(iEntity, "AddOutput");
	AcceptEntityInput(iEntity, "FireUser2");
	
	SetVariantString("OnUser3 !self:Kill::5:1");
	AcceptEntityInput(iEntity, "AddOutput");
	AcceptEntityInput(iEntity, "FireUser3");
	
	
	//AcceptEntityInput(iEntity, "StartleZombie");
	//AcceptEntityInput(iEntity, "kill");
	
	
	
}

public Action:g_bWitchMobOnlyReset(Handle:hTimer)
{
	g_bWitchMobOnly = false;
	//PrintToChatAll("WitchMobBool False");
}

public Action:SetOffWitch(Handle:hTimer, any:iWitch)
{
	if(!IsValidEntity(iWitch))
		return Plugin_Stop;
	
	//PrintToChatAll("Searching for client to attack witch");
	
	new iClient = 0;
	for(new i = 1; i <= MaxClients; i++)
	{
		if(IsClientInGame(i) && GetClientTeam(i) == 2 && IsPlayerAlive(i))
		{
			//PrintToChatAll("Checking clients");
			iClient = i;
			break; //Exit the For-Loop
		}
	}
	//PrintToChatAll("Checking if valid after break");
	if(iClient < 1)
		return Plugin_Stop;
	
	//new String:sClassName[32];
	
	//GetEntityClassname(iClient, sClassName, 32);
	//PrintToChatAll("Hurty");
	Entity_Hurt(iWitch, 1, iClient, DMG_BULLET);
	//PrintToChatAll("Witch hit by %N", iClient);
	//g_bWitchMobSet = false;
	CreateTimer(0.1, g_bWitchMobOnlyReset, INVALID_HANDLE, TIMER_FLAG_NO_MAPCHANGE);
	
	return Plugin_Stop;
}

public Action:DevilWitchTimeOut(Handle:hTimer)
{
	g_bDevilWitch = false;//should be false
}

public ePreTankRush(Handle:hEvent, const String:sname[], bool:bDontBroadcast)
{
	if(g_bTankRush)
	{
		new iTank =  GetEventInt(hEvent, "tankid");
		if(iTank > 0 && iTank <= MaxClients && IsClientInGame(iTank) && GetClientTeam(iTank) == 3)
		{
			//Create unique UserID via GetClientUserId for easy checking if the client has disconnected
			//If the tank disconnected in the 0.1 sec the unique userID becomes invalid, perfect, no need to hooking Connect/Disconnect and no bugs when the client index gets replaced by another player who isn't a tank by re-joining
			CreateTimer(0.1, TankRush, GetClientUserId(iTank), TIMER_FLAG_NO_MAPCHANGE);
		}
	}
}

public Action:TankRush(Handle:hTimer, any:iUserID)
{
	//Convert UserID to Client Index again
	//If the Tank client disconnects in the meantime while the Timer was "sleepin", GetClientOfUserId will return -1
	new iTank = GetClientOfUserId(iUserID);
	
	if(iTank < 1 || iTank > MaxClients || !IsClientInGame(iTank))
		return Plugin_Stop;
	
	new iClient = 0;
	for(new i = 1; i <= MaxClients; i++)
	{
		if(IsClientInGame(i) && GetClientTeam(i) == 2 && IsPlayerAlive(i))
		{
			iClient = i;
			break; //Exit the For-Loop
		}
	}
	
	if(iClient < 1)
		return Plugin_Stop;
	
	Entity_Hurt(iTank, 1, iClient, DMG_BULLET);
	
	return Plugin_Stop;
}

public Action:TankCallp3(Handle:hTimer)
{
	EmitSoundToAllClients(g_sTankCallp3, SOUND_FROM_PLAYER, SNDCHAN_AUTO, 100, SND_NOFLAGS, 1.0, 100);// not really sure how to do this another way, if there is a better way comment it xD i'm too inexperienced
}

Client_ExecuteCheat(iClient, const String:sCmd[], const String:sArgs[])
{
	new flags = GetCommandFlags(sCmd);
	SetCommandFlags(sCmd, flags & ~FCVAR_CHEAT);
	FakeClientCommand(iClient, "%s %s", sCmd, sArgs);
	SetCommandFlags(sCmd, flags | FCVAR_CHEAT);
}

EmitSoundToAllClients(const String:sample[], entity = SOUND_FROM_PLAYER, channel = SNDCHAN_AUTO, level = SNDLEVEL_NORMAL, flags = SND_NOFLAGS, Float:volume = SNDVOL_NORMAL, pitch = SNDPITCH_NORMAL, speakerentity = -1, const Float:origin[3] = NULL_VECTOR, const Float:dir[3] = NULL_VECTOR, bool:updatePos = true, Float:soundtime = 0.0)
{
	for(new i = 1; i <= MaxClients; i++)
		if(IsClientInGame(i) && !IsFakeClient(i))
		EmitSoundToClient(i, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
}

stock bool:IsValidEntRef(iEntRef)
{
	new iEntity = EntRefToEntIndex(iEntRef);
	return (iEntRef && iEntity != INVALID_ENT_REFERENCE && IsValidEntity(iEntity));
}

stock bool:Create_Infected(Float:fOrigin[3], iAmount=1, bool:bForceAttack=false, const String:sPopulation[]="default", bool:bForceDirectSpawn=false, Float:fStartDelay=0.0, Float:fSpawnDelay=0.1)
{
	if(iAmount < 1) return false;
	
	static iEntity;
	iEntity = CreateEntityByName("info_zombie_spawn");
	if(iEntity == -1) return false;
	
	DispatchKeyValue(iEntity, "population", sPopulation);
	
	if(bForceAttack)
		DispatchKeyValue(iEntity, "AttackOnSpawn", "1");
	else
		DispatchKeyValue(iEntity, "AttackOnSpawn", "0");
	
	DispatchSpawn(iEntity);
	ActivateEntity(iEntity);
	
	TeleportEntity(iEntity, fOrigin, NULL_VECTOR, NULL_VECTOR);
	
	static i;
	
	if(bForceDirectSpawn)
	{
		for(i = 1; i <= iAmount; i++)
		{
			AcceptEntityInput(iEntity, "SpawnZombie");
		}
		return (AcceptEntityInput(iEntity, "Kill"));
	}
	
	else
	
	{
		AcceptEntityInput(iEntity, "SpawnZombie");
		
		static Float:fDelay;
		fDelay = fStartDelay;
		for(i = 1; i <= (iAmount - 1); i++)
		{
			fDelay += fSpawnDelay;
			
			Entity_CallTimer(iEntity, fDelay, "SpawnZombie", false);
			
		}
		
		Entity_CallTimer(iEntity, fDelay, "Kill");
		
		return true;
		
	}
}

public OnMapEnd()
{
	SetConVarInt(FindConVar("z_witch_speed"), 300);
	g_bDevilWitch = false;//should be false
}

stock bool:Entity_Hurt(entity, damage, attacker=0, damageType=DMG_GENERIC, const String:fakeClassName[]="")
{
	static point_hurt = INVALID_ENT_REFERENCE;
	
	if (point_hurt == INVALID_ENT_REFERENCE || !IsValidEntity(point_hurt)) {
		point_hurt = EntIndexToEntRef(Entity_Create("point_hurt"));
		
		if (point_hurt == INVALID_ENT_REFERENCE) {
			return false;
		}
		
		DispatchSpawn(point_hurt);
	}
	
	AcceptEntityInput(point_hurt, "TurnOn");
	SetEntProp(point_hurt, Prop_Data, "m_nDamage", damage);
	SetEntProp(point_hurt, Prop_Data, "m_bitsDamageType", damageType);
	Entity_PointHurtAtTarget(point_hurt, entity);
	
	if (fakeClassName[0] != '\0') {
		Entity_SetClassName(point_hurt, fakeClassName);
	}
	
	AcceptEntityInput(point_hurt, "Hurt", attacker);
	AcceptEntityInput(point_hurt, "TurnOff");
	
	if (fakeClassName[0] != '\0') {
		Entity_SetClassName(point_hurt, "point_hurt");
	}
	
	return true;
}

stock Entity_SetParent(entity, parent)
{
	SetVariantString("!activator");
	AcceptEntityInput(entity, "SetParent", parent);
}

stock Entity_Create(const String:className[], ForceEdictIndex=-1)
{
	if (ForceEdictIndex != -1 && Entity_IsValid(ForceEdictIndex)) {
		return INVALID_ENT_REFERENCE;
	}
	
	return CreateEntityByName(className, ForceEdictIndex);
}

stock Entity_SetClassName(entity, const String:className[])
{
	return DispatchKeyValue(entity, "classname", className);
}

stock Entity_IsValid(entity)
{
	return IsValidEntity(entity);
}

stock Entity_PointHurtAtTarget(entity, target, const String:name[]="")
{
	decl String:targetName[128];
	Entity_GetTargetName(entity, targetName, sizeof(targetName));
	
	if (name[0] == '\0') {
		
		if (targetName[0] == '\0') {
			// Let's generate our own name
			Format(
					targetName,
					sizeof(targetName),
					"_smlib_Entity_PointHurtAtTarget:%d",
					target
					);
		}
	}
	else {
		strcopy(targetName, sizeof(targetName), name);
	}
	
	DispatchKeyValue(entity, "DamageTarget", targetName);
	Entity_SetName(target, targetName);
}

stock Entity_GetTargetName(entity, String:buffer[], size)
{
	return GetEntPropString(entity, Prop_Data, "m_target", buffer, size);
}

stock Entity_SetName(entity, const String:name[], any:...)
{
	decl String:format[128];
	VFormat(format, sizeof(format), name, 3);
	
	return DispatchKeyValue(entity, "targetname", format);
}

stock PrecacheParticleSystem(const String:particleSystem[])
{
	static particleEffectNames = INVALID_STRING_TABLE;
	
	if (particleEffectNames == INVALID_STRING_TABLE) {
		if ((particleEffectNames = FindStringTable("ParticleEffectNames")) == INVALID_STRING_TABLE) {
			return INVALID_STRING_INDEX;
		}
	}
	
	new index = FindStringIndex2(particleEffectNames, particleSystem);
	if (index == INVALID_STRING_INDEX) {
		new numStrings = GetStringTableNumStrings(particleEffectNames);
		if (numStrings >= GetStringTableMaxStrings(particleEffectNames)) {
			return INVALID_STRING_INDEX;
		}
		
		AddToStringTable(particleEffectNames, particleSystem);
		index = numStrings;
	}
	
	return index;
}

stock FindStringIndex2(tableidx, const String:str[])
{
	decl String:buf[1024];
	
	new numStrings = GetStringTableNumStrings(tableidx);
	for (new i=0; i < numStrings; i++) {
		ReadStringTable(tableidx, i, buf, sizeof(buf));
		
		if (StrEqual(buf, str)) {
			return i;
		}
	}
	
	return INVALID_STRING_INDEX;
}

stock PrecacheMaterial(const String:material[])
{
	static materialNames = INVALID_STRING_TABLE;
	
	if (materialNames == INVALID_STRING_TABLE) {
		if ((materialNames = FindStringTable("Materials")) == INVALID_STRING_TABLE) {
			return INVALID_STRING_INDEX;
		}
	}
	
	new index = FindStringIndex2(materialNames, material);
	if (index == INVALID_STRING_INDEX) {
		new numStrings = GetStringTableNumStrings(materialNames);
		if (numStrings >= GetStringTableMaxStrings(materialNames)) {
			return INVALID_STRING_INDEX;
		}
		
		AddToStringTable(materialNames, material);
		index = numStrings;
	}
	
	return index;
  }
