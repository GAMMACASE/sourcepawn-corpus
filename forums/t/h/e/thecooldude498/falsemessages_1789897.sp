/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <tf2>
#include <tf2_stocks>
#include <colors_jindo>

#define PL_VERSION		"3.1"

#define ACHIEVEMENT_SOUND	"misc/achievement_earned.wav"
#define ITEM_LOSE			"player/crit_hit_mini.wav"

#define CVAR_VERSION	0
#define CVAR_FIREWORKS	1
#define CVAR_TXTCOLOR	2
#define CVAR_ITEMFLAG	3
#define CVAR_LOSESOUND	4
#define CVAR_ACHFLAG	5
#define CVAR_VOFLAG		6
#define CVAR_LOGFILE	7
#define CVAR_DELAY		8
#define CVAR_DIMMUNE	9
#define NUM_CVARS		10

new Handle:g_cvars[NUM_CVARS];

new g_ent[MAXPLAYERS+1];
new g_target[MAXPLAYERS+1];
new g_delay[MAXPLAYERS+1];

public Plugin:myinfo = 
{
	name = "False Messages",
	author = "Jindo",
	description = "Fabricate in-game messages and notifications.",
	version = PL_VERSION,
	url = "http://www.topaz-games.com/"
}

public OnPluginStart()
{
	LoadTranslations("falsemessages.phrases");
	
	g_cvars[CVAR_VERSION] = CreateConVar("falsemessages_version", PL_VERSION, "Version of the plugin.", FCVAR_PLUGIN|FCVAR_NOTIFY|FCVAR_REPLICATED);
	g_cvars[CVAR_FIREWORKS] = CreateConVar("falsemessages_fireworks", "1", "Non-zero enables the achievement fireworks for items real and fake.", FCVAR_PLUGIN);
	g_cvars[CVAR_LOSESOUND] = CreateConVar("falsemessages_losesound", "1", "Non-zero enables the lose item sound.", FCVAR_PLUGIN);
	g_cvars[CVAR_TXTCOLOR] = CreateConVar("falsemessages_textcolor", "0", "Non-zero uses the achievement text color in place of item text color on fake item messages.", FCVAR_PLUGIN);
	
	g_cvars[CVAR_ACHFLAG] = CreateConVar("falsemessages_achflag", "a", "Admin flag required for players to use achievement-related commands.", FCVAR_PLUGIN);
	g_cvars[CVAR_VOFLAG] = CreateConVar("falsemessages_voflag", "a", "Admin flag required for players to use the fake voice command.", FCVAR_PLUGIN);
	
	g_cvars[CVAR_LOGFILE] = CreateConVar("falsemessages_logfile", "logs/falsemessages.cfg", "Non-empty specifies a file to log usage to, relative to the Sourcemod folder. Leave this blank to log to the SM log files.", FCVAR_PLUGIN);
	g_cvars[CVAR_DELAY] = CreateConVar("falsemessages_delay", "0", "Non-zero specifies a period for which the player cannot reuse fake commands.", FCVAR_PLUGIN);
	g_cvars[CVAR_DIMMUNE] = CreateConVar("falsemessages_nodelayflag", "", "Anyone with flags specified in this cvar are immune to the above delay.", FCVAR_PLUGIN);
	
	RegConsoleCmd("sm_fakelose", Command_FakeLose);
	RegConsoleCmd("sm_fakeach", Command_FakeAchievement);
	RegConsoleCmd("sm_fakeachievement", Command_FakeAchievement);
	RegConsoleCmd("sm_vo", Command_Voice);
	
	HookEvent("item_found", Event_Item_Found);
}

public OnMapStart()
{
	PrecacheSound(ACHIEVEMENT_SOUND, true);
	PrecacheSound(ITEM_LOSE, true);
}

public Action:Event_Item_Found(Handle:event, const String:name[], bool:dontBroadcast)
{
	if (GetConVarInt(g_cvars[CVAR_FIREWORKS]))
	{
		new client = GetEventInt(event, "player");
		if (client > 0 && client <= MaxClients)
		{
			if (IsClientConnected(client) && IsClientInGame(client))
			{
				if (IsPlayerAlive(client))
				{
					if (TF2_GetPlayerClass(client) != TF2_GetClass("spy"))
					{
						AchievementEffect(client);
					}
				}
			}
		}
	}
	return Plugin_Continue;
}

public Action:Command_FakeLose(client, args)
{
	if (g_delay[client] > 0)
	{
		ReplyToCommand(client, "[FM] %t", "wait", g_delay[client]);
		return Plugin_Handled;
	}
	decl String:flag[16];
	GetConVarString(g_cvars[CVAR_ITEMFLAG], flag, sizeof(flag));
	if (!IsClientAllowed(client, flag))
	{
		ReplyToCommand(client, "[FM] %t", "no access");
		return Plugin_Handled;
	}
	
	if(args < 2)
	{
		ReplyToCommand(client, "[SM] Usage: sm_fakelose <client> \"Item Name in Quotes\"");
		return Plugin_Handled;
	}
	
	decl String:player[64];
	GetCmdArg(1, player, sizeof(player));	
	
	decl String:item[64];
	GetCmdArg(2, item, sizeof(item));
	
	new String:target_name[MAX_TARGET_LENGTH]
	new target_list[MAXPLAYERS], target_count
	new bool:tn_is_ml
 
	if ((target_count = ProcessTargetString(
			player,
			client,
			target_list,
			MAXPLAYERS,
			COMMAND_FILTER_CONNECTED,
			target_name,
			sizeof(target_name),
			tn_is_ml)) <= 0)
	{
		ReplyToTargetError(client, target_count);
		return Plugin_Handled;
	}
	
	decl String:log[256];
	Format(log, sizeof(log), "%N used sm_fakelose \"%s\" on", client, item);
	if (target_count > 1)
	{
		Format(log, sizeof(log), "%s multiple targets.", log);
	}
	else
	{
		Format(log, sizeof(log), "%s %N.", log, target_list[0]);
	}
	LogCorrectly(log);
	
	for (new i=0; i<target_count; i++)
	{
		PrintItemMessage(client, item, target_list[i], 2);
	}
	
	return Plugin_Handled;
}

public Action:Command_FakeAchievement(client, args)
{
	if (g_delay[client] > 0)
	{
		ReplyToCommand(client, "[FM] %t", "wait", g_delay[client]);
		return Plugin_Handled;
	}
	decl String:flag[16];
	GetConVarString(g_cvars[CVAR_ACHFLAG], flag, sizeof(flag));
	if (!IsClientAllowed(client, flag))
	{
		ReplyToCommand(client, "[FM] %t", "no access");
		return Plugin_Handled;
	}
	
	if(args < 2)
	{
		ReplyToCommand(client, "[SM] Usage: sm_fakeach <client> \"Achievement in Quotes\"");
		return Plugin_Handled;
	}
	
	decl String:player[64];
	GetCmdArg(1, player, sizeof(player));	
	
	decl String:ach[64];
	GetCmdArg(2, ach, sizeof(ach));
	
	new String:target_name[MAX_TARGET_LENGTH]
	new target_list[MAXPLAYERS], target_count
	new bool:tn_is_ml
 
	if ((target_count = ProcessTargetString(
			player,
			client,
			target_list,
			MAXPLAYERS,
			COMMAND_FILTER_CONNECTED,
			target_name,
			sizeof(target_name),
			tn_is_ml)) <= 0)
	{
		ReplyToTargetError(client, target_count);
		return Plugin_Handled;
	}
	
	decl String:log[256];
	Format(log, sizeof(log), "%N used sm_fakeach \"%s\" on", client, ach);
	if (target_count > 1)
	{
		Format(log, sizeof(log), "%s multiple targets.", log);
	}
	else
	{
		Format(log, sizeof(log), "%s %N.", log, target_list[0]);
	}
	LogCorrectly(log);
	
	for (new i=0; i<target_count; i++)
	{
		AchievementMessage(client, target_list[i], ach);
	}
	
	Delay(client);
	
	return Plugin_Handled;
}

public Action:Command_Voice(client, args)
{
	if (g_delay[client] > 0)
	{
		ReplyToCommand(client, "[FM] %t", "wait", g_delay[client]);
		return Plugin_Handled;
	}
	decl String:flag[16];
	GetConVarString(g_cvars[CVAR_VOFLAG], flag, sizeof(flag));
	if (!IsClientAllowed(client, flag))
	{
		ReplyToCommand(client, "[FM] %t", "no access");
		return Plugin_Handled;
	}
	
	decl String:vo[200];
	GetCmdArgString(vo, sizeof(vo));
	PrintVoiceMessage(client, vo);
	
	decl String:log[256];
	Format(log, sizeof(log), "%N used sm_vo \"%s\".", client, vo);
	LogCorrectly(log);
	
	Delay(client);
	
	return Plugin_Handled;
}

stock PrintItemMessage(client, String:item[64], target, type)
{
	if (target < 0 || target > MaxClients)
	{
		return;
	}
	if (!IsClientConnected(target))
	{
		return;
	}
	if (!IsClientInGame(target))
	{
		return;
	}
	decl String:player_name[64];
	GetClientName(target, player_name, sizeof(player_name));
	switch (type)
	{
		case 1:
		{
			if (GetConVarInt(g_cvars[CVAR_TXTCOLOR]))
			{
				CPrintToChatAllEx(target, "%t", "found item olive", player_name, item);
			}
			else
			{
				CPrintToChatAllEx(target, "%t", "found item gold", player_name, item);
			}
		}
		case 2:
		{
			if (GetConVarInt(g_cvars[CVAR_TXTCOLOR]))
			{
				CPrintToChatAllEx(target, "%t", "lose item olive", player_name, item);
			}
			else
			{
				CPrintToChatAllEx(target, "%t", "lose item gold", player_name, item);
			}
			if (GetConVarInt(g_cvars[CVAR_LOSESOUND]))
			{
				new Float:pos[3] ;
				GetClientAbsOrigin(target, pos);
				EmitAmbientSound(ITEM_LOSE, pos, SOUND_FROM_WORLD, SNDLEVEL_NORMAL, SND_NOFLAGS, SNDVOL_NORMAL, SNDPITCH_NORMAL, 0.0);
			}
		}
		case 3:
		{
			if (GetConVarInt(g_cvars[CVAR_TXTCOLOR]))
			{
				CPrintToChatAllEx(target, "%t", "craft item olive", player_name, item);
			}
			else
			{
				CPrintToChatAllEx(target, "%t", "craft item gold", player_name, item);
			}
		}
	}
	if (type != 2 && GetConVarInt(g_cvars[CVAR_FIREWORKS]))
	{
		if (IsPlayerAlive(target) && TF2_GetPlayerClass(target) != TF2_GetClass("spy"))
		{
			AchievementEffect(target);
			new Float:pos[3];
			GetClientAbsOrigin(target, pos);
			EmitAmbientSound(ACHIEVEMENT_SOUND, pos, SOUND_FROM_WORLD, SNDLEVEL_NORMAL, SND_NOFLAGS, SNDVOL_NORMAL, SNDPITCH_NORMAL, 0.0);
		}
	}
	Delay(client);
}

stock PrintVoiceMessage(client, String:msg[])
{
	for (new i = 1; i <= MaxClients; i++)
	{
		if (i > 0 && i <= MaxClients && IsClientConnected(i) && IsClientInGame(i) && GetClientTeam(i) == GetClientTeam(client))
		{
			CPrintToChatEx(i, i, "{teamcolor}(%t) %N{default}: %s", "voice", client, msg);
		}
	}
}

stock AchievementMessage(client, target, String:ach[])
{
	if (target > 0 && target <= MaxClients)
	{
		if (IsClientConnected(target) && IsClientInGame(target))
		{
			if (IsPlayerAlive(target))
			{
				if (TF2_GetPlayerClass(target) != TF2_GetClass("spy"))
				{
					AchievementEffect(target);
					new Float:pos[3] ;
					GetClientAbsOrigin(target, pos);
					EmitAmbientSound(ACHIEVEMENT_SOUND, pos, SOUND_FROM_WORLD, SNDLEVEL_NORMAL, SND_NOFLAGS, SNDVOL_NORMAL, SNDPITCH_NORMAL, 0.0);
				}
			}
			decl String:player_name[64];
			GetClientName(target, player_name, sizeof(player_name));
			CPrintToChatAllEx(target, "%t", "achievement", player_name, ach);
		}
	}
}

AchievementEffect(client)
{
	if (client > 0 && client <= MaxClients)
	{
		if (IsClientConnected(client) && IsClientInGame(client))
		{
			if (IsPlayerAlive(client))
			{
				if (TF2_GetPlayerClass(client) == TF2_GetClass("spy"))
				{
					//Do a more advanced check to see if the spy is cloaked or disguised.
					return;
				}
				CreateTimer(0.01, Timer_Particles, client, TIMER_FLAG_NO_MAPCHANGE);
				CreateTimer(0.5, Timer_Trophy, client, TIMER_FLAG_NO_MAPCHANGE);
				CreateTimer(2.0, Timer_Particles, client, TIMER_FLAG_NO_MAPCHANGE);
				CreateTimer(10.0, Timer_Delete, client, TIMER_FLAG_NO_MAPCHANGE);
			}
		}
	}
	return;
}


public Action:Timer_Particles(Handle:timer, any:client)
{
	if (IsPlayerAlive(client) && IsClientConnected(client) && IsClientInGame(client))
	{
		AttachParticle(client, "mini_fireworks");
	}
	return Plugin_Handled;
}

public Action:Timer_Trophy(Handle:timer, any:client)
{
	if (IsPlayerAlive(client) && IsClientConnected(client) && IsClientInGame(client))
	{
		AttachParticle(client, "achieved");
	}
	return Plugin_Handled;
}

public Action:Timer_Delete(Handle:timer, any:client)
{
	DeleteParticle(g_ent[client]);
	g_ent[client] = 0;
	g_target[client] = 0;
}

stock AttachParticle(ent, String:particle_type[])
{
	new particle = CreateEntityByName("info_particle_system");
	decl String:name[128];
	
	if (IsValidEdict(particle))
	{
		new Float:pos[3] ;
		
		GetEntPropVector(ent, Prop_Send, "m_vecOrigin", pos);
		pos[2] += 74
		TeleportEntity(particle, pos, NULL_VECTOR, NULL_VECTOR);
		
		Format(name, sizeof(name), "target%i", ent);
		
		DispatchKeyValue(ent, "targetname", name);
		DispatchKeyValue(particle, "targetname", "tf2particle");
		DispatchKeyValue(particle, "parentname", name);
		DispatchKeyValue(particle, "effect_name", particle_type);
		DispatchSpawn(particle);
		
		SetVariantString(name);
		AcceptEntityInput(particle, "SetParent", particle, particle, 0);
		SetVariantString("flag");
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start");
		
		g_ent[ent] = particle;
		g_target[ent] = 1;
		
	}
	
}

stock DeleteParticle(any:particle)
{
    if (IsValidEntity(particle))
    {
        decl String:classname[256];
        GetEdictClassname(particle, classname, sizeof(classname));
		
        if (!strcmp(classname, "info_particle_system"))
        {
            RemoveEdict(particle);
        }
    }
}

stock bool:IsClientAllowed(client, const String:flags[])
{
	if (GetUserFlagBits(client) & ADMFLAG_ROOT)
	{
		return true;
	}
	new iFlags = ReadFlagString(flags);
	if (GetUserFlagBits(client) & iFlags)
	{
		return true;
	}
	return false;
}

stock LogCorrectly(const String:log[])
{
	decl String:logfile[64];
	GetConVarString(g_cvars[CVAR_LOGFILE], logfile, sizeof(logfile));
	if (!strcmp(logfile, ""))
	{
		LogMessage(log);
	}
	else
	{
		BuildPath(Path_SM, logfile, sizeof(logfile), "%s", logfile);
		LogToFile(logfile, log);
	}
}

Delay(client)
{
	decl String:immune_flag[26];
	GetConVarString(g_cvars[CVAR_DIMMUNE], immune_flag, sizeof(immune_flag));
	if (IsClientAllowed(client, immune_flag))
	{
		g_delay[client] = GetConVarInt(g_cvars[CVAR_DELAY]);
		CreateTimer(1.0, Timer_Delay, client, TIMER_FLAG_NO_MAPCHANGE);
	}
}

public Action:Timer_Delay(Handle:timer, any:client)
{
	g_delay[client]--;
	if (g_delay[client])
	{
		CreateTimer(1.0, Timer_Delay, client, TIMER_FLAG_NO_MAPCHANGE);
	}
	return Plugin_Handled;
}