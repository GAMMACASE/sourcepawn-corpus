/* Plugin Template generated by Pawn Studio */

#pragma semicolon 1
#include <sourcemod>
#include <sdktools>
#include <sdktools_functions>


#define ZOMBIECLASS_SURVIVOR	9
#define ZOMBIECLASS_SMOKER	1
#define ZOMBIECLASS_BOOMER	2
#define ZOMBIECLASS_HUNTER	3
#define ZOMBIECLASS_SPITTER	4
#define ZOMBIECLASS_JOCKEY	5
#define ZOMBIECLASS_CHARGER	6
new ZOMBIECLASS_TANK=	5;

new GameMode;
new L4D2Version;
new SafeRoom=0;
public Plugin:myinfo = 
{
	name = "[L4D2] Coop",
	author = "Pan Xiaohai",
	description = "<- Description ->",
	version = "1.4",
	url = "<- URL ->"
} 
 

new Handle:l4d_together_enable; 
new Handle:l4d_together_loner_range; 
 

new Handle:l4d_together_loner_punish; 
new Handle:l4d_punish_intervual_min;
new Handle:l4d_punish_intervual_max;

new Handle:l4d_safedoor_require_count;
new Handle:l4d_safedoor_require_notank;
new Handle:l4d_safedoor_ignore_bot;

public OnPluginStart()
{
	GameCheck(); 	
	if(GameMode!=1) return;
	l4d_together_enable= 		CreateConVar("l4d2_together_enable", "1", "Enable plugin? 0 = Disable, 1 = Enable");
 	l4d_together_loner_range=	CreateConVar("l4d2_together_loner_range", "1000.0", "How far does a player have to be from his team to be a loner?"); 
	
	l4d_together_loner_punish= 	CreateConVar("l4d2_together_loner_punish", "1", "Enable punish system? 0 = Disable, 1 = Enable, spawn infected to punish loner.");
	l4d_punish_intervual_min= 	CreateConVar("l4d2_together_loner_punish_intervual_min", "10.0", "Minimum seconds to punish a loner.");	
	l4d_punish_intervual_max= 	CreateConVar("l4d2_together_loner_punish_intervual_max", "20.0", "Maximum seconds to punish a loner.");
	
	l4d_safedoor_require_count= CreateConVar("l4d2_together_saferoom_require_count", "4", "Minimum count of suvivors required to operate saferoom door, 0 = Disable, survivors can operate saferoom in any condition.");
	l4d_safedoor_require_notank= CreateConVar("l4d2_together_safedoor_require_notank", "1", "1 = Cannot operate saferoom door with Tank alive, 0 = Ignore Tank.");
	l4d_safedoor_ignore_bot= CreateConVar("l4d2_together_safedoor_ignore_bot", "0", "1 = Ignore bot, 0 = Do not ignore bot.");

 	
	AutoExecConfig(true, "l4d2_coop");	
	RegConsoleCmd("sm_alone", sm_alone); 
 
	HookEvent("player_spawn", player_spawn);	
	HookEvent("player_death", player_death); 
	
	HookEvent("round_start", round_start);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition",  round_end);	 
	if(L4D2Version)
	{
		HookEvent("player_left_checkpoint", player_left_start_area);
		HookEvent("player_entered_checkpoint", player_left_start_area);	
	}
	else
	{
		HookEvent("player_left_start_area",  player_left_start_area); 
	}
	HookEvent("player_use", player_use);
	ResetAllState();
}
 
new PlayerCompanionCount[MAXPLAYERS+1];
new PlayerClosestCompanionCount[MAXPLAYERS+1]; 
new Float:PlayerAloneStartTime[MAXPLAYERS+1];
new Float:PlayerSpawnTime[MAXPLAYERS+1];
new Float:PlayerSpawnIntervual[MAXPLAYERS+1];
new bool:Msg[MAXPLAYERS+1];
new PlayerIndex=0; 
new SurviorHumanCount=0; 
new SurviorBotCount=0; 
new bool:GameStart=false; 
bool:IsLeftStartAreaArea()
{
	new ent = -1, maxents = GetMaxEntities();
	for (new i = MaxClients+1; i <= maxents; i++)
	{
		if (IsValidEntity(i))
		{
			decl String:netclass[64];
			GetEntityNetClass(i, netclass, sizeof(netclass));
			
			if (StrEqual(netclass, "CTerrorPlayerResource"))
			{
				ent = i;
				break;
			}
		}
	}
	
	if (ent > -1)
	{
		new offset = FindSendPropInfo("CTerrorPlayerResource", "m_hasAnySurvivorLeftSafeArea");
		if (offset > 0)
		{
			if (GetEntData(ent, offset))
			{
				if (GetEntData(ent, offset) == 1) return true;
			}
		}
	}
	return false;
}
public Action:player_spawn(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(hEvent, "userid")); 
	if(client>0)
	{
 
		PlayerCompanionCount[client]=1;
		PlayerClosestCompanionCount[client]=1;
		PlayerAloneStartTime[client]=GetEngineTime(); 
		PlayerSpawnTime[client]=GetEngineTime(); 
		PlayerSpawnIntervual[client]=0.0;
		Msg[client]=true;
	}
}
public Action:player_death(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(hEvent, "userid"));
	if(client>0)
	{
 
		PlayerCompanionCount[client]=1;
		PlayerClosestCompanionCount[client]=1;
		PlayerAloneStartTime[client]=GetEngineTime(); 
		PlayerSpawnTime[client]=GetEngineTime(); 
		PlayerSpawnIntervual[client]=0.0;
		Msg[client]=true;
	}
	
}
public Action:round_start(Handle:event, const String:name[], bool:dontBroadcast)
{ 
	ResetAllState(); 
}
public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	ResetAllState();
	for (new i=1; i<=MaxClients; i++)
	{
		if (IsClientInGame(i))
		{
			if (GetClientTeam(i) == 3)
			{
				if (IsFakeClient(i))
				{
					KickClient(i);
				}
			}
		}
	}	
}
 
ResetAllState()
{  
	SafeRoom=0;
	new Float:time=GetEngineTime();
	PlayerIndex=0;
	SurviorHumanCount=0;
	GameStart=false;
	for( new i=1; i<=MaxClients; i++)
	{ 		
 
		PlayerCompanionCount[i]=1; 
		PlayerClosestCompanionCount[i]=1;
		PlayerAloneStartTime[i]=time;
		PlayerSpawnTime[i]=time;
		PlayerSpawnIntervual[i]=0.0;
		Msg[PlayerIndex]=true;
	}
}
public Action:player_left_start_area(Handle:event, const String:name[], bool:dontBroadcast)
{
	GameStart=true;
}
public Action:player_use(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(GetConVarInt(l4d_together_enable)==0)return;
	
	
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new targetid = GetEventInt(event, "targetid");
	if(client>0)
	{ 
		new String:entname[64];
		if(GetEdictClassname(targetid, entname, sizeof(entname)))
		{ 
			if(StrEqual(entname, "prop_door_rotating_checkpoint"))
			{
				if(SafeRoom==0)SafeRoom=targetid;
				if(SafeRoom==targetid)return;
				if((IsLeftStartAreaArea() ) && GetConVarInt(l4d_safedoor_require_notank)==1 && HaveTank())
				{
					AcceptEntityInput(targetid, "Lock"); 
					SetEntProp(targetid, Prop_Data, "m_hasUnlockSequence", 1);
					PrintToChat(client, "We must kill all Tanks before we can operate the door!");
				}
				else 
				{
					new require=GetConVarInt(l4d_safedoor_require_count);
					if(require==0)return;
					new survivorCount;
					if(GetConVarInt(l4d_safedoor_ignore_bot)==1)survivorCount=SurviorHumanCount ;
					else  survivorCount=SurviorHumanCount+SurviorBotCount;
					new companion=PlayerClosestCompanionCount[client];									
					if(require>=survivorCount)require=survivorCount; 
					if(companion<require)
					{
						AcceptEntityInput(targetid, "Lock"); 
						SetEntProp(targetid, Prop_Data, "m_hasUnlockSequence", 1);
						PrintToChat(client, "We need at least %d people to operate the door!", require);
					}
					else
					{ 
						SetEntProp(targetid, Prop_Data, "m_hasUnlockSequence", 0);
						AcceptEntityInput(targetid, "Unlock"); 	 
					}
				}
			}
		}
	}
}
bool:HaveTank()
{
	for( new i=1; i<=MaxClients; i++)
	{
		if(IsClientInGame(i) && GetClientTeam(i)==3 )
		{
			if(IsPlayerAlive(i) && IsInfected(i, ZOMBIECLASS_TANK))
			{
				return true;
			}  
		} 
	} 	
	return false;
}
IsInfected(client, type)
{
	new class = GetEntProp(client, Prop_Send, "m_zombieClass");
	if(type==class)return true;
	else return false;
}
public Action:sm_alone(client,args)
{
	if(client>0)
	{
		for( new i=1; i<=MaxClients; i++)
		{
			if(IsClientInGame(i) && GetClientTeam(i)==2)
			{
				if(IsPlayerAlive(i) && GetEngineTime()-PlayerAloneStartTime[i]>5.0)
				{
					PrintToChatAll("%N", i);
				}
			}
			
		}
	}
}
public Action:TimerUpdatePlayer(Handle:timer, any:data)
{
	if(GetConVarInt(l4d_together_enable)==0)return Plugin_Continue;
	if(!NextPlayer())return Plugin_Continue; 
	decl Float:playerPos[3];
	decl Float:pos[3];
	GetClientEyePosition(PlayerIndex, playerPos);
	new playerCount=0;
	new botCount=0;
	new Float:time=GetEngineTime();
	new closestCompanionCount=1;
	new companionCount=1;
	new Float:loner_rage=GetConVarFloat(l4d_together_loner_range);
	new bool:ignoreBot=GetConVarInt(l4d_safedoor_ignore_bot)==1;
	for( new i=1; i<=MaxClients; i++)
	{
		if(IsClientInGame(i) && GetClientTeam(i)==2 )
		{
			if(IsPlayerAlive(i))
			{
				new isbot=IsFakeClient(i);
				if(isbot)botCount++;
				else playerCount++;
				if(i==PlayerIndex)continue;
				
				GetClientEyePosition(i, pos);
				new Float:dis=GetVectorDistance(pos, playerPos);
				//if(PlayerIndex==1)PrintToChatAll("%N dis %f, range %f",i, dis,loner_rage );
				if(dis<loner_rage)
				{
					companionCount++;					 
				} 
				if(dis<=500.0)
				{
					if(ignoreBot && isbot)
					{
						
					}
					else closestCompanionCount++;
				}
			}  
		} 
	}  
	SurviorBotCount=botCount;
	SurviorHumanCount=playerCount;
	PlayerCompanionCount[PlayerIndex]=companionCount;
 	PlayerClosestCompanionCount[PlayerIndex]=closestCompanionCount; 
	if(companionCount>1 && botCount+playerCount>1)
	{		
		PlayerAloneStartTime[PlayerIndex]=time; 	
		Msg[PlayerIndex]=true;  
	} 	 
	else 
	{
		if(Msg[PlayerIndex])
		{
			PrintHintText(PlayerIndex, "WARNING! You are too far from your teammates."); 
		}
		Msg[PlayerIndex]=false;
	}
	
	if(botCount+playerCount>1 && time-PlayerAloneStartTime[PlayerIndex]>5.0 && GetConVarInt(l4d_together_loner_punish)==1)
	{  
		if(PlayerSpawnTime[PlayerIndex]+PlayerSpawnIntervual[PlayerIndex]<time)
		{ 
			CreateTimer(0.1, TimerPunishLoner, PlayerIndex, TIMER_FLAG_NO_MAPCHANGE);	 
			PlayerSpawnTime[PlayerIndex]=time;
			PlayerSpawnIntervual[PlayerIndex]=GetRandomFloat(GetConVarFloat(l4d_punish_intervual_min), GetConVarFloat(l4d_punish_intervual_max));			
		}		
	} 
	return Plugin_Continue;
}
public Action:TimerPunishLoner(Handle:timer, any:client)
{
	PunishLoner(client);
}
PunishLoner(client)
{
	if(IsClientInGame(client) && GetClientTeam(client)==2 && IsPlayerAlive(client) && !IsPlayerIncapped(client))
	{ 
		decl Float:hitpos[3];
		decl Float:pos[3];
		decl Float:angle[3];
		decl Float:vec[3];
		GetClientEyePosition(client, pos);
		GetClientEyeAngles(client , angle);
		angle[0]=-25.0;
		GetAngleVectors(angle,angle,NULL_VECTOR,NULL_VECTOR);
		NormalizeVector(angle, angle);
		ScaleVector(angle,-1.0);
		CopyVector( angle, vec );
		GetVectorAngles(angle,angle);
		
		new Handle:trace= TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, TraceRayDontHitSelf, client); 
		if(TR_DidHit(trace))
		{	
			TR_GetEndPosition(hitpos, trace);
			NormalizeVector(vec,vec);
			ScaleVector(vec, -40.0);
			AddVectors(hitpos, vec, hitpos);
			
			new Float:d=GetVectorDistance(hitpos, pos); 
			if(d<200.0 && d>40.0)
			{ 
				SpawnInfected(hitpos);
			}
		}
		CloseHandle(trace);
	}
}
bool:IsPlayerIncapped(client)
{ 
	if (GetEntProp(client, Prop_Send, "m_isIncapacitated", 1)) return true;
	return false;
}
SpawnInfected(Float:pos[3])
{

	new bot = CreateFakeClient("Monster");
	if (bot > 0)	
	{		
		ChangeClientTeam(bot,3);  
		new random =0;
		
		decl bool:IsPalyerSI[MAXPLAYERS+1];
	 
		
		for(new i = 1; i <= MaxClients; i++)
		{	
			IsPalyerSI[i]=false;
			if(IsClientInGame(i) && IsPlayerAlive(i))
			{
				if(GetClientTeam(i)==3)
				{
					IsPalyerSI[i]=true;
				}
			}		 
		}
		
		if(L4D2Version)random=GetRandomInt(1,4);
		else random = GetRandomInt(1,2);
		decl String:siName[32]="";
		switch(random)
		{
			case 1: 
				siName="smoker";
			case 2:
			    siName="hunter";
			case 3:
				siName="jockey"; 
			case 4:
				siName="charger"; 
			
		} 
		
		SpawnCommand(bot, "z_spawn_old", siName);
		new selected=0;
		for(new i = 1; i <= MaxClients; i++)
		{	
			if(IsClientInGame(i) && IsPlayerAlive(i) && GetClientTeam(i)==3)
			{
				if(!IsPalyerSI[i])
				{
					selected=i;
					break;
				} 
			}		 
		}
		if(selected>0)
		{
			TeleportEntity(selected, pos, NULL_VECTOR, NULL_VECTOR ); 
		} 
		
		Kickbot(INVALID_HANDLE, bot); 
	}	  
}
public Action:Kickbot(Handle:timer, any:client)
{
	if (IsClientInGame(client))
	{
		if (IsFakeClient(client))
		{
			KickClient(client);
		}
	}
}
public bool:TraceRayDontHitSelf (entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}	
	return true;
}
CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
	target[1]=source[1];
	target[2]=source[2];
}
bool:NextPlayer()
{
	new bool:find=false;
	for(new i=PlayerIndex+1; i<=MaxClients; i++)
	{
		if(IsClientInGame(i) )
		{
			if(GetClientTeam(i)==2)
			{
				if(IsPlayerAlive(i))
				{
					find=true;
					PlayerIndex=i;
					break;
				} 
			} 
		}  
	}
	if(!find)
	{
		PlayerIndex=0;
	}
	return find;
	 
}
public Action:TimerAjust(Handle:timer, any:data)
{
 
	return Plugin_Continue;   
}
 
SpawnCommand(client, String:command[], String:arguments[] = "")
{
	if (client)
	{ 
		new flags = GetCommandFlags(command);
		SetCommandFlags(command, flags & ~FCVAR_CHEAT);
		FakeClientCommand(client, "%s %s", command, arguments);
		SetCommandFlags(command, flags);
	}
}

GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	
 
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
		ZOMBIECLASS_TANK=8;
		L4D2Version=true;
	}	
	else
	{
		ZOMBIECLASS_TANK=5;
		L4D2Version=false;
	}
	ZOMBIECLASS_TANK+=0;
}
 public OnMapStart()
{
	ResetAllState();
	if(GameMode!=1) return;
	CreateTimer(0.1, TimerUpdatePlayer, 0, TIMER_REPEAT|TIMER_FLAG_NO_MAPCHANGE);	
	SafeRoom=0;
} 