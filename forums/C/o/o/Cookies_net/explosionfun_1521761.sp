/* Script generated by SourcePawn IDE */

#pragma semicolon 1

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>

#define EXPLODE_SOUND "weapons/explode3.wav"

#define PLUGIN_VERSION "1.0.0.0"

new Handle:hRadius;
new Handle:hInnerRadius;
new Handle:hDamage;
new Float:flRadius;
new Float:flInnerRadius;
new Float:flOuterRadius;
new Float:flDamage;

public Plugin:myinfo = 
{
    name = "Explosion Fun",
    author = "Cookies",
    description = "Admins can make explosion where they look at",
    version = PLUGIN_VERSION,
    url = ""
}

public OnPluginStart()
{
    CreateConVar("explosion_fun_version", PLUGIN_VERSION, "Current Explosion Fun version", FCVAR_PLUGIN|FCVAR_NOTIFY|FCVAR_REPLICATED|FCVAR_DONTRECORD);
    
    hRadius = CreateConVar("explosion_fun_radius", "550", "The radius of the explosion", FCVAR_PLUGIN, true, 1.0);
    hInnerRadius = CreateConVar("explosion_fun_inner_radius", "50", "The inner radius of the explosion", FCVAR_PLUGIN, true, 1.0);
    hDamage = CreateConVar("explosion_fun_damage", "300", "The damage of the explosion", FCVAR_PLUGIN, true);
    
    HookConVarChange(hRadius, explosion_radius_changed);
    HookConVarChange(hInnerRadius, explosion_inner_radius_changed);
    HookConVarChange(hDamage, explosion_damage_changed);
    
    flRadius = GetConVarFloat(hRadius);
    flInnerRadius = GetConVarFloat(hInnerRadius);
    flDamage = GetConVarFloat(hDamage);
    flOuterRadius = flRadius - flInnerRadius;

    RegAdminCmd("sm_createexplosion", cmd_createexplosion, ADMFLAG_ROOT, "Creates an explosion where the client looks at", "", FCVAR_PLUGIN);
}

public Action:cmd_createexplosion(client, args)
{
    decl Float:pos[3];
    if (LookPoint(client, pos))
    {
        CreateExplosionEffects(pos);
        Damage(pos, client);
    }
    return Plugin_Handled;
}

bool:LookPoint(client, Float:dest[3])
{
    decl Float:ang[3];
    decl Float:pos[3];
    
    GetClientEyePosition(client, pos);
    GetClientEyeAngles(client, ang);
    
    new Handle:trace = TR_TraceRayFilterEx(pos, ang, MASK_SHOT, RayType_Infinite, FilterPlayer, client);

    if(TR_DidHit(trace))
    {        
        TR_GetEndPosition(dest, trace);
    }
    else
    {
        CloseHandle(trace);
        return false;
    }
    
    CloseHandle(trace);
    return true;
}

public bool:FilterPlayer(entity, contentsMask, any:data)
{
    return entity != data;
}

CreateExplosionEffects(Float:pos[3])
{
    new ent = CreateEntityByName("info_particle_system");
    if (IsValidEntity(ent))
    {
        TeleportEntity(ent, pos, NULL_VECTOR, NULL_VECTOR);
        DispatchKeyValue(ent, "effect_name", "asplode_hoodoo");
        DispatchSpawn(ent);
        ActivateEntity(ent);
        AcceptEntityInput(ent, "start");
        SetVariantString("OnUser1 !self:Kill::8:-1");
        AcceptEntityInput(ent, "AddOutput");
        AcceptEntityInput(ent, "FireUser1");
        EmitAmbientSound(EXPLODE_SOUND, pos, _, SNDLEVEL_SCREAMING);
    }
}

Damage(Float:pos[3], client)
{
    for (new i = 1; i <= MaxClients; i++)
    {
        if (IsClientInGame(i) && IsPlayerAlive(i))
        {
            decl Float:pos2[3];
            
            GetClientAbsOrigin(i, pos2);
            new Float:dist = GetVectorDistance(pos, pos2);
            
            if (dist <= flRadius)
            {
                new Float:damage = flDamage * ClampFloat((flOuterRadius - (dist - flInnerRadius)) / flOuterRadius, 0.0, 1.0);
                pos[2] -= 50.0;
                PushDamagePlayer(client, i, dist, damage, pos, pos2);
                pos[2] += 50.0;
            }
        }
    }
    new ent = -1;
    while ((ent = FindEntityByClassname(ent, "obj_sentrygun")) != -1)
    {
        DamageBuildable(ent, client, pos);
    }
    while ((ent = FindEntityByClassname(ent, "obj_dispenser")) != -1)
    {
        DamageBuildable(ent, client, pos);
    }
    while ((ent = FindEntityByClassname(ent, "obj_teleporter")) != -1)
    {
        DamageBuildable(ent, client, pos);
    }
}

DamageBuildable(ent, attacker, Float:pos[3])
{
    decl Float:pos2[3];
    GetEntPropVector(ent, Prop_Send, "m_vecOrigin", pos2);
    
    new Float:dist = GetVectorDistance(pos, pos2);
    if (dist <= flRadius)
    {
        new Float:damage = flDamage * ClampFloat((flOuterRadius - (dist - flInnerRadius)) / flOuterRadius, 0.0, 1.0);
        SDKHooks_TakeDamage(ent, attacker, attacker, damage, DMG_BLAST);
    }
}

PushDamagePlayer(attacker, victim, Float:distance, Float:damage, Float:pos1[3], Float:pos2[3])
{
    decl Float:vel[3], Float:vel2[3];
    MakeVectorFromPoints(pos1, pos2, vel);
    NormalizeVector(vel, vel);
    ScaleVector(vel, 250 + ((flRadius - distance) / flRadius) * 500);
    GetEntPropVector(victim, Prop_Data, "m_vecAbsVelocity", vel2);
    AddVectors(vel, vel2, vel);
    TeleportEntity(victim, NULL_VECTOR, NULL_VECTOR, vel);
    if (attacker != victim) SDKHooks_TakeDamage(victim, attacker, attacker, damage, DMG_BLAST);
}

Float:ClampFloat(Float:val, Float:min, Float:max)
{
    return (val < min ? min : val > max ? max : val);
}

public explosion_radius_changed(Handle:convar, String:oldValue[], String:newValue[])
{
    flRadius = StringToFloat(newValue);
    flOuterRadius = flRadius - flInnerRadius;
}

public explosion_inner_radius_changed(Handle:convar, String:oldValue[], String:newValue[])
{
    flInnerRadius = StringToFloat(newValue);
    flOuterRadius = flRadius - flInnerRadius;
}

public explosion_damage_changed(Handle:convar, String:oldValue[], String:newValue[])
{
    flDamage = StringToFloat(newValue);
}




