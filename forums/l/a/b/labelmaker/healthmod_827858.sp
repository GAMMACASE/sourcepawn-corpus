/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <damage>

new g_playerAttacking[MAXPLAYERS + 1];
new bool:g_alreadykilled[MAXPLAYERS + 1];

public Plugin:myinfo = 
{
	name = "Health Modding",
	author = "LabelMaker",
	description = "Double Damage and Health Modding Example",
	version = "1.0",
	url = "<- URL ->"
}

public OnPluginStart()
{
	HookEvent("player_hurt", EventDamage, EventHookMode_Pre);
}

public OnEventShutdown()
{
	UnhookEvent("player_spawn", PlayerSpawnEvent);
}

public OnGameFrame()
{
    SaveAllHealth();
}

public PlayerSpawnEvent(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (client > 0)
	{	
		SaveHealth(client);
		g_alreadykilled[client] = false;
	}
}

public EventDamage(Handle:Event, const String:Name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(Event, "userid"));
	
	if (g_alreadykilled[victim])//this will prevent players gaining multiple kills for a single kill
	{
		g_alreadykilled[victim] = false;
		return;
	}
	
	new attacker = GetClientOfUserId(GetEventInt(Event, "attacker"));
	new bool:self = false;
	new v_health = GetEntProp(victim, Prop_Send, "m_iHealth");
	//new a_health = GetEntProp(attacker, Prop_Send, "m_iHealth");
	new damage = GetDamage(Event, victim, attacker, -1, -1);
	new victimFlags = GetEntProp(victim, Prop_Data, "m_fFlags", victimFlags);
	
	if (attacker == victim) self = true;
	if (!self && attacker != 0 && IsClientConnected(attacker))
	{
		v_health -= damage; // this will double the damage done by subtracting again whats already been done.
	}
	
	//is victim or attacker dead?
	if (v_health != GetEntProp(victim, Prop_Send, "m_iHealth"))
	{
		if (v_health < 1)
		{
			g_playerAttacking[attacker] = victim;
			CreateTimer(0.1, checkDeath, victim);// wait a frame to prevent invincible exploit
		}
		else
		{
			SetEntityHealth(victim, v_health);
			SaveHealth(victim);
		}
	}
	/* this section is only needed if you apply anything health related to your attacker//
	if (a_health != GetEntProp(attacker, Prop_Send, "m_iHealth"))
	{
		if (a_health < 1)
		{
			g_playerAttacking[victim] = attacker;
			CreateTimer(0.01, checkDeath, attacker);
		}
		else
		{
			SetEntityHealth(attacker, a_health);
			SaveHealth(attacker);
		}
	}
	///////////////////////////////////////////////////////////////////////////////////////*/
}

public Action:checkDeath(Handle:timer, any:client)
{
	new attacker;
	new fFlags = GetEntProp(client, Prop_Data, "m_fFlags", fFlags);
	for(new i = 1; i <= MaxClients; ++i) 
	{ 
		if (IsClientConnected(i) && g_playerAttacking[i] == client) 
		{ 
			g_playerAttacking[i] = 0; 
			attacker = i; 
			break; 
		} 
	}  
	if (IsPlayerAlive(client) && !(fFlags & FL_KILLME)) KillPlayer(client, attacker); //if the game engine hasnt assigned the player for death, kill them.
}

KillPlayer(client, attacker)
{
	new ent = CreateEntityByName("env_explosion");
	if (IsValidEntity(ent))
	{
		g_alreadykilled[client] = true;//tell the damage event to halt, and let the game engine do the work.
		
		DispatchKeyValue(ent, "iMagnitude", "1000");
		DispatchKeyValue(ent, "iRadiusOverride", "2");
		SetEntPropEnt(ent, Prop_Data, "m_hInflictor", attacker);
		SetEntPropEnt(ent, Prop_Data, "m_hOwnerEntity", attacker);
		DispatchKeyValue(ent, "spawnflags", "3964");
		DispatchSpawn(ent);
		new Float:pos[3];
		GetClientAbsOrigin(client, pos);
		TeleportEntity(ent, pos, NULL_VECTOR, NULL_VECTOR);
		AcceptEntityInput(ent, "explode", client, client);
		CreateTimer(0.2, RemoveExplosion, ent);
	}
}

public Action:RemoveExplosion(Handle:timer, any:ent)
{
	if (IsValidEntity(ent))
	{
		RemoveEdict(ent);
	}
}
