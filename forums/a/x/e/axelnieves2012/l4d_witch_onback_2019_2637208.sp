/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 
#include <sdkhooks>
#define Model_Witch "models/infected/witch.mdl"
#define Model_Witch2 "models/infected/witch_bride.mdl"
new Anim[90];
new AnimCount=2;
new WitchEnt[MAXPLAYERS+1];
new bool:WitchViewOn[MAXPLAYERS+1];
new bool:On3rdPerson[MAXPLAYERS+1];
new Float:OffSets[100][3];


new GameMode;
new L4D2Version;
public Plugin:myinfo = 
{
	name = "Witch On Back",
	author = "Pan XiaoHai, Axel Juan Nieves",
	description = "Decoration For Witch Killer. Witch killer will put witch's body on his back",
	version = "1.3",
	url = "https://forums.alliedmods.net/showthread.php?p=1544645"
}
new Handle:l4d_witch_onback_bestpose;
public OnPluginStart()
{
	GameCheck(); 	
	if(L4D2Version)SetAnimL4d2();
	else SetAnimL4d1();
	l4d_witch_onback_bestpose = CreateConVar("l4d_witch_onback_bestpose", "0", "  0: random pose, 1: best pose", 0);

	AutoExecConfig(true, "l4d_witch_onback");  
 
 	HookEvent("witch_killed", witch_killed );  
	HookEvent("player_bot_replace", player_bot_replace );	 
	HookEvent("round_start", round_end);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition", round_end);	 
 	
	RegConsoleCmd("sm_witch", sm_witch); 
	RegConsoleCmd("sm_witchpose", sm_witchpose); 
	ResetAllState();
}
GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	GameMode=GameMode+0;
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
 
		L4D2Version=true;
	}	
	else
	{
		L4D2Version=false;
	}
 
}
public OnMapStart()
{  
	PrecacheModel(Model_Witch);
	if(L4D2Version)PrecacheModel(Model_Witch2);
}
new best_amin=0;
SetAnimL4d2()
{
	OffSets[1]=Float:{-5.000000,26.000000,-100.000000};
	OffSets[2]=Float:{-3.000000,32.000000,-100.000000};
	OffSets[3]=Float:{-1.000000,28.000000,-100.000000};
	OffSets[5]=Float:{-1.000000,28.000000,-100.000000};
	OffSets[7]=Float:{1.000000,26.000000,-100.000000};
	OffSets[8]=Float:{-3.000000,26.000000,-100.000000};
	OffSets[10]=Float:{-3.000000,24.000000,-100.000000};
	OffSets[16]=Float:{1.000000,28.000000,-100.000000};
	OffSets[18]=Float:{1.000000,32.000000,-100.000000}; 
	OffSets[35]=Float:{-5.000000,4.000000,-100.000000};
	OffSets[37]=Float:{1.000000,28.000000,-100.000000}; 
	OffSets[44]=Float:{-1.000000,28.000000,-100.000000};
	OffSets[45]=Float:{-1.000000,30.000000,-100.000000};
	OffSets[46]=Float:{-1.000000,32.000000,-100.000000};
	OffSets[49]=Float:{-3.000000,32.000000,-100.000000};
	OffSets[51]=Float:{-1.000000,30.000000,-100.000000};
	OffSets[54]=Float:{3.000000,32.000000,-100.000000};
	OffSets[55]=Float:{-1.000000,30.000000,-100.000000};
	OffSets[59]=Float:{-1.000000,28.000000,-100.000000};
	OffSets[61]=Float:{-5.000000,24.000000,-100.000000};
	OffSets[62]=Float:{-5.000000,22.000000,-100.000000};
	OffSets[66]=Float:{-5.000000,30.000000,-100.000000};
	OffSets[73]=Float:{-5.000000,0.000000,-100.000000};
	OffSets[74]=Float:{1.000000,10.000000,-100.000000};
	OffSets[76]=Float:{-5.000000,32.000000,-100.000000};
	OffSets[77]=Float:{-5.000000,34.000000,-100.000000}; //best
	OffSets[79]=Float:{-9.000000,20.000000,-100.000000};
	OffSets[80]=Float:{-15.000000,18.000000,-100.000000};
	AnimCount=0;
	for(new i=0;i<90; i++)
	{
		if(OffSets[i][2]==-100.0)
		{		
			Anim[AnimCount]=i;
			AnimCount++;
		}
	}
	best_amin=77;
}
SetAnimL4d1()
{
	OffSets[1]=Float:{1.000000,32.000000,-100.000000};
	OffSets[3]=Float:{-1.000000,28.000000,-100.000000};
	OffSets[4]=Float:{1.000000,28.000000,-100.000000};
	OffSets[5]=Float:{1.000000,32.000000,-100.000000};
	OffSets[6]=Float:{1.000000,22.000000,-100.000000};
	OffSets[9]=Float:{3.000000,26.000000,-100.000000};
	OffSets[29]=Float:{-1.000000,30.000000,-100.000000};
	OffSets[32]=Float:{-1.000000,30.000000,-100.000000};
	OffSets[36]=Float:{1.000000,32.000000,-100.000000};
	OffSets[37]=Float:{-1.000000,32.000000,-100.000000};
	OffSets[41]=Float:{-1.000000,32.000000,-100.000000};
	OffSets[43]=Float:{-1.000000,32.000000,-100.000000};
	OffSets[46]=Float:{1.000000,32.000000,-100.000000};
	OffSets[47]=Float:{1.000000,26.000000,-100.000000};
	OffSets[51]=Float:{1.000000,24.000000,-100.000000};
	OffSets[53]=Float:{-1.000000,20.000000,-100.000000};
	OffSets[54]=Float:{-5.000000,20.000000,-100.000000};
	OffSets[57]=Float:{-3.000000,20.000000,-100.000000};
	OffSets[65]=Float:{-9.000000,2.000000,-100.000000};
	OffSets[66]=Float:{-1.000000,14.000000,-100.000000};
	OffSets[68]=Float:{-1.000000,36.000000,-100.000000};
	OffSets[69]=Float:{-3.000000,32.000000,-100.000000}; //best 
	OffSets[70]=Float:{-1.000000,32.000000,-100.000000};
	OffSets[72]=Float:{-9.000000,18.000000,-100.000000};
	AnimCount=0;
	for(new i=0;i<90; i++)
	{
		if(OffSets[i][2]==-100.0)
		{		
			Anim[AnimCount]=i;
			AnimCount++;
		}
	}	
	best_amin=69;
}
 
public Action: sm_witchpose(client,args)
{
	for(new i=1; i<=MaxClients; i++)
	{
			
		if( IsWitch(WitchEnt[i]) )
		{
			client=i;
			if(client>0 && IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client)==2)
			{
				new anim=Anim[ GetRandomInt(0,AnimCount-1) ]; 
				new Float:ang[3]; 
				SetVector(ang, 0.0, 0.0, 90.0);
				new Float:pos[3];
				pos[0]=OffSets[anim][0];
				pos[1]=OffSets[anim][1];
				
				TeleportEntity(WitchEnt[client], pos, ang, NULL_VECTOR);		
				
				SetEntProp(WitchEnt[client], Prop_Send, "m_nSequence", anim);
				SetEntPropFloat(WitchEnt[client], Prop_Send, "m_flPlaybackRate", 1.0);		 
				
				//PrintToChatAll("pose m_nSequence %d ", anim);

				
			}
		}
	} 
	return Plugin_Continue;
	
} 

public void TP_OnThirdPersonChanged(client, bool:bIsThirdPerson)
{
	On3rdPerson[client] = bIsThirdPerson;
}

public Action:sm_witch(client,args)
{
	if(client>0)
	{
		
		WitchViewOn[client]=!WitchViewOn[client];
		if(WitchViewOn[client])PrintToChat(client, "\x04witch \x03view is \x04on");
		else PrintToChat(client, "\x04witch \x03view is \x04off, \x03but others still can see it on your back");
	}
}
 
public Action:player_death(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
	new victim = GetClientOfUserId(GetEventInt(hEvent, "userid")); 
	if(victim>0 && victim<=MaxClients)
	{
		DeleteDecoration(victim);
	}
	return Plugin_Continue;	 
}
public player_bot_replace(Handle:Spawn_Event, const String:Spawn_Name[], bool:Spawn_Broadcast)
{
 	new client = GetClientOfUserId(GetEventInt(Spawn_Event, "player"));
	new bot = GetClientOfUserId(GetEventInt(Spawn_Event, "bot"));   
	if(client>0)
	{
		DeleteDecoration(client);
	}
	if(bot>0)
	{
		DeleteDecoration(bot)		;
	}
}
public Action:witch_killed(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
	new attacker = GetClientOfUserId(GetEventInt(hEvent, "userid")); 
	if(attacker>0 && attacker<=MaxClients)
	{
		if(IsClientInGame(attacker) && IsPlayerAlive(attacker) && GetClientTeam(attacker)==2)
		{ 
			CreateDecoration(attacker);
		}
	}
	return Plugin_Continue;	 
}
public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	ResetAllState();
}
ResetAllState()
{
	for(new i=1; i<=MaxClients; i++)
	{
		WitchEnt[i]=0;
	}
}
bool:IsWitch(ent)
{
	if(ent>0 && IsValidEdict(ent) && IsValidEntity(ent))
	{
		return true;
	}
	else return false;
}
 
DeleteDecoration(client)
{
	if(IsWitch(WitchEnt[client]))
	{
		AcceptEntityInput(WitchEnt[client], "ClearParent");
		AcceptEntityInput(WitchEnt[client], "kill");
		SDKUnhook(WitchEnt[client], SDKHook_SetTransmit, Hook_SetTransmit);
	}
	WitchEnt[client]=0;
}
CreateDecoration(client)
{
	if(IsWitch(WitchEnt[client]) )return;
	new witch=CreateEntityByName("prop_dynamic_override"); 
	if(L4D2Version)
	{
		if(GetRandomInt(0,1)==0)DispatchKeyValue(witch, "model", Model_Witch2); 
		else DispatchKeyValue(witch, "model", Model_Witch);  
	}
	else DispatchKeyValue(witch, "model", Model_Witch);  
	DispatchSpawn(witch); 
	
	decl String:tname[60];
	Format(tname, sizeof(tname), "target%d", client);
	DispatchKeyValue(client, "targetname", tname); 		
	DispatchKeyValue(witch, "parentname", tname);
	
	SetVariantString(tname);
	AcceptEntityInput(witch, "SetParent",witch, witch, 0); 	
	SetVariantString("medkit"); 
	AcceptEntityInput(witch, "SetParentAttachment"); 
	
	new anim=0;
	if(GetConVarInt(l4d_witch_onback_bestpose)==0)anim=Anim[ GetRandomInt(0,AnimCount-1) ];
	else anim=best_amin;
	
	new Float:pos[3];
	new Float:ang[3];
	SetVector(pos, -5.0, 32.0, 0.0); 
	pos[0]=OffSets[anim][0];
	pos[1]=OffSets[anim][1]; 
	SetVector(ang, 0.0, 00.0, 90.0);
 	
	TeleportEntity(witch, pos, ang, NULL_VECTOR);
	SetEntityRenderMode(witch, RENDER_TRANSCOLOR);
	SetEntityRenderColor(witch, 255,0,0,255);
	SetEntProp(witch, Prop_Send, "m_CollisionGroup", 2);   


	SetEntProp(witch, Prop_Send, "m_nSequence", anim);
	SetEntPropFloat(witch, Prop_Send, "m_flPlaybackRate", 1.0);		
	
	WitchEnt[client]= witch ; 
 	if(GetConVarInt(l4d_witch_onback_bestpose)==0)CreateTimer(30.0, TimerAnimWitch, client, TIMER_FLAG_NO_MAPCHANGE| TIMER_REPEAT);
	SDKHook(WitchEnt[client], SDKHook_SetTransmit, Hook_SetTransmit);
	WitchViewOn[client]=false;
	PrintToChatAll("\x04%N \x03put witch on his back", client);
	PrintToChat(client, "\x04!witch \x03 : toggle to see or hide your own witch");
	
}

public Action:TimerAnimWitch(Handle:timer, any:client)
{
	if( IsWitch(WitchEnt[client]) )
	{
		if(client>0 && IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client)==2)
		{
			new anim=Anim[ GetRandomInt(0,AnimCount-1) ]; 
			
			new Float:ang[3]; 
			SetVector(ang, 0.0, 0.0, 90.0);
			new Float:pos[3];
			pos[0]=OffSets[anim][0];
			pos[1]=OffSets[anim][1];
			
			TeleportEntity(WitchEnt[client], pos, ang, NULL_VECTOR);		
			
			SetEntProp(WitchEnt[client], Prop_Send, "m_nSequence", anim);
			SetEntPropFloat(WitchEnt[client], Prop_Send, "m_flPlaybackRate", 1.0);		 
			
			return Plugin_Continue;
		}
		else
		{
			DeleteDecoration(client);
		}
	}
	WitchEnt[client]=0;
	return Plugin_Stop;
}
public Action:Hook_SetTransmit(entity, client)
{ 
	if(entity==WitchEnt[client])
	{
		if (WitchViewOn[client] || On3rdPerson[client]) return Plugin_Continue;
		else return Plugin_Handled;
	}
	return Plugin_Continue;
}
SetVector(Float:target[3], Float:x, Float:y, Float:z)
{
	target[0]=x;
	target[1]=y;
	target[2]=z;
}