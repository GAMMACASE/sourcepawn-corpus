/* Plugin Template generated by Pawn Studio */

/*
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* Version History
* 0.x	- Base code (setting up the correct convars and retrieving models).
* 1.0	- First release.
*/

// define
#define PLUGIN_VERSION "1.2"
#define PLUGIN_NAME "L4D Character selector"

// includes
#include <sourcemod>
#include <sdktools>

// Client numbers are dynamic, keep changing according to the spawn order

// CVars Handles
new Handle:l4d_charselect;

public Plugin:myinfo = 
{
	name = PLUGIN_NAME,
	author = "MagnoT",
	description = "[L4D] Lets players select a character to play with",
	version = PLUGIN_VERSION,
	url = "http://www.sourcemod.net/" //http://driftinc.co.nr
}

public OnPluginStart()
{
	RegConsoleCmd("say", Command_Say);
    l4d_charselect = CreateConVar("l4d_charselect", "1", "Enable Char Select Plugin", FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
}

public Action:Command_Say(client, args)
{
	if (GetConVarInt(l4d_charselect) == 0)
		return Plugin_Continue;

	if (!client)
	{
		return Plugin_Continue;
	}
	
	decl String:text[192];
	if (!GetCmdArgString(text, sizeof(text)))
	{
		return Plugin_Continue;
	}
	
	new startidx = 0;
	if(text[strlen(text)-1] == '"')
	{
		text[strlen(text)-1] = '\0';
		startidx = 1;
	}
	
	new ReplySource:old = SetCmdReplySource(SM_REPLY_TO_CHAT);
	
	if (strcmp(text[startidx], "!zoey", false) == 0)
	{
		new offset = FindSendPropInfo("CTerrorPlayer", "m_survivorCharacter");
		new char = GetEntData(client, offset, 1);
		
		// set char
		char = 1;
		SetEntData(client, offset, char, 1, true);
		
		// update client model info
		decl String:model[] = "models/survivors/survivor_teenangst.mdl";
		SetEntityModel(client, model);
	}
	else if (strcmp(text[startidx], "!louis", false) == 0)
	{
		new offset = FindSendPropInfo("CTerrorPlayer", "m_survivorCharacter");
		new char = GetEntData(client, offset, 1);

		// set char
		char = 3;
		SetEntData(client, offset, char, 1, true);
		
		// update client model info
		decl String:model[] = "models/survivors/survivor_manager.mdl";
		SetEntityModel(client, model);
	}
	else if (strcmp(text[startidx], "!francis", false) == 0)
	{
		new offset = FindSendPropInfo("CTerrorPlayer", "m_survivorCharacter");
		new char = GetEntData(client, offset, 1);

		// set char
		char = 2;
		SetEntData(client, offset, char, 1, true);
		
		// update client model info
		decl String:model[] = "models/survivors/survivor_biker.mdl";
		SetEntityModel(client, model);
	}
	else if (strcmp(text[startidx], "!bill", false) == 0)
	{
		new offset = FindSendPropInfo("CTerrorPlayer", "m_survivorCharacter");
		new char = GetEntData(client, offset, 1);

		// set char
		char = 4;
		SetEntData(client, offset, char, 1, true);
		
		// update client model info
		decl String:model[] = "models/survivors/survivor_namvet.mdl";
		SetEntityModel(client, model);
	}
	else if (strcmp(text[startidx], "!all zoey", false) == 0)
	{
		new AdminId:adminId = GetUserAdmin(client);
	
		// Checks if player is registered as an admin
		if (((adminId == INVALID_ADMIN_ID) ? false : GetAdminFlag(adminId, Admin_Root)) == false)
		{
			ReplyToCommand(client, "You don't have enough permissions to use this command.");
			return Plugin_Continue;
		}
		else
		{
			decl String:ClientSteamID[12];
			new offset = FindSendPropInfo("CTerrorPlayer", "m_survivorCharacter");
			new char;
			for (new i = 1; i <= GetMaxClients(); i++)
			{
				if (IsClientConnected(i))
				{
					GetClientAuthString(i, ClientSteamID, sizeof(ClientSteamID));
					if (!StrEqual(ClientSteamID, "BOT", false))
					{
						if (IsClientInGame(i) && !IsFakeClient(i))
						{
							char = GetEntData(i, offset, 1);			
						
							// set char
							char = 1;
							SetEntData(i, offset, char, 1, true);
							
							// update client model info
							decl String:model[] = "models/survivors/survivor_teenangst.mdl";
							SetEntityModel(i, model);
						}       
					}
				}
			}
		}
	}
	else if (strcmp(text[startidx], "!all louis", false) == 0)
	{
		new AdminId:adminId = GetUserAdmin(client);
	
		// Checks if player is registered as an admin
		if (((adminId == INVALID_ADMIN_ID) ? false : GetAdminFlag(adminId, Admin_Root)) == false)
		{
			ReplyToCommand(client, "You don't have enough permissions to use this command.");
			return Plugin_Continue;
		}
		else
		{
			decl String:ClientSteamID[12];
			new offset = FindSendPropInfo("CTerrorPlayer", "m_survivorCharacter");
			new char;		
			for (new i = 1; i <= GetMaxClients(); i++)
			{
				if (IsClientConnected(i))
				{
					GetClientAuthString(i, ClientSteamID, sizeof(ClientSteamID));
					if (!StrEqual(ClientSteamID, "BOT", false))
					{
						if (IsClientInGame(i) && !IsFakeClient(i))
						{
							char = GetEntData(i, offset, 1);			
						
							// set char
							char = 3;
							SetEntData(i, offset, char, 1, true);
							
							// update client model info
							decl String:model[] = "models/survivors/survivor_manager.mdl";
							SetEntityModel(i, model);
						}       
					}
				}
			}
		}
	}	
	else if (strcmp(text[startidx], "!all francis", false) == 0)
	{
		new AdminId:adminId = GetUserAdmin(client);
	
		// Checks if player is registered as an admin
		if (((adminId == INVALID_ADMIN_ID) ? false : GetAdminFlag(adminId, Admin_Root)) == false)
		{
			ReplyToCommand(client, "You don't have enough permissions to use this command.");
			return Plugin_Continue;
		}
		else
		{
			decl String:ClientSteamID[12];
			new offset = FindSendPropInfo("CTerrorPlayer", "m_survivorCharacter");
			new char;
			for (new i = 1; i <= GetMaxClients(); i++)
			{
				if (IsClientConnected(i))
				{
					GetClientAuthString(i, ClientSteamID, sizeof(ClientSteamID));
					if (!StrEqual(ClientSteamID, "BOT", false))
					{
						if (IsClientInGame(i) && !IsFakeClient(i))
						{
							char = GetEntData(i, offset, 1);
						
							// set char
							char = 2;
							SetEntData(i, offset, char, 1, true);
							
							// update client model info
							decl String:model[] = "models/survivors/survivor_biker.mdl";
							SetEntityModel(i, model);
						}       
					}
				}
			}
		}
	}	
	else if (strcmp(text[startidx], "!all bill", false) == 0)
	{
		new AdminId:adminId = GetUserAdmin(client);
	
		// Checks if player is registered as an admin
		if (((adminId == INVALID_ADMIN_ID) ? false : GetAdminFlag(adminId, Admin_Root)) == false)
		{
			ReplyToCommand(client, "You don't have enough permissions to use this command.");
			return Plugin_Continue;
		}
		else
		{
			decl String:ClientSteamID[12];
			new offset = FindSendPropInfo("CTerrorPlayer", "m_survivorCharacter");
			new char;
			for (new i = 1; i <= GetMaxClients(); i++)
			{
				if (IsClientConnected(i))
				{
					GetClientAuthString(i, ClientSteamID, sizeof(ClientSteamID));
					if (!StrEqual(ClientSteamID, "BOT", false))
					{
						if (IsClientInGame(i) && !IsFakeClient(i))
						{
							char = GetEntData(i, offset, 1);
						
							// set char
							char = 4;
							SetEntData(i, offset, char, 1, true);
							
							// update client model info
							decl String:model[] = "models/survivors/survivor_namvet.mdl";
							SetEntityModel(i, model);
						}       
					}
				}
			}
		}
	}	

	SetCmdReplySource(old);
	
	return Plugin_Continue;	
}