/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#include <sourcemod>
#include <sdktools>
#include <sdktools_functions> 
#include <sdkhooks> 

 
#define MAX_SIZE 30
new String:SoundName[MAX_SIZE][200];
new String:WeaponName[MAX_SIZE][100];

new Float:MeleeChangeEnable[MAX_SIZE][MAX_SIZE];
  
 
#define Position_Melee 1
#define Position_Melee2 2
#define Position_Bayonet 3
#define Position_Bayonet_smg 4
#define Position_Bayonet_sniper 5
#define Position_Bayonet_hunting 6
#define Position_Bayonet_m60 7
#define Position_Bayonet_grenade_launcher 8
#define Position_Bayonet_scout 9
#define Position_Bayonet_desert 10
#define Position_Bayonet_sg552 11
#define Position_Bayonet_mp5 12
#define Position_Back 21

#define ArraySize MAXPLAYERS+1

new LastWeapon[ArraySize];
  
new MeleeEnt[ArraySize];
new MeleeEnt2[ArraySize];
new bool:canchienOn[ArraySize];
new MeleeType[ArraySize]; 
new bool:Cuting[ArraySize];
new bool:HoldMeleeMutation[ArraySize];
new Float:CutingDistance[ArraySize];
new Float:CutingStartTime[ArraySize];
new Float:CutingStartPos[ArraySize][3];
new Float:CutingFrontDirection[ArraySize][3];
new Float:CutingRightDirection[ArraySize][3];
new Float:CutingMaxDamage[ArraySize];
new Float:CutingMaxDistance[ArraySize];
new Float:CutingDamage[ArraySize];
new CutingHit[ArraySize];
new bool:CutingEnemy[ArraySize][ArraySize];


new GameMode;
new L4D2Version;
new g_sprite;
new g_PointHurt=0;
 
public Plugin:myinfo = 
{
	name = "Can Chien Phong To",
	author = "panxiaohai conversion by kochiurun119",
	description = "L4D2 only",
	version = "1.3",
	url = "<- URL ->"
}
new Handle:canchienphongto;
new Handle:satthuongcongthem;
new Handle:kichcocuacanchien;
public OnPluginStart()
{
	GameCheck(); 	
	if(!L4D2Version)return;
	
 	canchienphongto = CreateConVar("canchienphongto", "1",  "0:Tat plugin, 1:Bat plugin ", FCVAR_PLUGIN);
 	satthuongcongthem = CreateConVar("satthuongcongthem", "50.0",  "[0.0, 100.0], 0.0:Sat Thuong Cong Them Cho Can Chien", FCVAR_PLUGIN);
	kichcocuacanchien = CreateConVar("kichcocuacanchien", "1.0",  "[0.5, 3.0] Kich Co Cua Can Chien", FCVAR_PLUGIN);
	
	AutoExecConfig(true, "canchienphongto"); 
	
	HookEvent("player_spawn", player_spawn);	
	HookEvent("player_death", player_death); 
	HookEvent("player_bot_replace", player_bot_replace );	  
	HookEvent("bot_player_replace", bot_player_replace );	
	
	HookEvent("round_start", round_start);
	HookEvent("round_end", round_end);
	HookEvent("finale_win", round_end);
	HookEvent("mission_lost", round_end);
	HookEvent("map_transition", round_end);	 
	
	HookEvent("player_use", player_use);	
	HookEvent("weapon_fire", weapon_fire);
	RegConsoleCmd("sm_canchien", sm_canchien);  
	ResetAllState();
	Init(); 
}
GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, sizeof(GameName));
	
	
	if (StrEqual(GameName, "survival", false))
		GameMode = 3;
	else if (StrEqual(GameName, "versus", false) || StrEqual(GameName, "teamversus", false) || StrEqual(GameName, "scavenge", false) || StrEqual(GameName, "teamscavenge", false))
		GameMode = 2;
	else if (StrEqual(GameName, "coop", false) || StrEqual(GameName, "realism", false))
		GameMode = 1;
	else
	{
		GameMode = 0;
 	}
	GameMode=GameMode+0;
	GetGameFolderName(GameName, sizeof(GameName));
	if (StrEqual(GameName, "left4dead2", false))
	{
 
		L4D2Version=true;
	}	
	else
	{
 
		L4D2Version=false;
	}
 
}

IsValidClient(client, team=0, bool:includeBot=true, bool:alive=true)
{
	if(client>0 && client<=MaxClients)
	{
		if(IsClientInGame(client))
		{
			if(GetClientTeam(client)!=team && team!=0)return false;
			if(IsFakeClient(client) && !includeBot)return false;			
			if(!IsPlayerAlive(client) && alive)return false;
			return true;
		}
	}
	return false;
}
public Action:player_use(Handle:event, const String:name[], bool:dontBroadcast) 
{ 
	if(GetConVarInt(canchienphongto)==0)return;
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if(IsValidClient(client, 2) )
	{ 	   
		new ent=GetPlayerWeaponSlot(client, 1);
		if(IsMeleeWeapon(ent))
		{ 
			new type=GetWeaopnType(ent);
			if(MeleeChangeEnable[type][type]>0.0)Start(client); 
		} 
	}
}
Start(client)
{
	if(client>0)
	{
		
		SDKUnhook(client, SDKHook_PreThink , ClientThink);
		SDKHook(client, SDKHook_PreThink , ClientThink);
	}
}

Stop(client)
{
	if(client>0)
	{
		SDKUnhook(client, SDKHook_PreThink , ClientThink); 
	}
}
StopAll()
{
	for(new i=1; i<=MaxClients; i++)
	{ 
		if(IsClientInGame(i))
		{
			SDKUnhook(i, SDKHook_PreThink , ClientThink); 
		}
	}
	 
} 
public ClientThink(client)
{
	new weapon=GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon" );
	if(weapon!=LastWeapon[client])
	{ 
		if(IsMeleeWeapon(weapon))
		{
			CreateMelee(client, weapon);
		}
		else
		{
			DeleteMelee(client);
		}
	}
	LastWeapon[client]=weapon;
	if(MeleeType[client]>0)
	{
		if(Cuting[client])
		{ 
			DoCut(client);
			if(CutingDistance[client]>CutingMaxDistance[client])
			{
				Cuting[client]=false;
			} 
		} 
	}
}

public Action:sm_canchien(client,args)
{ 
	if(client>0)
	{ 
		canchienOn[client]=!canchienOn[client];
 	} 
}
bool:IsMeleeWeapon(ent)
{
	if(ent>0 && IsValidEdict(ent) && IsValidEntity(ent))
	{
		decl String:item[64];
		GetEdictClassname(ent, item, sizeof(item));
		if(StrEqual(item, "weapon_melee"))
		{
			return true;
		}
	}
	return false;
}
bool:IsMeleeClone(ent)
{
	if(ent>0 && IsValidEdict(ent) && IsValidEntity(ent))
	{
		decl String:item[64];
		GetEdictClassname(ent, item, sizeof(item));
		if(StrEqual(item, "prop_dynamic"))
		{
			return true;
		}
	}
	return false;
}


 
#define Melee_FireAxe 1
#define Melee_cricket_bat 2
#define Melee_Katana 3
#define Melee_Machete 4
#define Melee_Guitar 5
#define Melee_pan 6
#define Melee_bat 7
#define Melee_tonfa 8
#define Melee_crowbar 9
#define Melee_golfclub 10
#define Melee_Riotshield 11
#define Melee_knife 12
 

#define Melee_TwoMachete 20 
#define Melee_TwoMachete2 21 


#define Melee_Count 10

GetWeaopnType(entity)
{
	decl String:mclassname[64];
	GetEntPropString(entity, Prop_Data, "m_ModelName", mclassname, sizeof(mclassname));
	
	new type=0;
 
	if(StrContains(mclassname, "fireaxe")>=0)type=Melee_FireAxe;
	else if(StrContains(mclassname, "fireaxe")>=0)type=Melee_FireAxe;
	else if(StrContains(mclassname, "katana")>=0)type=Melee_Katana;
	else if(StrContains(mclassname, "machete")>=0)
	{
		type=Melee_Machete; 
	}
	else if(StrContains(mclassname, "electric_guitar")>=0)type=Melee_Guitar;
	else if(StrContains(mclassname, "tonfa")>=0)type=Melee_tonfa;
	else if(StrContains(mclassname, "frying_pan")>=0)type=Melee_pan;
	else if(StrContains(mclassname, "crowbar")>=0)type=Melee_crowbar;
	else if(StrContains(mclassname, "cricket_bat")>=0)type=Melee_cricket_bat;
	else if(StrContains(mclassname, "v_bat")>=0)type=Melee_bat;
	else if(StrContains(mclassname, "golfclub")>=0)type=Melee_golfclub;
        else if(StrContains(mclassname, "riotshield")>=0)type=Melee_Riotshield;
        else if(StrContains(mclassname, "knife")>=0)type=Melee_knife;
	return type;
}
Init()  
{
	SetRandomSeed(GetSysTickCount());

	for(new i=0; i<MAX_SIZE; i++)
	{
 		SoundName[i]="";
		for(new j=0; j<MAX_SIZE; j++)
		{
			MeleeChangeEnable[i][j]=0.0;
		}
	}  

	WeaponName[Melee_FireAxe]="models/weapons/melee/w_fireaxe.mdl"; 
	WeaponName[Melee_Katana]="models/weapons/melee/w_katana.mdl";
	WeaponName[Melee_Machete]="models/weapons/melee/w_machete.mdl";	
	WeaponName[Melee_Guitar]="models/weapons/melee/w_electric_guitar.mdl"; 
	WeaponName[Melee_pan]="models/weapons/melee/w_frying_pan.mdl"; 
	WeaponName[Melee_tonfa]="models/weapons/melee/w_tonfa.mdl";	
  	WeaponName[Melee_crowbar]="models/weapons/melee/w_crowbar.mdl";
	WeaponName[Melee_cricket_bat]="models/weapons/melee/w_cricket_bat.mdl";	 
	WeaponName[Melee_bat]="models/weapons/melee/w_bat.mdl";	
	WeaponName[Melee_golfclub]="models/weapons/melee/w_golfclub.mdl";
        WeaponName[Melee_Riotshield]="models/weapons/melee/w_riotshield.mdl";
        WeaponName[Melee_knife]="models/w_models/weapons/w_knife_t.mdl";



	SoundName[Melee_FireAxe]="weapons/machete/machete_impact_flesh1.wav"; 
	SoundName[Melee_Katana]="weapons/katana/melee_katana_01.wav";
	SoundName[Melee_Machete]="weapons/machete/machete_impact_flesh1.wav"; 
	SoundName[Melee_Guitar]="weapons/guitar/melee_guitar_05.wav"; 
	SoundName[Melee_pan]="weapons/pan/melee_frying_pan_01.wav"; 
	SoundName[Melee_tonfa]="weapons/tonfa/melee_tonfa_01.wav"; 
	SoundName[Melee_crowbar]="weapons/machete/machete_impact_flesh1.wav";
	SoundName[Melee_golfclub]="weapons/golf_club/wpn_golf_club_melee_01.wav"; 
                   SoundName[Melee_Riotshield]="weapons/tonfa/melee_tonfa_01.wav"; 
 	SoundName[Melee_knife]="weapons/machete/machete_impact_flesh1.wav"; 

     
	


	//MeleeChangeEnable[Melee_FireAxe][Melee_FireAxe]=2.0;
        
                   MeleeChangeEnable[Melee_FireAxe][Melee_FireAxe]=2.0;
	
	MeleeChangeEnable[Melee_Katana][Melee_Katana]=2.5; 
 	 
	MeleeChangeEnable[Melee_Machete][Melee_Machete]=2.5; 
 
	
	MeleeChangeEnable[Melee_Guitar][Melee_Guitar]=2.5;
	
	MeleeChangeEnable[Melee_pan][Melee_pan]=2.5;	
	
	MeleeChangeEnable[Melee_tonfa][Melee_tonfa]=2.5;		
	 
	MeleeChangeEnable[Melee_crowbar][Melee_crowbar]=2.5; 

                   MeleeChangeEnable[Melee_golfclub][Melee_golfclub]=2.5;

                   MeleeChangeEnable[Melee_bat][Melee_bat]=2.5;
           
                   MeleeChangeEnable[Melee_cricket_bat][Melee_cricket_bat]=1.5;
        
                  MeleeChangeEnable[Melee_Riotshield][Melee_Riotshield]=2.5;

                  MeleeChangeEnable[Melee_Riotshield][Melee_Riotshield]=2.5;

                  MeleeChangeEnable[Melee_knife][Melee_knife]=2.5;

	//MeleeBayonetEnable;
	 
}

public Action:Melee_SetTransmit(entity, client)
{  
	new owner=0;
	if(entity==MeleeEnt[client] || entity==MeleeEnt2[client] )
	{
		owner=client;
	}	
	if(owner>0 && canchienOn[client])
	{
		return Plugin_Handled;
	}
	return Plugin_Continue;
}

DeleteMelee(client)
{
	new ents[3];
	ents[0]=MeleeEnt[client];
	ents[1]=MeleeEnt2[client];
 
	MeleeEnt[client]=0;
	MeleeEnt2[client]=0;
	MeleeType[client]=0;
 
	for(new i=0; i<2; i++)
	{
		if(IsMeleeClone(ents[i]))
		{
			SDKUnhook(ents[i], SDKHook_SetTransmit, Melee_SetTransmit);
			AcceptEntityInput(ents[i], "ClearParent");
			AcceptEntityInput(ents[i], "kill");
		}
	}
	 
}
CreateMelee(client, activeWeapon)
{	 
	DeleteMelee(client); 
 	new weapon= MeleeType[client]=GetWeaopnType(activeWeapon);  
	if(MeleeChangeEnable[weapon][weapon]<=0.0)return;
	new Float:scale=MeleeChangeEnable[weapon][weapon]*GetConVarFloat(kichcocuacanchien);
 
	if(weapon==Melee_Machete)
	{
		MeleeEnt[client]=CreateMeleeClone(client,  Melee_Machete, Position_Melee,scale);
		MeleeEnt2[client]=CreateMeleeClone(client, Melee_Machete, Position_Melee2,scale );
		SDKHook(MeleeEnt[client], SDKHook_SetTransmit, Melee_SetTransmit);
		SDKHook(MeleeEnt2[client], SDKHook_SetTransmit, Melee_SetTransmit);
	}
	else if(weapon==Melee_TwoMachete2)
	{
		MeleeEnt[client]=CreateMeleeClone(client,  Melee_Machete, Position_Melee,scale);
		MeleeEnt2[client]=CreateMeleeClone(client, Melee_Machete, Position_Melee2,scale *0.7);
		SDKHook(MeleeEnt[client], SDKHook_SetTransmit, Melee_SetTransmit);
		SDKHook(MeleeEnt2[client], SDKHook_SetTransmit, Melee_SetTransmit);
	}
	else
	{
		MeleeEnt[client]=CreateMeleeClone(client,  weapon, Position_Melee,scale);
		MeleeEnt2[client]=0; 
		SDKHook(MeleeEnt[client], SDKHook_SetTransmit, Melee_SetTransmit);
	}
	HoldMeleeMutation[client]=true;
	Cuting[client]=false;
	CutingDistance[client]=0.0;
	CutingStartTime[client]=0.0;
	CutingMaxDamage[client]=GetConVarFloat(satthuongcongthem);
	CutingDamage[client]=CutingMaxDamage[client];
	CutingMaxDistance[client]=60.0*scale/2.0; 
}
public Action:weapon_fire(Handle:event, const String:name[], bool:dontBroadcast)
{ 
	 
	if(GetConVarInt(canchienphongto)==0)return Plugin_Continue;
	if(GetConVarFloat(satthuongcongthem)<=0.0)return Plugin_Continue;
 	new client = GetClientOfUserId(GetEventInt(event, "userid"));	 
	if(client>0 && GetClientTeam(client)==2)
	{
		if( HoldMeleeMutation[client] )
		{ 
			decl String:item[65];
			GetEventString(event, "weapon", item, 65);
			if( StrContains(item, "melee")>=0 )
			{
				new Float:time=GetEngineTime();
				Cuting[client]=true;
				CutingStartTime[client]=time;
				CutingDistance[client]=0.0;
				GetClientEyePosition(client, CutingStartPos[client]);
				decl Float:angle[3];
				GetClientEyeAngles(client, angle);
				GetAngleVectors(angle, CutingFrontDirection [client], NULL_VECTOR,NULL_VECTOR);
				GetAngleVectors(angle, NULL_VECTOR,CutingRightDirection [client],NULL_VECTOR);
				NormalizeVector(CutingFrontDirection [client], CutingFrontDirection [client]);
				NormalizeVector(CutingRightDirection [client], CutingRightDirection [client]);
				for(new i=0; i<=MaxClients; i++)CutingEnemy[client][i]=false;
			}			
		}		
	}
	return Plugin_Continue;
}
 
DoCut(client, Float:CutWidth=50.0, Float:Offset=20.0)
{ 
	
	decl Float:startPos[3]; 
	decl Float:left[3];
	decl Float:right[3];
	decl Float:temp[3];
	
	//CutingDamage[client]=CutingMaxDamage[client]*(CutingMaxDistance[client]-CutingDistance[client]*0.5)/CutingMaxDistance[client];
	//if(CutingDamage[client]<=0.0)CutingDamage[client]=0.0; 
	
	
	CopyVector(CutingStartPos[client], startPos);
	CopyVector(CutingRightDirection[client], temp);
	ScaleVector(temp, CutWidth);
	AddVectors(startPos, temp, right);
	SubtractVectors(startPos,temp, left);
	
	CopyVector(CutingFrontDirection[client], temp);
	ScaleVector(temp, CutingDistance[client]);	
	CutingDistance[client]+=Offset;	
	
	AddVectors(right, temp, right);
	AddVectors(left, temp, left);
	
	//ShowLaser(0, left, right, 0.06, 1.0, 1.0);	

	CutingHit[client]=0;
	new Handle:trace=TR_TraceRayFilterEx(left, right, MASK_ALL, RayType_EndPoint, DontHitSelf,client);
	TR_DidHit(trace);
 	CloseHandle(trace); 
	if(CutingHit[client]>0 && strlen(SoundName[MeleeType[client]])>1)
	{		 
		EmitSoundToAll(SoundName[MeleeType[client]], client,  SNDCHAN_WEAPON, SNDLEVEL_NORMAL, SND_NOFLAGS,0.5, SNDPITCH_NORMAL, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);

	}
}

CreatePointHurt()
{
	new pointHurt=CreateEntityByName("point_hurt");
	if(pointHurt)
	{
		DispatchKeyValue(pointHurt,"Damage","10");
		DispatchKeyValue(pointHurt,"DamageType","2");
		DispatchSpawn(pointHurt);
	}
	return pointHurt;
}
new String:N[20];
DoPointHurtForInfected(victim, attacker=0, Float:damage)
{
	if(g_PointHurt > 0)
	{
		if(IsValidEdict(g_PointHurt))
		{
			if(victim>0 && IsValidEdict(victim))
			{		
				Format(N, 20, "target%d", victim);
				DispatchKeyValue(victim,"targetname", N);
				DispatchKeyValue(g_PointHurt,"DamageTarget", N);
				//DispatchKeyValue(g_PointHurt,"classname","");
				DispatchKeyValueFloat(g_PointHurt,"Damage", damage);
				DispatchKeyValue(g_PointHurt,"DamageType","-2130706430"); //-2130706430 
				AcceptEntityInput(g_PointHurt,"Hurt",(attacker>0)?attacker:-1);
			}
		}
		else g_PointHurt=CreatePointHurt();
	}
	else g_PointHurt=CreatePointHurt();
}
public bool:DontHitSelf(entity, mask, any:data)
{
	if(entity == data) 
	{
		return false; 
	}
	if(entity == 0) 
	{
		
		return false; 
	}
	if(entity>0 && entity<=MaxClients)
	{
		if(IsClientInGame(entity) && GetClientTeam(entity)==2)return false; 
		if(CutingEnemy[data][entity])return false; 
		CutingEnemy[data][entity]=true;
	}	 
	else
	{
		decl String:name[64];
		GetEdictClassname(entity, name, 64);
		if(!StrEqual(name, "infected"))
		{
			return false;
		}
	}
	CutingHit[data]++;
	DoPointHurtForInfected(entity, data, CutingDamage[data] );	 	 
	return false;
}
CreateMeleeClone(client, replaceWeaopn, position, Float:scale )
{
	
	new weapon=replaceWeaopn;  
	
	new melee=CreateEntityByName("prop_dynamic_override");    
	SetEntityModel(melee, WeaponName[weapon]);
	DispatchSpawn(melee); 
	
	new owner=client;
	//owner=256;
	decl String:tname[60];
	Format(tname, sizeof(tname), "target%d", owner);
	DispatchKeyValue(owner, "targetname", tname); 		
	DispatchKeyValue(melee, "parentname", tname);
	
	SetVariantString(tname);
	AcceptEntityInput(melee, "SetParent",melee, melee, 0); 	 
	SetVariantString("weapon_bone"); //weapon_bone
	AcceptEntityInput(melee, "SetParentAttachment"); 
	 
 	
	new Float:pos[3];
	new Float:ang[3]; 
	GetPosAng( pos, ang,position); 
 	
	TeleportEntity(melee, pos, ang, NULL_VECTOR);
 
 	SetEntProp(melee, Prop_Send, "m_CollisionGroup", 2);   
 	SetEntProp(melee, Prop_Send, "m_iGlowType", 3 ); //3
	SetEntProp(melee, Prop_Send, "m_nGlowRange", 0 ); //0
	SetEntProp(melee, Prop_Send, "m_glowColorOverride",  1); //1
	
	SetEntPropFloat(melee , Prop_Send,"m_flModelScale" ,scale);  
	return melee;
} 
GetPosAng(Float:pos[3],  Float:ang[3], position )
{ 
	if(position==Position_Melee)
	{
		SetVector(pos,  0.0, 0.0, 0.0); 
		SetVector(ang, 270.0, 270.0,0.0);
	}
	else if(position==Position_Melee2)
	{
		SetVector(pos,  0.0, 0.0, 0.0); 
		SetVector(ang, 270.0, 90.0,0.0);
	}	
	else if(position==Position_Bayonet)
	{
		SetVector(pos,  0.0,  1.0, 23.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
	else if(position==Position_Bayonet_grenade_launcher)
	{
		SetVector(pos,  0.0,  2.0, 20.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
	else if(position==Position_Bayonet_m60)
	{
		SetVector(pos,  0.0,  2.5, 32.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	} 
	else if(position==Position_Bayonet_sniper)
	{
		SetVector(pos,  0.0,  2.0, 28.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
	else if(position==Position_Bayonet_scout)
	{
		SetVector(pos,  0.0,  1.5, 23.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
 	else if(position==Position_Bayonet_hunting)
	{
		SetVector(pos,  0.0,  2.5, 23.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	} 	
	else if(position==Position_Bayonet_smg)
	{
		SetVector(pos,  0.0,  1.0, 12.0); 
		SetVector(ang, 0.0, 270.0,0.0);	 
	} 
	else if(position==Position_Bayonet_mp5)
	{
		SetVector(pos,  0.0,  2.5, 15.0); 
		SetVector(ang, 0.0, 270.0,0.0);	 
	} 
	else if(position==Position_Bayonet_desert)
	{
		SetVector(pos,  0.0,  1.5, 20.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}
	else if(position==Position_Bayonet_sg552)
	{
		SetVector(pos,  0.0,  1.5, 15.0); 
		SetVector(ang, 0.0, 270.0,0.0);			
	}	
}
 

SetVector(Float:target[3], Float:x, Float:y, Float:z)
{
	target[0]=x;
	target[1]=y;
	target[2]=z;
}
IsInfected(client, type)
{
	new class = GetEntProp(client, Prop_Send, "m_zombieClass");
	if(type==class)return true;
	else return false;
}

public Action:player_spawn(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
	new client = GetClientOfUserId(GetEventInt(hEvent, "userid"));   
	if(client>0)
	{ 
		ResetClientState(client);
		Stop(client);
	}
}

public Action:player_death(Handle:hEvent, const String:strName[], bool:DontBroadcast)
{ 
	new victim = GetClientOfUserId(GetEventInt(hEvent, "userid")); 
	if(victim>0 && victim<=MaxClients)
	{
		DeleteMelee(victim);
		ResetClientState(victim);
		Stop(victim);
	}
	return Plugin_Continue;	 
}
public player_bot_replace(Handle:Spawn_Event, const String:Spawn_Name[], bool:Spawn_Broadcast)
{
 	new client = GetClientOfUserId(GetEventInt(Spawn_Event, "player"));
	new bot = GetClientOfUserId(GetEventInt(Spawn_Event, "bot"));   
	 
	if(client>0)
	{
		DeleteMelee(client);
		ResetClientState(client);
		Stop(client);		
	}
	if(bot>0)
	{
		ResetClientState(bot);
		Stop(bot);	
	}
}
public bot_player_replace(Handle:Spawn_Event, const String:Spawn_Name[], bool:Spawn_Broadcast)
{
 	new client = GetClientOfUserId(GetEventInt(Spawn_Event, "player"));
	new bot = GetClientOfUserId(GetEventInt(Spawn_Event, "bot"));   
	 
	if(bot>0)
	{
		ResetClientState(bot);
		Stop(bot);	
	}
	if(client>0)
	{
		 ResetClientState(client);
		 Stop(client);	
	}

}
public Action:round_start(Handle:event, const String:name[], bool:dontBroadcast)
{
	StopAll();
	ResetAllState();
}
public Action:round_end(Handle:event, const String:name[], bool:dontBroadcast)
{
	StopAll();
	ResetAllState();
}
ResetAllState()
{
	for(new i=1; i<=MaxClients; i++)
	{
		ResetClientState(i);
	}
}
ResetClientState(i)
{
	LastWeapon[i]=0;
	MeleeEnt[i]=0;
	MeleeEnt2[i]=0;
	MeleeType[i]=0;  
	 
	canchienOn[i]=false;
	Cuting[i]=false;
	CutingStartTime[i]=0.0;
	HoldMeleeMutation[i]=false;
	g_PointHurt=0;
}
public OnMapStart()
{ 
	if(L4D2Version)
	{
		for(new i=1; i<MAX_SIZE; i++)
		{
			if(strlen(WeaponName[i])>1)PrecacheModel(WeaponName[i]);
		}
		for(new i=1; i<MAX_SIZE; i++)
		{
			if(strlen(SoundName[i])>1)PrecacheSound(SoundName[i]);
		}
 	}
	
	if(L4D2Version)
	{
		g_sprite = PrecacheModel("materials/sprites/laserbeam.vmt");	
	 
	}
	else
	{
		g_sprite = PrecacheModel("materials/sprites/laser.vmt");	
		 	
	}
	ResetAllState();
}
 
CopyVector(Float:source[3], Float:target[3])
{
	target[0]=source[0];
	target[1]=source[1];
	target[2]=source[2];
}
ShowLaser(colortype,Float:pos1[3], Float:pos2[3], Float:life=10.0,  Float:width1=1.0, Float:width2=11.0)
{
	decl color[4];
	if(colortype==1)
	{
		color[0] = 200; 
		color[1] = 0;
		color[2] = 0;
		color[3] = 230; 
	}
	else if(colortype==2)
	{
		color[0] = 0; 
		color[1] = 200;
		color[2] = 0;
		color[3] = 230; 
	}
	else if(colortype==3)
	{
		color[0] = 0; 
		color[1] = 0;
		color[2] = 200;
		color[3] = 230; 
	}
	else 
	{
		color[0] = 200; 
		color[1] = 200;
		color[2] = 200;
		color[3] = 230; 		
	}

	
	TE_SetupBeamPoints(pos1, pos2, g_sprite, 0, 0, 0, life, width1, width2, 1, 0.0, color, 0);
	TE_SendToAll();
}
 